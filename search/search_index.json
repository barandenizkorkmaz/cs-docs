{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Hi \ud83d\udc4b, Welcome to SWE Resources This site has been created for learning purposes and contains my self notes. Please support my work if you find it useful by giving the repository a \u2b50. About Me \ud83c\udf93 I am currently pursuing my Master's degree in Computer Science in Technical University of Munich . \ud83c\udf93 I studied my Bachelor's in Computer Engineering in Bo\u011fazi\u00e7i University . \ud83d\udcbb I am currently doing my Master's Thesis at Siemens AG . \ud83d\udcbb Previously at Infineon Technologies AG , Huawei Technologies , Pointr , and SAS Institute . \ud83d\udd0e I am interested in Software Engineering (Software Development, System Design, Cloud Information Systems) , Artificial Intelligence, Computer Vision, Quantum Computing, and Blockchain. \ud83e\udd73 In my free times, I enjoy Football, Formula 1, Chess, Guitar, and Movies. \u2709\ufe0f Feel free to reach me via bdkorkmazdeveloper@gmail.com ! \ud83d\udcc4 For a more detailed background about me, check out my resume ! Connect with me \ud83e\udd1d Author's Notes \ud83d\udea8 Some pages contain typos and misrendered syntax due to incompatibility between Markdown editor I am using and Markdown syntax rendered by MkDocs. All the issues will be resolved as soon as possible.","title":"Home"},{"location":"algorithms/sorting/sorting.html","text":"Sorting Sorting in Java The Java API java.util provides a class Arrays with several overloaded sort methods for different array types. In addition, the class Collections (also part of the API java.util) con- tains similar sorting methods for Lists. The methods for arrays of primitive types are based on the quicksort algorithm (Section 8.9), and the methods for arrays of Objects and for Lists are based on the Timsort algorithm (Section 8.7). Both algorithms are O(n log n). Method Arrays.sort is defined as a public static void method and is overloaded (see Table 8.1). The first argument in a call can be an array of any primitive type (although we have just shown int[]) or an array of objects. If the first argument is an array of objects, then either the class type of the array must implement the Comparable interface or a Comparator object must be passed as the last argument (see Section 6.6). A class that implements the Comparable interface must define a compareTo method that determines the natural ordering of its objects. If a Comparator is passed, its compare method will be used to determine the ordering. For method Collections.sort (see Table 8.1), the first argument must be a collection of objects that implement the List interface (e.g., an ArrayList or a LinkedList). If only one argument is provided, the objects in the List must implement the Comparable interface. Method compareTo is called by the sorting method to determine the relative ordering of two objects. Optionally, a Comparator can be passed as a second argument. Using a Comparator, you can compare objects based on some other information rather than using their natural ordering (as determined by method compareTo). The Comparator object must be the last argument in the call to the sorting method. Rather than rearranging the elements in the List, method sort first copies the List elements to an array, sorts the array using Arrays.sort, and then copies them back to the List. Method sort in Class Arrays Description sort(int[] items) Sorts the array items in ascending order sort(int[] items, int fromIndex, int toIndex) Sorts array elements items[fromIndex] to items[toIndex] in ascending order sort(Object[] items) Sorts the objects in array items in ascending order using their natural ordering (defined by compareTo ) sort(Object[] items, int fromIndex, int toIndex) Sorts array elements items[fromIndex] to items[toIndex] in ascending order using natural ordering <T> void sort(T[] items, Comparator<? super T> comp) Sorts the objects in items in ascending order as defined by method comp.compare <T> void sort(T[] items, int fromIndex, int toIndex, Comparator<? super T> comp) Sorts array elements items[fromIndex] to items[toIndex] in ascending order using method comp.compare Method sort in Class Collections Description <T extends Comparable<T>> void sort(List<T> list) Sorts the objects in list in ascending order using their natural ordering (defined by compareTo ) <T> void sort(List<T> list, Comparator<? super T> comp) Sorts the objects in list in ascending order as defined by method comp.compare Method sort in Interface List Description default void sort(Comparator<? super E> comp) Sorts the objects in the list in ascending order as defined by method comp.compare For the second method parameter, the notation Comparator<? super T> means that comp must be an object that implements the Comparator interface for type T or for a superclass of type T. In Java 8, you can pass a lambda expression as a Comparator object to the List.sort method instead of writing a class that implements Comparator . Selection Sort Algorithm 1. for fill = 0 to n \u2013 2 do 2. Set posMin to the subscript of the smallest item in the subarray starting at subscript fill. 3. Exchange the item at posMin with the one at fill. Refinement of Selection Sort Algorithm (Step 2) 2.1 Initialize posMin to fill. 2.2 for next = fill + 1 to n \u2010 1 2.3 if the item at next is less than the item at posMin 2.4 Reset posMin to next. Implementation /** Implements the selection sort algorithm. */ public class SelectionSort { /** Sort the array using selection sort algorithm. @pre table contains Comparable objects. @post table is sorted. @param table The array to be sorted */ public static void sort(Comparable[] table) { int n = table.length; for (int fill = 0; fill < n - 1; fill++) { // Invariant: table[0 . . . fill \u2013 1] is sorted. int posMin = fill; for (int next = fill + 1; next < n; next++) { // Invariant: table[posMin] is the smallest item in // table[fill . . . next \u2010 1]. if (table[next].compareTo(table[posMin]) < 0) { posMin = next; } } // assert: table[posMin] is the smallest item in // table[fill . . . n \u2010 1]. // Exchange table[fill] and table[posMin]. Comparable temp = table[fill]; table[fill] = table[posMin]; table[posMin] = temp; // assert: table[fill] is the smallest item in // table[fill . . . n \u2010 1]. } // assert: table[0 . . . n \u2010 1] is sorted. } } Analysis The number of comparisons is O(n^2) . The number of exchanges is O(n) . The selection sort is a quadratic sort. PROGRAM STYLE Making Sort Methods Generic The code above will compile, but it will generate a warning message regarding an unchecked call to compareTo . You can eliminate this warning message by making the sort a generic sort. To accomplish this for the sort above, change the method heading to public static <T extends Comparable<T>> void sort(T[] table) { where the generic type parameter, T, must implement the Comparable interface. Also, change the data type of variable temp from Comparable to type T, the data type of the array elements. T temp = table[fill]; We will code the other sorting algorithms in this chapter as generic methods. Insertion Sort Algorithm 1. for each array element from the second (nextPos = 1) to the last 2. Insert the element at nextPos where it belongs in the array, increasing the length of the sorted subarray by 1 element. Refinement of Insertion Sort Algorithm (Step 2) 2.1 nextPos is the position of the element to insert. 2.2 Save the value of the element to insert in nextVal. 2.3 while nextPos > 0 and the element at nextPos \u2013 1 > nextVal 2.4 Shift the element at nextPos \u2013 1 to position nextPos. 2.5 Decrement nextPos by 1. 2.6 Insert nextVal at nextPos. Implementation /** Implements the insertion sort algorithm. */ public class InsertionSort { /** * Sort the table using insertion sort algorithm. * @pre table contains Comparable objects. * @post table is sorted. * @param table The array to be sorted */ public static <T extends Comparable<T>> void sort(T[] table) { for (int nextPos = 1; nextPos < table.length; nextPos++) { // Invariant: table[0 . . . nextPos - 1] is sorted. // Insert element at position nextPos in the sorted subarray. insert(table, nextPos); } // End for. } // End sort. /** * Insert the element at nextPos where it belongs in the array. * @pre table[0 . . . nextPos - 1] is sorted. * @post table[0 . . . nextPos] is sorted. * @param table The array being sorted. * @param nextPos The position of the element to insert. */ private static <T extends Comparable<T>> void insert(T[] table, int nextPos) { T nextVal = table[nextPos]; // Element to insert. while (nextPos > 0 && nextVal.compareTo(table[nextPos - 1]) < 0) { table[nextPos] = table[nextPos - 1]; // Shift down. nextPos--; // Check next smaller element. } // Insert nextVal at nextPos. table[nextPos] = nextVal; } } We use the method insert to perform the insertion step so that it would be easier to implement the Shell sort algorithm later. Analysis The maximum number of comparisons is represented by the series 1 + 2 + ... + (n -2) + (n -1) , which is O(n^2) . \ud83d\udea8 More on This Chapter Coming Soon!","title":"Sorting"},{"location":"algorithms/sorting/sorting.html#sorting","text":"","title":"Sorting"},{"location":"algorithms/sorting/sorting.html#sorting-in-java","text":"The Java API java.util provides a class Arrays with several overloaded sort methods for different array types. In addition, the class Collections (also part of the API java.util) con- tains similar sorting methods for Lists. The methods for arrays of primitive types are based on the quicksort algorithm (Section 8.9), and the methods for arrays of Objects and for Lists are based on the Timsort algorithm (Section 8.7). Both algorithms are O(n log n). Method Arrays.sort is defined as a public static void method and is overloaded (see Table 8.1). The first argument in a call can be an array of any primitive type (although we have just shown int[]) or an array of objects. If the first argument is an array of objects, then either the class type of the array must implement the Comparable interface or a Comparator object must be passed as the last argument (see Section 6.6). A class that implements the Comparable interface must define a compareTo method that determines the natural ordering of its objects. If a Comparator is passed, its compare method will be used to determine the ordering. For method Collections.sort (see Table 8.1), the first argument must be a collection of objects that implement the List interface (e.g., an ArrayList or a LinkedList). If only one argument is provided, the objects in the List must implement the Comparable interface. Method compareTo is called by the sorting method to determine the relative ordering of two objects. Optionally, a Comparator can be passed as a second argument. Using a Comparator, you can compare objects based on some other information rather than using their natural ordering (as determined by method compareTo). The Comparator object must be the last argument in the call to the sorting method. Rather than rearranging the elements in the List, method sort first copies the List elements to an array, sorts the array using Arrays.sort, and then copies them back to the List. Method sort in Class Arrays Description sort(int[] items) Sorts the array items in ascending order sort(int[] items, int fromIndex, int toIndex) Sorts array elements items[fromIndex] to items[toIndex] in ascending order sort(Object[] items) Sorts the objects in array items in ascending order using their natural ordering (defined by compareTo ) sort(Object[] items, int fromIndex, int toIndex) Sorts array elements items[fromIndex] to items[toIndex] in ascending order using natural ordering <T> void sort(T[] items, Comparator<? super T> comp) Sorts the objects in items in ascending order as defined by method comp.compare <T> void sort(T[] items, int fromIndex, int toIndex, Comparator<? super T> comp) Sorts array elements items[fromIndex] to items[toIndex] in ascending order using method comp.compare Method sort in Class Collections Description <T extends Comparable<T>> void sort(List<T> list) Sorts the objects in list in ascending order using their natural ordering (defined by compareTo ) <T> void sort(List<T> list, Comparator<? super T> comp) Sorts the objects in list in ascending order as defined by method comp.compare Method sort in Interface List Description default void sort(Comparator<? super E> comp) Sorts the objects in the list in ascending order as defined by method comp.compare For the second method parameter, the notation Comparator<? super T> means that comp must be an object that implements the Comparator interface for type T or for a superclass of type T. In Java 8, you can pass a lambda expression as a Comparator object to the List.sort method instead of writing a class that implements Comparator .","title":"Sorting in Java"},{"location":"algorithms/sorting/sorting.html#selection-sort","text":"","title":"Selection Sort"},{"location":"algorithms/sorting/sorting.html#algorithm","text":"1. for fill = 0 to n \u2013 2 do 2. Set posMin to the subscript of the smallest item in the subarray starting at subscript fill. 3. Exchange the item at posMin with the one at fill. Refinement of Selection Sort Algorithm (Step 2) 2.1 Initialize posMin to fill. 2.2 for next = fill + 1 to n \u2010 1 2.3 if the item at next is less than the item at posMin 2.4 Reset posMin to next.","title":"Algorithm"},{"location":"algorithms/sorting/sorting.html#implementation","text":"/** Implements the selection sort algorithm. */ public class SelectionSort { /** Sort the array using selection sort algorithm. @pre table contains Comparable objects. @post table is sorted. @param table The array to be sorted */ public static void sort(Comparable[] table) { int n = table.length; for (int fill = 0; fill < n - 1; fill++) { // Invariant: table[0 . . . fill \u2013 1] is sorted. int posMin = fill; for (int next = fill + 1; next < n; next++) { // Invariant: table[posMin] is the smallest item in // table[fill . . . next \u2010 1]. if (table[next].compareTo(table[posMin]) < 0) { posMin = next; } } // assert: table[posMin] is the smallest item in // table[fill . . . n \u2010 1]. // Exchange table[fill] and table[posMin]. Comparable temp = table[fill]; table[fill] = table[posMin]; table[posMin] = temp; // assert: table[fill] is the smallest item in // table[fill . . . n \u2010 1]. } // assert: table[0 . . . n \u2010 1] is sorted. } }","title":"Implementation"},{"location":"algorithms/sorting/sorting.html#analysis","text":"The number of comparisons is O(n^2) . The number of exchanges is O(n) . The selection sort is a quadratic sort.","title":"Analysis"},{"location":"algorithms/sorting/sorting.html#program-style","text":"","title":"PROGRAM STYLE"},{"location":"algorithms/sorting/sorting.html#making-sort-methods-generic","text":"The code above will compile, but it will generate a warning message regarding an unchecked call to compareTo . You can eliminate this warning message by making the sort a generic sort. To accomplish this for the sort above, change the method heading to public static <T extends Comparable<T>> void sort(T[] table) { where the generic type parameter, T, must implement the Comparable interface. Also, change the data type of variable temp from Comparable to type T, the data type of the array elements. T temp = table[fill]; We will code the other sorting algorithms in this chapter as generic methods.","title":"Making Sort Methods Generic"},{"location":"algorithms/sorting/sorting.html#insertion-sort","text":"","title":"Insertion Sort"},{"location":"algorithms/sorting/sorting.html#algorithm_1","text":"1. for each array element from the second (nextPos = 1) to the last 2. Insert the element at nextPos where it belongs in the array, increasing the length of the sorted subarray by 1 element. Refinement of Insertion Sort Algorithm (Step 2) 2.1 nextPos is the position of the element to insert. 2.2 Save the value of the element to insert in nextVal. 2.3 while nextPos > 0 and the element at nextPos \u2013 1 > nextVal 2.4 Shift the element at nextPos \u2013 1 to position nextPos. 2.5 Decrement nextPos by 1. 2.6 Insert nextVal at nextPos.","title":"Algorithm"},{"location":"algorithms/sorting/sorting.html#implementation_1","text":"/** Implements the insertion sort algorithm. */ public class InsertionSort { /** * Sort the table using insertion sort algorithm. * @pre table contains Comparable objects. * @post table is sorted. * @param table The array to be sorted */ public static <T extends Comparable<T>> void sort(T[] table) { for (int nextPos = 1; nextPos < table.length; nextPos++) { // Invariant: table[0 . . . nextPos - 1] is sorted. // Insert element at position nextPos in the sorted subarray. insert(table, nextPos); } // End for. } // End sort. /** * Insert the element at nextPos where it belongs in the array. * @pre table[0 . . . nextPos - 1] is sorted. * @post table[0 . . . nextPos] is sorted. * @param table The array being sorted. * @param nextPos The position of the element to insert. */ private static <T extends Comparable<T>> void insert(T[] table, int nextPos) { T nextVal = table[nextPos]; // Element to insert. while (nextPos > 0 && nextVal.compareTo(table[nextPos - 1]) < 0) { table[nextPos] = table[nextPos - 1]; // Shift down. nextPos--; // Check next smaller element. } // Insert nextVal at nextPos. table[nextPos] = nextVal; } } We use the method insert to perform the insertion step so that it would be easier to implement the Shell sort algorithm later.","title":"Implementation"},{"location":"algorithms/sorting/sorting.html#analysis_1","text":"The maximum number of comparisons is represented by the series 1 + 2 + ... + (n -2) + (n -1) , which is O(n^2) .","title":"Analysis"},{"location":"algorithms/sorting/sorting.html#more-on-this-chapter-coming-soon","text":"","title":"\ud83d\udea8 More on This Chapter Coming Soon!"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-1-arrays.html","text":"1. Arrays Overview Fixed length once initialized. Add or remove element at a specified position without shifting the other elements to make room/fill in the resulting gap. One feature that the array data structure provides that these classes (List classes) don\u2019t is the ability to store primitive\u2010type values. The List classes all store references to Objects, so all primitive\u2010type values must be wrapped in objects. Note that all generic classes in Java extends Object class. NOTE: Circular array implementation will be shown in Queue chapter. Performance Operations/Complexity Best-Case Average-Case Worst-Case Add O(1) (add to the end) O(N) O(N) Delete O(1) (delete from the end) O(N) O(N) Search O(1) O(N) O(N) Get O(1) O(1) O(1) Class java.util.Arrays Method Summary Modifier and Type Method Description static boolean equals(Object[] a, Object[] a2) Returns true if the two specified arrays of Objects are equal to one another. static void fill(Object[] a, Object val) Assigns the specified Object reference to each element of the specified array of Objects. static \\ T[] copyOf(T[] original, int newLength) Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. static \\ T[] copyOfRange(T[] original, int from, int to) Copies the specified range of the specified array into a new array. static String toString(Object[] a) Returns a string representation of the contents of the specified array. static void sort(Object[] a) Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. static \\ void sort(T[] a, Comparator<? super T> c) Sorts the specified array of objects according to the order induced by the specified comparator. int size() Returns the number of elements in this list. static int binarySearch(Object[] a, Object key) Searches the specified array for the specified object using the binary search algorithm. Reference: https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html // A more general method of copying an array System.arraycopy(source, sourcePos, destination, destPos, numElements);","title":"Arrays"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-1-arrays.html#1-arrays","text":"","title":"1. Arrays"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-1-arrays.html#overview","text":"Fixed length once initialized. Add or remove element at a specified position without shifting the other elements to make room/fill in the resulting gap. One feature that the array data structure provides that these classes (List classes) don\u2019t is the ability to store primitive\u2010type values. The List classes all store references to Objects, so all primitive\u2010type values must be wrapped in objects. Note that all generic classes in Java extends Object class. NOTE: Circular array implementation will be shown in Queue chapter.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-1-arrays.html#performance","text":"Operations/Complexity Best-Case Average-Case Worst-Case Add O(1) (add to the end) O(N) O(N) Delete O(1) (delete from the end) O(N) O(N) Search O(1) O(N) O(N) Get O(1) O(1) O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-1-arrays.html#class-javautilarrays","text":"","title":"Class java.util.Arrays"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-1-arrays.html#method-summary","text":"Modifier and Type Method Description static boolean equals(Object[] a, Object[] a2) Returns true if the two specified arrays of Objects are equal to one another. static void fill(Object[] a, Object val) Assigns the specified Object reference to each element of the specified array of Objects. static \\ T[] copyOf(T[] original, int newLength) Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. static \\ T[] copyOfRange(T[] original, int from, int to) Copies the specified range of the specified array into a new array. static String toString(Object[] a) Returns a string representation of the contents of the specified array. static void sort(Object[] a) Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. static \\ void sort(T[] a, Comparator<? super T> c) Sorts the specified array of objects according to the order induced by the specified comparator. int size() Returns the number of elements in this list. static int binarySearch(Object[] a, Object key) Searches the specified array for the specified object using the binary search algorithm. Reference: https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html // A more general method of copying an array System.arraycopy(source, sourcePos, destination, destPos, numElements);","title":"Method Summary"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-2-list-interface.html","text":"2. List Interface Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list (optional operation). void add(int index, E element) Inserts the specified element at the specified position in this list (optional operation). E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list (optional operation). boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present (optional operation). E set(int index, E element) Replaces the element at the specified position in this list with the specified element (optional operation). int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element).","title":"List Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-2-list-interface.html#2-list-interface","text":"Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list (optional operation). void add(int index, E element) Inserts the specified element at the specified position in this list (optional operation). E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list (optional operation). boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present (optional operation). E set(int index, E element) Replaces the element at the specified position in this list with the specified element (optional operation). int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element).","title":"2. List Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html","text":"3. ArrayList Overview Java uses array internally to contain the data of a ArrayList . The physical size of the array is indicated by the data field capacity . The number of data items is indicated by the data field size . The data type of the references stored in the underlying array theData (type E[]) is also determined when the MyArrayList object is declared. If no parameter type is specified, the implicit parameter type is Object, and the underlying data array is type Object[]. Class java.util.ArrayList<E> Modifier and Type Method and Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Implementation import java.util.AbstractList; import java.util.Arrays; import java.util.List; public class MyArrayList<E> extends AbstractList<E> implements List<E> { // Data Fields /** The default initial capacity */ private static final int INITIAL_CAPACITY = 10; /** The underlying data array */ private E[] data; /** The current size */ private int size = 0; /** The current capacity */ private int capacity = 0; @SuppressWarnings(\"unchecked\") public MyArrayList(){ this.capacity = INITIAL_CAPACITY; data = (E[]) new Object[capacity]; } public boolean add(E anEntry) { if (size == capacity) { reallocate(); } data[size] = anEntry; size++; return true; } public void add(int index, E anEntry) { if (index < 0 || index > size) { throw new ArrayIndexOutOfBoundsException(index); } if (size == capacity) { reallocate(); } // Shift data in elements from index to size \u2010 1 for (int i = size; i > index; i--) { data[i] = data[i - 1]; } // Insert the new item. data[index] = anEntry; size++; } public E get(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } return data[index]; } public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E oldValue = data[index]; data[index] = newValue; return oldValue; } public E remove(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E returnValue = data[index]; for (int i = index + 1; i < size; i++) { data[i - 1] = data[i]; } size--; return returnValue; } private void reallocate() { capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } public int size() { return this.size; } } Performance Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(1) add(int index, E element) O(N) get(int index) O(1) set(int index, E element) O(1) remove(int index) O(N) remove(Object o) O(N) size() O(1) Recall that when we reallocate the array, we double its size. Doubling an array of size n allows us to add n more items before we need to do another array copy. Therefore, we can add n new items after we have copied over n existing items. This averages out to 1 copy per add. Therefore, reallocation is effectively an O(1) operation, so the insertion (to any index) is still O(n). Extra Syntax: Creating a Generic Collection FORM: CollectionClassName\\ variable = new CollectionClassName<>(); CollectionClassName\\ variable = new CollectionClassName\\ (); EXAMPLE: List\\ people = new ArrayList<>(); List\\ myList = new ArrayList\\ (); ArrayList\\ numList = new ArrayList<>(); MEANING: An initially empty CollectionClassName\\ object is created that can be used to store references to objects of type E (the type parameter). The actual object type stored in an object of type CollectionClassName\\ is specified when the object is created. If the CollectionClassName on the left is an interface, the CollectionClassName on the right must be a class that implements it. Otherwise, it must be the same class or a subclass of the one on the left. The examples above show different ways to create an ArrayList. In this text, we normally specify the interface name on the left of the = operator and the implementing class name on the right as shown in the first two examples. Since the type parameter E must be the same on both sides of the assignment operator, Java 7 introduced the diamond operator <> which eliminates the need to specify the type parameter twice. We will follow this convention. In some cases, we will declare the variable type in one statement and create it in a later statement. In earlier versions of Java, generic collections were not supported. In these versions, you use the statement List yourList = new ArrayList(); to create an initially empty ArrayList. Each element of yourList is a type Object reference. The data types of the actual objects referenced by elements of yourList are not specified, and in fact, different elements can reference objects of different types. Use of the adjective \u201cgeneric\u201d is a bit confusing. A nongeneric collection in Java is very general in that it can store objects of different data types. A generic collection, however, can store objects of one specified data type only. Therefore, generics enable the compiler to do more strict type checking to detect errors at compile time instead of at run time. They also eliminate the need to downcast from type Object to a specific type. For these reasons, we will always use generic collections. Constructor Declaration for Generic Classes The constructor declaration follows. Because the constructor is for a generic class, the type parameter \\ is implied but it must not appear in the constructor heading. \u200b public MyArrayList() { \u200b capacity = INITIAL_CAPACITY; \u200b data = (E[]) new Object[capacity]; \u200b } The statement data = (E[]) new Object[capacity]; allocates storage for an array with type Object references and then casts this array object to type E[] so that it is type compatible with variable theData. Because the actual type corresponding to E is not known, the compiler issues the warning message: MyArrayList.java uses unchecked or unsafe operations. Don\u2019t be concerned about this warning\u2014everything is fine. PITFALL Declaring a Generic Array Rather than use the approach shown in the above constructor, you might try to create a generic array directly using the statement theData = new E[capacity]; // Invalid generic array type. However, this statement will not compile because Java does not allow you to create an array with an unspecified type. Remember, E is a type parameter that is not specified until a generic ArrayList object is created. Therefore, the constructor must create an array of type Object[] since Object is the superclass of all types and then downcast this array object to type E[].","title":"ArrayLists"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#3-arraylist","text":"","title":"3. ArrayList"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#overview","text":"Java uses array internally to contain the data of a ArrayList . The physical size of the array is indicated by the data field capacity . The number of data items is indicated by the data field size . The data type of the references stored in the underlying array theData (type E[]) is also determined when the MyArrayList object is declared. If no parameter type is specified, the implicit parameter type is Object, and the underlying data array is type Object[].","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#class-javautilarrayliste","text":"Modifier and Type Method and Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element).","title":"Class java.util.ArrayList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#implementation","text":"import java.util.AbstractList; import java.util.Arrays; import java.util.List; public class MyArrayList<E> extends AbstractList<E> implements List<E> { // Data Fields /** The default initial capacity */ private static final int INITIAL_CAPACITY = 10; /** The underlying data array */ private E[] data; /** The current size */ private int size = 0; /** The current capacity */ private int capacity = 0; @SuppressWarnings(\"unchecked\") public MyArrayList(){ this.capacity = INITIAL_CAPACITY; data = (E[]) new Object[capacity]; } public boolean add(E anEntry) { if (size == capacity) { reallocate(); } data[size] = anEntry; size++; return true; } public void add(int index, E anEntry) { if (index < 0 || index > size) { throw new ArrayIndexOutOfBoundsException(index); } if (size == capacity) { reallocate(); } // Shift data in elements from index to size \u2010 1 for (int i = size; i > index; i--) { data[i] = data[i - 1]; } // Insert the new item. data[index] = anEntry; size++; } public E get(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } return data[index]; } public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E oldValue = data[index]; data[index] = newValue; return oldValue; } public E remove(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E returnValue = data[index]; for (int i = index + 1; i < size; i++) { data[i - 1] = data[i]; } size--; return returnValue; } private void reallocate() { capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } public int size() { return this.size; } }","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#performance","text":"Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(1) add(int index, E element) O(N) get(int index) O(1) set(int index, E element) O(1) remove(int index) O(N) remove(Object o) O(N) size() O(1) Recall that when we reallocate the array, we double its size. Doubling an array of size n allows us to add n more items before we need to do another array copy. Therefore, we can add n new items after we have copied over n existing items. This averages out to 1 copy per add. Therefore, reallocation is effectively an O(1) operation, so the insertion (to any index) is still O(n).","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#extra","text":"","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#syntax-creating-a-generic-collection","text":"FORM: CollectionClassName\\ variable = new CollectionClassName<>(); CollectionClassName\\ variable = new CollectionClassName\\ (); EXAMPLE: List\\ people = new ArrayList<>(); List\\ myList = new ArrayList\\ (); ArrayList\\ numList = new ArrayList<>(); MEANING: An initially empty CollectionClassName\\ object is created that can be used to store references to objects of type E (the type parameter). The actual object type stored in an object of type CollectionClassName\\ is specified when the object is created. If the CollectionClassName on the left is an interface, the CollectionClassName on the right must be a class that implements it. Otherwise, it must be the same class or a subclass of the one on the left. The examples above show different ways to create an ArrayList. In this text, we normally specify the interface name on the left of the = operator and the implementing class name on the right as shown in the first two examples. Since the type parameter E must be the same on both sides of the assignment operator, Java 7 introduced the diamond operator <> which eliminates the need to specify the type parameter twice. We will follow this convention. In some cases, we will declare the variable type in one statement and create it in a later statement. In earlier versions of Java, generic collections were not supported. In these versions, you use the statement List yourList = new ArrayList(); to create an initially empty ArrayList. Each element of yourList is a type Object reference. The data types of the actual objects referenced by elements of yourList are not specified, and in fact, different elements can reference objects of different types. Use of the adjective \u201cgeneric\u201d is a bit confusing. A nongeneric collection in Java is very general in that it can store objects of different data types. A generic collection, however, can store objects of one specified data type only. Therefore, generics enable the compiler to do more strict type checking to detect errors at compile time instead of at run time. They also eliminate the need to downcast from type Object to a specific type. For these reasons, we will always use generic collections.","title":"Syntax: Creating a Generic Collection"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#constructor-declaration-for-generic-classes","text":"The constructor declaration follows. Because the constructor is for a generic class, the type parameter \\ is implied but it must not appear in the constructor heading. \u200b public MyArrayList() { \u200b capacity = INITIAL_CAPACITY; \u200b data = (E[]) new Object[capacity]; \u200b } The statement data = (E[]) new Object[capacity]; allocates storage for an array with type Object references and then casts this array object to type E[] so that it is type compatible with variable theData. Because the actual type corresponding to E is not known, the compiler issues the warning message: MyArrayList.java uses unchecked or unsafe operations. Don\u2019t be concerned about this warning\u2014everything is fine.","title":"Constructor Declaration for Generic Classes"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#pitfall","text":"","title":"PITFALL"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-3-arraylist.html#declaring-a-generic-array","text":"Rather than use the approach shown in the above constructor, you might try to create a generic array directly using the statement theData = new E[capacity]; // Invalid generic array type. However, this statement will not compile because Java does not allow you to create an array with an unspecified type. Remember, E is a type parameter that is not specified until a generic ArrayList object is created. Therefore, the constructor must create an array of type Object[] since Object is the superclass of all types and then downcast this array object to type E[].","title":"Declaring a Generic Array"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-4-single-linked-lists.html","text":"4. Single-Linked Lists Overview Java does not have a class that implements single-linked lists. Instead, it has a more general double-linked list class. Class LinkedList<E> Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Note that the LinkedList class, part of Java API package java.util , is a double-linked list. However, the API description above is still valid. Implementation import java.util.AbstractSequentialList; import java.util.List; import java.util.ListIterator; /** Class to represent a linked list with a link from each node to the next node. SingleLinkedList does not implement the List interface. */ public class SingleLinkedList<E> extends AbstractSequentialList<E> implements List<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** * Reference to list head. */ private Node<E> head = null; /** * The number of items in the list */ private int size = 0; /** Insert the specified item at index @param index The position where item is to be inserted @param item The item to be inserted @throws IndexOutOfBoundsException if index is out of range */ public void add(int index, E item) { if (index < 0 || index > size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } if (index == 0) { addFirst(item); } else { Node<E> node = getNode(index-1); addAfter(node, item); } } /** Append item to the end of the list @param item The item to be appended @return true (as specified by the Collection interface) */ public boolean add(E item) { add(size, item); return true; } /** Add an item to the front of the list. @param item The item to be added */ public void addFirst(E item) { head = new Node<>(item, head); size++; } /** Add a node after a given node @param node The node preceding the new item @param item The item to insert */ private void addAfter(Node<E> node, E item) { node.next = new Node<>(item, node.next); size++; } /** * Returns the list iterator object. * @param i the index of the iterator. * @return the list iterator object. */ @Override public ListIterator<E> listIterator(int i) { throw new UnsupportedOperationException(); } /** * Removes the element at the specified position in this list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E remove(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } E removedData; if (index == 0) { removedData = removeFirst(); } else { Node<E> prevNode = getNode(index - 1); removedData = removeAfter(prevNode); } return removedData; } /** Remove the node after a given node @param node The node before the one to be removed @return The data from the removed node, or null if there is no node to remove */ private E removeAfter(Node<E> node) { Node<E> temp = node.next; if (temp != null) { node.next = temp.next; size--; return temp.data; } else { return null; } } /** Remove the first node from the list @return The removed node's data or null if the list is empty */ private E removeFirst() { Node<E> temp = head; if (head != null) { head = head.next; } // Return data at old head or null if list is empty if (temp != null) { size--; return temp.data; } else { return null; } } /** Get the data at index @param index The position of the data to return @return The data at index @throws IndexOutOfBoundsException if index is out of range */ public E get(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); return node.data; } /** Find the node at a specified position @param index The position of the node sought @return The node at index or null if it does not exist */ private Node<E> getNode(int index) { Node<E> node = head; for (int i = 0; i < index && node != null; i++) { node = node.next; } return node; } /** Store a reference to anEntry in the element at position index. @param index The position of the item to change @param newValue The new data @return The data previously at index @throws IndexOutOfBoundsException if index is out of range */ public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); E result = node.data; node.data = newValue; return result; } /** * Return the current number of elements in the list. * @return The size of the list */ public int size(){ return size; } /** * Returns the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element. This method allows searching for * an object of type Object. * * @param target the object to search for in the list * @return the index of the first occurrence of the object in the list, or -1 if not found */ public int indexOf(Object target) { Node<E> current = head; int index = 0; while (current != null) { if (current.data.equals(target)) { return index; } current = current.next; index++; } return -1; // Return -1 if the element is not found } } Performance Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(N) - Insertion into the middle: O(N) add(int index, E element) O(N) get(int index) O(N) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) size() O(1) Extra The keyword static in the class header indicates that the Node class will not reference its outer class. (It can\u2019t because it has no methods other than constructors.) In the Java API documentation, static inner classes are also called nested classes. Generally, we want to keep the details of the Node class private. Thus, the qualifier private is applied to the class as well as to the data fields and the constructor. However, the data fields and methods of an inner class are visible anywhere within the enclosing class (also called the parent class).","title":"Single-Linked Lists"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-4-single-linked-lists.html#4-single-linked-lists","text":"","title":"4. Single-Linked Lists"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-4-single-linked-lists.html#overview","text":"Java does not have a class that implements single-linked lists. Instead, it has a more general double-linked list class.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-4-single-linked-lists.html#class-linkedliste","text":"Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Note that the LinkedList class, part of Java API package java.util , is a double-linked list. However, the API description above is still valid.","title":"Class LinkedList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-4-single-linked-lists.html#implementation","text":"import java.util.AbstractSequentialList; import java.util.List; import java.util.ListIterator; /** Class to represent a linked list with a link from each node to the next node. SingleLinkedList does not implement the List interface. */ public class SingleLinkedList<E> extends AbstractSequentialList<E> implements List<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** * Reference to list head. */ private Node<E> head = null; /** * The number of items in the list */ private int size = 0; /** Insert the specified item at index @param index The position where item is to be inserted @param item The item to be inserted @throws IndexOutOfBoundsException if index is out of range */ public void add(int index, E item) { if (index < 0 || index > size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } if (index == 0) { addFirst(item); } else { Node<E> node = getNode(index-1); addAfter(node, item); } } /** Append item to the end of the list @param item The item to be appended @return true (as specified by the Collection interface) */ public boolean add(E item) { add(size, item); return true; } /** Add an item to the front of the list. @param item The item to be added */ public void addFirst(E item) { head = new Node<>(item, head); size++; } /** Add a node after a given node @param node The node preceding the new item @param item The item to insert */ private void addAfter(Node<E> node, E item) { node.next = new Node<>(item, node.next); size++; } /** * Returns the list iterator object. * @param i the index of the iterator. * @return the list iterator object. */ @Override public ListIterator<E> listIterator(int i) { throw new UnsupportedOperationException(); } /** * Removes the element at the specified position in this list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E remove(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } E removedData; if (index == 0) { removedData = removeFirst(); } else { Node<E> prevNode = getNode(index - 1); removedData = removeAfter(prevNode); } return removedData; } /** Remove the node after a given node @param node The node before the one to be removed @return The data from the removed node, or null if there is no node to remove */ private E removeAfter(Node<E> node) { Node<E> temp = node.next; if (temp != null) { node.next = temp.next; size--; return temp.data; } else { return null; } } /** Remove the first node from the list @return The removed node's data or null if the list is empty */ private E removeFirst() { Node<E> temp = head; if (head != null) { head = head.next; } // Return data at old head or null if list is empty if (temp != null) { size--; return temp.data; } else { return null; } } /** Get the data at index @param index The position of the data to return @return The data at index @throws IndexOutOfBoundsException if index is out of range */ public E get(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); return node.data; } /** Find the node at a specified position @param index The position of the node sought @return The node at index or null if it does not exist */ private Node<E> getNode(int index) { Node<E> node = head; for (int i = 0; i < index && node != null; i++) { node = node.next; } return node; } /** Store a reference to anEntry in the element at position index. @param index The position of the item to change @param newValue The new data @return The data previously at index @throws IndexOutOfBoundsException if index is out of range */ public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); E result = node.data; node.data = newValue; return result; } /** * Return the current number of elements in the list. * @return The size of the list */ public int size(){ return size; } /** * Returns the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element. This method allows searching for * an object of type Object. * * @param target the object to search for in the list * @return the index of the first occurrence of the object in the list, or -1 if not found */ public int indexOf(Object target) { Node<E> current = head; int index = 0; while (current != null) { if (current.data.equals(target)) { return index; } current = current.next; index++; } return -1; // Return -1 if the element is not found } }","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-4-single-linked-lists.html#performance","text":"Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(N) - Insertion into the middle: O(N) add(int index, E element) O(N) get(int index) O(N) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) size() O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-4-single-linked-lists.html#extra","text":"The keyword static in the class header indicates that the Node class will not reference its outer class. (It can\u2019t because it has no methods other than constructors.) In the Java API documentation, static inner classes are also called nested classes. Generally, we want to keep the details of the Node class private. Thus, the qualifier private is applied to the class as well as to the data fields and the constructor. However, the data fields and methods of an inner class are visible anywhere within the enclosing class (also called the parent class).","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-5-linked-list-class.html","text":"5. The LinkedList Class Overview The LinkedList class, part of the Java API package java.util , is a double\u2010linked list that implements the List interface. Class java.util.LinkedList<E> Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E get(int index) Returns the element at the specified position in this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E remove() Retrieves and removes the head (first element) of this list. E removeFirst() Removes and returns the first element from this list. E removeLast() Removes and returns the last element from this list. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Reference: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html Performance Operations/Complexity Big O (Worst-Case Complexity) add(E e) - General case: O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(1) - Insertion into the middle: O(N) add(int index, E element) O(N) addFirst(E e) O(1) addLast(E e) O(1) get(int index) O(N) getFirst() O(1) getLast() O(1) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) remove() O(1) removeFirst() O(1) removeLast() O(1) size() O(1)","title":"LinkedList Class"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-5-linked-list-class.html#5-the-linkedlist-class","text":"","title":"5. The LinkedList Class"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-5-linked-list-class.html#overview","text":"The LinkedList class, part of the Java API package java.util , is a double\u2010linked list that implements the List interface.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-5-linked-list-class.html#class-javautillinkedliste","text":"Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E get(int index) Returns the element at the specified position in this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E remove() Retrieves and removes the head (first element) of this list. E removeFirst() Removes and returns the first element from this list. E removeLast() Removes and returns the last element from this list. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Reference: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html","title":"Class java.util.LinkedList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-5-linked-list-class.html#performance","text":"Operations/Complexity Big O (Worst-Case Complexity) add(E e) - General case: O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(1) - Insertion into the middle: O(N) add(int index, E element) O(N) addFirst(E e) O(1) addLast(E e) O(1) get(int index) O(N) getFirst() O(1) getLast() O(1) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) remove() O(1) removeFirst() O(1) removeLast() O(1) size() O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html","text":"6. The Iterator , ListIterator , and Iterable Interfaces The Iterator Interface Overview The List interface declares the method iterator, which returns an Iterator object that will iterate over the elements of that list. The requirement for the iterator method is actually in the Collection interface, which is the superinterface for the List interface. The Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an Iterator method. An Iterator does not refer to or point to a particular object at any given time. Rather, you should think of an Iterator as pointing between objects within a list. Think of an iterator as a moving place marker that keeps track of the current position in a particular linked list. The Iterator object for a list starts at the first element in the list. The programmer can use the Iterator object\u2019s next method to retrieve the next element. Each time it does a retrieval, the Iterator object advances to the next list element, where it waits until it is needed again. We can also ask the Iterator object to determine whether the list has more elements left to process (method hasNext ). Iterator objects throw a NoSuchElementException if they are asked to retrieve the next element after all elements have been processed. You can use the Iterator remove method to remove elements from a list as you access them. You can remove only the element that was most recently accessed by next. Each call to remove must be preceded by a call to next to retrieve the next element. Interface java.util.Iterator<E> Modifier and Type Method Description boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation). Extra Efficient Access to List Elements by Iterator We can use the following loop to access the list elements in sequence, starting with the one at index 0. // Access each list element. for (int index = 0; index < aList.size(); index++) { E nextElement = aList.get(index); // Do something with the element at position index (nextElement) . . . } The loop is executed aList.size() times; thus it is O( n ). During each iteration, we call the method get to retrieve the element at position index. If we assume that the method get begins at the first list node (head), each call to method get must advance a local reference (nodeRef) to the node at position index using a loop such as: // Advance nodeRef to the element at position index. Node nodeRef = head; for (int j = 0; j < index; j++) { nodeRef = nodeRef.next; } This loop (in method get) executes index times, so it is also O( n ). Therefore, the performance of the nested loops used to process each element in a LinkedList is O( n^2 ) and is very inefficient. We would like to have an alternative way to access the elements in a linked list sequentially. Removal Using Iterator.remove versus List.remove You could also use method LinkedList.remove to remove elements from a list. However, it is more efficient to remove multiple elements from a list using Iterator.remove than it would be to use LinkedList.remove. The LinkedList.remove method removes only one element at a time, so you would need to start at the beginning of the list each time and advance down the list to each element that you wanted to remove (O(n2) process). With the Iterator.remove method, you can remove elements as they are accessed by the Iterator object without having to go back to the beginning of the list (O(n) process). The Enhanced for Loop The enhanced for loop creates an Iterator object and implicitly calls its hasNext and next methods. Other Iterator methods, such as remove, are not available. FORM : for (formalParameter : expression) { . . . } EXAMPLE : for (String nextStr : myList) { . . . } for (int nextInt : aList) { . . . } MEANING : During each repetition of the loop, the variable specified by formalParameter accesses the next element of expression, starting with the first element and ending with the last. The expression must be an array or a collection that implements the Iterable interface. The Collection interface extends the Iterable interface so that all classes that implement it are implementors of the Iterable interface (see next section). The ListIterator Interface Overview The Iterator has some limitations. It can traverse the List only in the forward direction. It also provides only a remove method, not an add method. Also, to start an Iterator somewhere other than at first List element, you must write your own loop to advance the Iterator to the desired starting position. The next method moves the iterator forward and returns the element that was jumped over. The previous method moves the iterator backward and also returns the element that was jumped over. Interface java.util.ListIterator<E> Modifier and Type Method Description void add(E e) Inserts the specified element into the list (optional operation). Inserts object obj into the list just before the item that would be returned by the next call to method next and after the item that would have been returned by method previous. If the method previous is called after add, the newly inserted object will be returned boolean hasNext() Returns true if this list iterator has more elements when traversing the list in the forward direction. boolean hasPrevious() Returns true if this list iterator has more elements when traversing the list in the reverse direction. E next() Returns the next element in the list and advances the cursor position. int nextIndex() Returns the index of the element that would be returned by a subsequent call to next(). E previous() Returns the previous element in the list and moves the cursor position backwards. int previousIndex() Returns the index of the element that would be returned by a subsequent call to previous(). void remove() Removes from the list the last element that was returned by next() or previous() (optional operation). Removes the last item returned from a call to next or previous. If a call to remove is not preceded by a call to next or previous, the IllegalStateException is thrown void set(E e) Replaces the last element returned by next() or previous() with the specified element (optional). Replaces the last item returned from a call to next or previous with obj. If a call to set is not preceded by a call to next or previous, the IllegalStateException is thrown Methods in java.util.LinkedList<E> that Return ListIterator Modifier and Type Method Description ListIterator\\ listIterator() Returns a ListIterator that begins just before the first list element. ListIterator\\ listIterator(int index) Returns a ListIterator that begins just before the position index. Comparison of Iterator and ListIterator Because the interface ListIterator<E> is a subinterface of Iterator<E> , classes that implement ListIterator must provide all of the capabilities of both. The Iterator interface requires fewer methods and can be used to iterate over more general data structures\u2014that is, structures for which an index is not meaningful and ones for which traversing in only the forward direction is required. It is for this reason that the Iterator is required by the Collection interface (more general), whereas the ListIterator is required only by the List interface (more specialized). The Iterable Interface Overview This interface requires only that a class that implements it provides an iterator method. As mentioned above, the Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an iterator method. Interface java.lang.Iterable<T> Modifier and Type Method and Description default void forEach(Consumer<? super T> action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable.","title":"The Iterator, ListIterator, and Iterable Interfaces"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#6-the-iterator-listiterator-and-iterable-interfaces","text":"","title":"6. The Iterator, ListIterator, and Iterable Interfaces"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#the-iterator-interface","text":"","title":"The Iterator Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#overview","text":"The List interface declares the method iterator, which returns an Iterator object that will iterate over the elements of that list. The requirement for the iterator method is actually in the Collection interface, which is the superinterface for the List interface. The Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an Iterator method. An Iterator does not refer to or point to a particular object at any given time. Rather, you should think of an Iterator as pointing between objects within a list. Think of an iterator as a moving place marker that keeps track of the current position in a particular linked list. The Iterator object for a list starts at the first element in the list. The programmer can use the Iterator object\u2019s next method to retrieve the next element. Each time it does a retrieval, the Iterator object advances to the next list element, where it waits until it is needed again. We can also ask the Iterator object to determine whether the list has more elements left to process (method hasNext ). Iterator objects throw a NoSuchElementException if they are asked to retrieve the next element after all elements have been processed. You can use the Iterator remove method to remove elements from a list as you access them. You can remove only the element that was most recently accessed by next. Each call to remove must be preceded by a call to next to retrieve the next element.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#interface-javautiliteratore","text":"Modifier and Type Method Description boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation).","title":"Interface java.util.Iterator&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#extra","text":"","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#efficient-access-to-list-elements-by-iterator","text":"We can use the following loop to access the list elements in sequence, starting with the one at index 0. // Access each list element. for (int index = 0; index < aList.size(); index++) { E nextElement = aList.get(index); // Do something with the element at position index (nextElement) . . . } The loop is executed aList.size() times; thus it is O( n ). During each iteration, we call the method get to retrieve the element at position index. If we assume that the method get begins at the first list node (head), each call to method get must advance a local reference (nodeRef) to the node at position index using a loop such as: // Advance nodeRef to the element at position index. Node nodeRef = head; for (int j = 0; j < index; j++) { nodeRef = nodeRef.next; } This loop (in method get) executes index times, so it is also O( n ). Therefore, the performance of the nested loops used to process each element in a LinkedList is O( n^2 ) and is very inefficient. We would like to have an alternative way to access the elements in a linked list sequentially.","title":"Efficient Access to List Elements by Iterator"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#removal-using-iteratorremove-versus-listremove","text":"You could also use method LinkedList.remove to remove elements from a list. However, it is more efficient to remove multiple elements from a list using Iterator.remove than it would be to use LinkedList.remove. The LinkedList.remove method removes only one element at a time, so you would need to start at the beginning of the list each time and advance down the list to each element that you wanted to remove (O(n2) process). With the Iterator.remove method, you can remove elements as they are accessed by the Iterator object without having to go back to the beginning of the list (O(n) process).","title":"Removal Using Iterator.remove versus List.remove"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#the-enhanced-for-loop","text":"The enhanced for loop creates an Iterator object and implicitly calls its hasNext and next methods. Other Iterator methods, such as remove, are not available. FORM : for (formalParameter : expression) { . . . } EXAMPLE : for (String nextStr : myList) { . . . } for (int nextInt : aList) { . . . } MEANING : During each repetition of the loop, the variable specified by formalParameter accesses the next element of expression, starting with the first element and ending with the last. The expression must be an array or a collection that implements the Iterable interface. The Collection interface extends the Iterable interface so that all classes that implement it are implementors of the Iterable interface (see next section).","title":"The Enhanced for Loop"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#the-listiterator-interface","text":"","title":"The ListIterator Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#overview_1","text":"The Iterator has some limitations. It can traverse the List only in the forward direction. It also provides only a remove method, not an add method. Also, to start an Iterator somewhere other than at first List element, you must write your own loop to advance the Iterator to the desired starting position. The next method moves the iterator forward and returns the element that was jumped over. The previous method moves the iterator backward and also returns the element that was jumped over.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#interface-javautillistiteratore","text":"Modifier and Type Method Description void add(E e) Inserts the specified element into the list (optional operation). Inserts object obj into the list just before the item that would be returned by the next call to method next and after the item that would have been returned by method previous. If the method previous is called after add, the newly inserted object will be returned boolean hasNext() Returns true if this list iterator has more elements when traversing the list in the forward direction. boolean hasPrevious() Returns true if this list iterator has more elements when traversing the list in the reverse direction. E next() Returns the next element in the list and advances the cursor position. int nextIndex() Returns the index of the element that would be returned by a subsequent call to next(). E previous() Returns the previous element in the list and moves the cursor position backwards. int previousIndex() Returns the index of the element that would be returned by a subsequent call to previous(). void remove() Removes from the list the last element that was returned by next() or previous() (optional operation). Removes the last item returned from a call to next or previous. If a call to remove is not preceded by a call to next or previous, the IllegalStateException is thrown void set(E e) Replaces the last element returned by next() or previous() with the specified element (optional). Replaces the last item returned from a call to next or previous with obj. If a call to set is not preceded by a call to next or previous, the IllegalStateException is thrown","title":"Interface java.util.ListIterator&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#methods-in-javautillinkedliste-that-return-listiterator","text":"Modifier and Type Method Description ListIterator\\ listIterator() Returns a ListIterator that begins just before the first list element. ListIterator\\ listIterator(int index) Returns a ListIterator that begins just before the position index.","title":"Methods in java.util.LinkedList&lt;E&gt; that Return ListIterator"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#comparison-of-iterator-and-listiterator","text":"Because the interface ListIterator<E> is a subinterface of Iterator<E> , classes that implement ListIterator must provide all of the capabilities of both. The Iterator interface requires fewer methods and can be used to iterate over more general data structures\u2014that is, structures for which an index is not meaningful and ones for which traversing in only the forward direction is required. It is for this reason that the Iterator is required by the Collection interface (more general), whereas the ListIterator is required only by the List interface (more specialized).","title":"Comparison of Iterator and ListIterator"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#the-iterable-interface","text":"","title":"The Iterable Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#overview_2","text":"This interface requires only that a class that implements it provides an iterator method. As mentioned above, the Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an iterator method.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-6-iterator-listiterator-and-iterable-interfaces.html#interface-javalangiterablet","text":"Modifier and Type Method and Description default void forEach(Consumer<? super T> action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable.","title":"Interface java.lang.Iterable&lt;T&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html","text":"7. Double-Linked List (Linked List) Overview A double\u2010linked list object would consist of a separate object with data fields head (a reference to the first list Node), tail (a reference to the last list Node), and size (the number of Nodes). Because both ends of the list are directly accessible, now insertion at either end is O(1); insertion else- where is still O(n). Implementation We can implement most of the MyLinkedList methods by delegation to the class MyListIterator , which will implement the ListIterator interface Data Fields for Class MyLinkedList<E> (Double-Linked List) Data Field Attribute private Node head A reference to the first item in the list private Node tail A reference to the last item in the list private int size A count of the number of items in the list package datastructures.list; import java.util.*; /** Class KWLinkedList implements a double\u2010linked list and a ListIterator. */ public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>{ /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; /** The reference to the previous node. */ private Node<E> prev; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** Inner class to implement the ListIterator interface. */ private class MyListIterator implements ListIterator<E> { /** A reference to the next item. */ private Node<E> nextItem; /** A reference to the last item returned. */ private Node<E> lastItemReturned; /** The index of the current item. */ private int index = 0; /** Construct a KWListIter that will reference the ith item. @param i The index of the item to be referenced */ public MyListIterator(int i) { // Validate i parameter. if (i < 0 || i > size) { throw new IndexOutOfBoundsException(\"Invalid index \" + i); } lastItemReturned = null; // No item returned yet. // Special case of last item. if (i == size) { index = size; nextItem = null; } else { // Start at the beginning nextItem = head; for (index = 0; index < i; index++) { nextItem = nextItem.next; } } } /** Indicate whether movement forward is defined. @return true if call to next will not throw an exception */ public boolean hasNext() { return nextItem != null; } /** Move the iterator forward and return the next item. @return The next item in the list @throws NoSuchElementException if there is no such object */ public E next() { if (!hasNext()) { throw new NoSuchElementException(); } lastItemReturned = nextItem; nextItem = nextItem.next; index++; return lastItemReturned.data; } /** Indicate whether movement backward is defined. @return true if call to previous will not throw an exception */ public boolean hasPrevious() { return (nextItem == null && size != 0) || nextItem.prev != null; } /** Move the iterator backward and return the previous item. @return The previous item in the list @throws NoSuchElementException if there is no such object */ public E previous() { if (!hasPrevious()) { throw new NoSuchElementException(); } if (nextItem == null) { // Iterator is past the last element nextItem = tail; } else { nextItem = nextItem.prev; } lastItemReturned = nextItem; index--; return lastItemReturned.data; } /** * Returns the index of the element that would be returned by a subsequent call to next(). * * @return the index of the element that would be returned by a subsequent call to next(), * or the size of the list if there is no next element */ @Override public int nextIndex() { return (hasNext()) ? index : size; } /** * Returns the index of the element that would be returned by a subsequent call to previous(). * * @return the index of the element that would be returned by a subsequent call to previous(), * or -1 if there is no previous element */ @Override public int previousIndex() { return (hasPrevious()) ? index - 1 : -1; } /** * Removes from the list the last element that was returned by next() or previous(). * * This method has not been verified! * * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void remove() { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to remove\"); } Node<E> lastNext = lastItemReturned.next; Node<E> lastPrev = lastItemReturned.prev; if (lastPrev == null) { // Removing first element head = lastNext; } else { lastPrev.next = lastNext; lastItemReturned.prev = null; } if (lastNext == null) { // Removing last element tail = lastPrev; } else { lastNext.prev = lastPrev; lastItemReturned.next = null; } if (nextItem == lastItemReturned) { nextItem = lastNext; } else { index--; } lastItemReturned.data = null; lastItemReturned = null; size--; } /** * Replaces the last element returned by next() or previous() with the specified element. * * @param e the element with which to replace the last returned element * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void set(E e) { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to set\"); } lastItemReturned.data = e; } /** Add a new item between the item that will be returned by next and the item that will be returned by previous. If previous is called after add, the element added is returned. @param obj The item to be inserted */ public void add(E obj) { if (head == null) { // Add to an empty list. head = new Node<>(obj); tail = head; } else if (nextItem == head) { // Insert at head // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to the nextItem. newNode.next = nextItem; // Link nextItem to the new node. nextItem.prev = newNode; // The new node is now the head. head = newNode; } else if(nextItem == null){ // Insert at tail // Create a new node. Node<E> newNode = new Node<>(obj); // Link the tail to the new node. tail.next = newNode; // Link the new node to the tail. newNode.prev = tail; // The new node is the new tail. tail = newNode; } else { // Insert into the middle. // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to nextItem.prev. newNode.prev = nextItem.prev; nextItem.prev.next = newNode; // Link it to the nextItem. newNode.next = nextItem; nextItem.prev = newNode; } // Increase size and index and set lastItemReturned. size++; index++; lastItemReturned = null; } // End of method add. } // Data Fields /** A reference to the head of the list. */ private Node<E> head = null; /** A reference to the end of the list. */ private Node<E> tail = null; /** The size of the list. */ private int size = 0; /** Add an item at position index. @param index The position at which the object is to be inserted @param obj The object to be inserted @throws IndexOutOfBoundsException if the index is out of range (i < 0 || i > size()) */ public void add(int index, E obj) { listIterator(index).add(obj); } @Override public ListIterator<E> listIterator(int i) { return new MyListIterator(i); } /** Get the element at position index. @param index Position of item to be retrieved @return The item at index */ public E get(int index) { return listIterator(index).next(); } /** * Return the number of elements in this list. * @return The number of elements in this list. */ @Override public int size() { return size; } } Extra Inner Classes: Static and Nonstatic There are two inner classes in class LinkedList\\ : class Node and class MyListIterator. We declare Node\\ to be static because there is no need for its methods to access the data fields of its parent class (LinkedList\\ ). We can\u2019t declare MyListIterator to be static because its methods access and modify the data fields of the LinkedList object that creates the MyListIterator object. An inner class that is not static contains an implicit reference to its parent object, just as it contains an implicit reference to itself. Because MyListIterator is not static and can reference data fields of its parent class LinkedList\\ , the type parameter is considered to be previously defined; therefore, it cannot appear as part of the class name. PITFALL Defining MyListIterator as a Generic Inner Class If you define class MyListIterator as private class MyListIterator ... you will get an incompatible types syntax error when you attempt to reference data field head or tail (type Node\\ ) inside class MyListIterator.","title":"Double-Linked Lists"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html#7-double-linked-list-linked-list","text":"","title":"7. Double-Linked List (Linked List)"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html#overview","text":"A double\u2010linked list object would consist of a separate object with data fields head (a reference to the first list Node), tail (a reference to the last list Node), and size (the number of Nodes). Because both ends of the list are directly accessible, now insertion at either end is O(1); insertion else- where is still O(n).","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html#implementation","text":"We can implement most of the MyLinkedList methods by delegation to the class MyListIterator , which will implement the ListIterator interface","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html#data-fields-for-class-mylinkedliste-double-linked-list","text":"Data Field Attribute private Node head A reference to the first item in the list private Node tail A reference to the last item in the list private int size A count of the number of items in the list package datastructures.list; import java.util.*; /** Class KWLinkedList implements a double\u2010linked list and a ListIterator. */ public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>{ /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; /** The reference to the previous node. */ private Node<E> prev; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** Inner class to implement the ListIterator interface. */ private class MyListIterator implements ListIterator<E> { /** A reference to the next item. */ private Node<E> nextItem; /** A reference to the last item returned. */ private Node<E> lastItemReturned; /** The index of the current item. */ private int index = 0; /** Construct a KWListIter that will reference the ith item. @param i The index of the item to be referenced */ public MyListIterator(int i) { // Validate i parameter. if (i < 0 || i > size) { throw new IndexOutOfBoundsException(\"Invalid index \" + i); } lastItemReturned = null; // No item returned yet. // Special case of last item. if (i == size) { index = size; nextItem = null; } else { // Start at the beginning nextItem = head; for (index = 0; index < i; index++) { nextItem = nextItem.next; } } } /** Indicate whether movement forward is defined. @return true if call to next will not throw an exception */ public boolean hasNext() { return nextItem != null; } /** Move the iterator forward and return the next item. @return The next item in the list @throws NoSuchElementException if there is no such object */ public E next() { if (!hasNext()) { throw new NoSuchElementException(); } lastItemReturned = nextItem; nextItem = nextItem.next; index++; return lastItemReturned.data; } /** Indicate whether movement backward is defined. @return true if call to previous will not throw an exception */ public boolean hasPrevious() { return (nextItem == null && size != 0) || nextItem.prev != null; } /** Move the iterator backward and return the previous item. @return The previous item in the list @throws NoSuchElementException if there is no such object */ public E previous() { if (!hasPrevious()) { throw new NoSuchElementException(); } if (nextItem == null) { // Iterator is past the last element nextItem = tail; } else { nextItem = nextItem.prev; } lastItemReturned = nextItem; index--; return lastItemReturned.data; } /** * Returns the index of the element that would be returned by a subsequent call to next(). * * @return the index of the element that would be returned by a subsequent call to next(), * or the size of the list if there is no next element */ @Override public int nextIndex() { return (hasNext()) ? index : size; } /** * Returns the index of the element that would be returned by a subsequent call to previous(). * * @return the index of the element that would be returned by a subsequent call to previous(), * or -1 if there is no previous element */ @Override public int previousIndex() { return (hasPrevious()) ? index - 1 : -1; } /** * Removes from the list the last element that was returned by next() or previous(). * * This method has not been verified! * * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void remove() { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to remove\"); } Node<E> lastNext = lastItemReturned.next; Node<E> lastPrev = lastItemReturned.prev; if (lastPrev == null) { // Removing first element head = lastNext; } else { lastPrev.next = lastNext; lastItemReturned.prev = null; } if (lastNext == null) { // Removing last element tail = lastPrev; } else { lastNext.prev = lastPrev; lastItemReturned.next = null; } if (nextItem == lastItemReturned) { nextItem = lastNext; } else { index--; } lastItemReturned.data = null; lastItemReturned = null; size--; } /** * Replaces the last element returned by next() or previous() with the specified element. * * @param e the element with which to replace the last returned element * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void set(E e) { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to set\"); } lastItemReturned.data = e; } /** Add a new item between the item that will be returned by next and the item that will be returned by previous. If previous is called after add, the element added is returned. @param obj The item to be inserted */ public void add(E obj) { if (head == null) { // Add to an empty list. head = new Node<>(obj); tail = head; } else if (nextItem == head) { // Insert at head // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to the nextItem. newNode.next = nextItem; // Link nextItem to the new node. nextItem.prev = newNode; // The new node is now the head. head = newNode; } else if(nextItem == null){ // Insert at tail // Create a new node. Node<E> newNode = new Node<>(obj); // Link the tail to the new node. tail.next = newNode; // Link the new node to the tail. newNode.prev = tail; // The new node is the new tail. tail = newNode; } else { // Insert into the middle. // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to nextItem.prev. newNode.prev = nextItem.prev; nextItem.prev.next = newNode; // Link it to the nextItem. newNode.next = nextItem; nextItem.prev = newNode; } // Increase size and index and set lastItemReturned. size++; index++; lastItemReturned = null; } // End of method add. } // Data Fields /** A reference to the head of the list. */ private Node<E> head = null; /** A reference to the end of the list. */ private Node<E> tail = null; /** The size of the list. */ private int size = 0; /** Add an item at position index. @param index The position at which the object is to be inserted @param obj The object to be inserted @throws IndexOutOfBoundsException if the index is out of range (i < 0 || i > size()) */ public void add(int index, E obj) { listIterator(index).add(obj); } @Override public ListIterator<E> listIterator(int i) { return new MyListIterator(i); } /** Get the element at position index. @param index Position of item to be retrieved @return The item at index */ public E get(int index) { return listIterator(index).next(); } /** * Return the number of elements in this list. * @return The number of elements in this list. */ @Override public int size() { return size; } }","title":"Data Fields for Class MyLinkedList&lt;E&gt; (Double-Linked List)"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html#extra","text":"","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html#inner-classes-static-and-nonstatic","text":"There are two inner classes in class LinkedList\\ : class Node and class MyListIterator. We declare Node\\ to be static because there is no need for its methods to access the data fields of its parent class (LinkedList\\ ). We can\u2019t declare MyListIterator to be static because its methods access and modify the data fields of the LinkedList object that creates the MyListIterator object. An inner class that is not static contains an implicit reference to its parent object, just as it contains an implicit reference to itself. Because MyListIterator is not static and can reference data fields of its parent class LinkedList\\ , the type parameter is considered to be previously defined; therefore, it cannot appear as part of the class name.","title":"Inner Classes: Static and Nonstatic"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-7-double-linked-lists.html#pitfall","text":"Defining MyListIterator as a Generic Inner Class If you define class MyListIterator as private class MyListIterator ... you will get an incompatible types syntax error when you attempt to reference data field head or tail (type Node\\ ) inside class MyListIterator.","title":"PITFALL"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html","text":"8. Circular Linked List Overview Circularly Linked Lists: Linked lists are traditionally viewed as storing a sequence of items in a linear order, from first to last. However, there are many applications in which data can be more naturally viewed as having a cyclic order, with well-defined neighboring relationships, but no fixed beginning or end. Example Application: Round-Robin Scheduling A process is given a short turn to execute, known as a time slice, but it is interrupted when the slice ends, even if its job is not yet complete. Each active process is given its own time slice, taking turns in a cyclic order. Class CircularlyLinkedList<E> Data Fields Data Field Attribute private Node tail A reference to the last item in the list private int size A count of the number of items in the list Method Summary Modifier and Type Method Description void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. void rotate() Rotates the first element to the back of the list. E removeFirst() Removes and returns the first element from this list. Implementation public class CircularLinkedList<E> { // Nested node class identical to that of the SinglyLinkedList class private static class Node<E> { private E element; private Node<E> next; public Node(E e, Node<E> n) { element = e; next = n; } public E getElement() { return element; } public Node<E> getNext() { return next; } public void setNext(Node<E> n) { next = n; } } private Node<E> tail = null; // We store tail (but not head) private int size = 0; // Number of nodes in the list public CircularLinkedList() { } // Constructs an initially empty list // Access methods public int size() { return size; } public boolean isEmpty() { return size == 0; } public E getFirst() { // Returns (but does not remove) the first element if (isEmpty()) return null; return tail.getNext().getElement(); // The head is *after* the tail } public E getLast() { // Returns (but does not remove) the last element if (isEmpty()) return null; return tail.getElement(); } // Update methods public void rotate() { // Rotate the first element to the back of the list if (tail != null) // If empty, do nothing tail = tail.getNext(); // The old head becomes the new tail } public void addFirst(E e) { // Adds element e to the front of the list if (size == 0) { tail = new Node<>(e, null); tail.setNext(tail); // Link to itself circularly } else { Node<E> newest = new Node<>(e, tail.getNext()); tail.setNext(newest); } size++; } public void addLast(E e) { // Adds element e to the end of the list addFirst(e); // Insert new element at front of list tail = tail.getNext(); // Now new element becomes the tail } public E removeFirst() { // Removes and returns the first element if (isEmpty()) return null; // Nothing to remove Node<E> head = tail.getNext(); if (head == tail) tail = null; // Must be the only node left else tail.setNext(head.getNext()); // Removes \u201dhead\u201d from the list size--; return head.getElement(); } } TODO: The implementations of some methods are missing and should be fixed in the future. Performance Operations/Complexity Big O addFirst(E e) O(1) addLast(E e) O(1) getFirst() O(1) getLast() O(1) rotate() O(1) removeFirst() O(1)","title":"Circular-Linked Lists"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html#8-circular-linked-list","text":"","title":"8. Circular Linked List"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html#overview","text":"Circularly Linked Lists: Linked lists are traditionally viewed as storing a sequence of items in a linear order, from first to last. However, there are many applications in which data can be more naturally viewed as having a cyclic order, with well-defined neighboring relationships, but no fixed beginning or end. Example Application: Round-Robin Scheduling A process is given a short turn to execute, known as a time slice, but it is interrupted when the slice ends, even if its job is not yet complete. Each active process is given its own time slice, taking turns in a cyclic order.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html#class-circularlylinkedliste","text":"","title":"Class CircularlyLinkedList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html#data-fields","text":"Data Field Attribute private Node tail A reference to the last item in the list private int size A count of the number of items in the list","title":"Data Fields"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html#method-summary","text":"Modifier and Type Method Description void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. void rotate() Rotates the first element to the back of the list. E removeFirst() Removes and returns the first element from this list.","title":"Method Summary"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html#implementation","text":"public class CircularLinkedList<E> { // Nested node class identical to that of the SinglyLinkedList class private static class Node<E> { private E element; private Node<E> next; public Node(E e, Node<E> n) { element = e; next = n; } public E getElement() { return element; } public Node<E> getNext() { return next; } public void setNext(Node<E> n) { next = n; } } private Node<E> tail = null; // We store tail (but not head) private int size = 0; // Number of nodes in the list public CircularLinkedList() { } // Constructs an initially empty list // Access methods public int size() { return size; } public boolean isEmpty() { return size == 0; } public E getFirst() { // Returns (but does not remove) the first element if (isEmpty()) return null; return tail.getNext().getElement(); // The head is *after* the tail } public E getLast() { // Returns (but does not remove) the last element if (isEmpty()) return null; return tail.getElement(); } // Update methods public void rotate() { // Rotate the first element to the back of the list if (tail != null) // If empty, do nothing tail = tail.getNext(); // The old head becomes the new tail } public void addFirst(E e) { // Adds element e to the front of the list if (size == 0) { tail = new Node<>(e, null); tail.setNext(tail); // Link to itself circularly } else { Node<E> newest = new Node<>(e, tail.getNext()); tail.setNext(newest); } size++; } public void addLast(E e) { // Adds element e to the end of the list addFirst(e); // Insert new element at front of list tail = tail.getNext(); // Now new element becomes the tail } public E removeFirst() { // Removes and returns the first element if (isEmpty()) return null; // Nothing to remove Node<E> head = tail.getNext(); if (head == tail) tail = null; // Must be the only node left else tail.setNext(head.getNext()); // Removes \u201dhead\u201d from the list size--; return head.getElement(); } } TODO: The implementations of some methods are missing and should be fixed in the future.","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-8-circular-linked-lists.html#performance","text":"Operations/Complexity Big O addFirst(E e) O(1) addLast(E e) O(1) getFirst() O(1) getLast() O(1) rotate() O(1) removeFirst() O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-9-the-collections-framework-design.html","text":"9. The Collections Framework Design The Collection Interface The Collection interface specifies a subset of the methods specified in the List interface. Specifically, the add(int, E), get(int), remove(int), set(int, E), and related methods (all of which have an int parameter that represents a position) are not in the Collection interface, but the add(E) and remove(Object) methods, which do not specify a position, are included. The iterator method is also included in the Collection interface. Thus, you can use an Iterator to access all of the items in a Collection , but the order in which they are retrieved is not necessarily related to the order in which they were inserted The Collection interface is part of the Collections Framework. This interface has three subinterfaces: the List interface, the Queue interface, and the Set interface. The Java API does not provide any direct implementation of the Collection interface. The interface is used to reference collections of data in the most general way. Common Features of Collections A few features can be considered fundamental: Collections grow as needed. Collections hold references to objects. Collections have at least two constructors: one to create an empty collection and one to make a copy of another collection. For collections implementing the List interface, the order of the elements is determined by the index of the elements. In the more general Collection, the order is not specified. Interface java.util.Collection<E> Modifier and Type Method and Description boolean add(E e) Ensures that this collection contains the specified element (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this collection (optional operation). void clear() Removes all of the elements from this collection (optional operation). boolean contains(Object o) Returns true if this collection contains the specified element. boolean containsAll(Collection<?> c) Returns true if this collection contains all of the elements in the specified collection. boolean equals(Object o) Compares the specified object with this collection for equality. boolean isEmpty() Returns true if this collection contains no elements. Iterator iterator() Returns an iterator over the elements in this collection. boolean remove(Object o) Removes a single instance of the specified element from this collection, if it is present (optional operation). boolean removeAll(Collection<?> c) Removes all of this collection's elements that are also contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this collection that are contained in the specified collection (optional operation). int size() Returns the number of elements in this collection. Object[] toArray() Returns an array containing all of the elements in this collection. The AbstractCollection , AbstractList , and AbstractSequentialList Classes If you look at the Java API documentation, you will see that the Collection and List interfaces specify a large number of methods. To help implement these interfaces, the Java API includes the AbstractCollection and AbstractList classes. You can think of these classes as a kit that can be used to build implementations of their corresponding interface. Most of the methods are provided, but you need to add a few to make it complete. To implement the Collection interface completely, you need only extend the AbstractCollection class, provide an implementation of the add, size, and iterator methods, and supply an inner class to implement the Iterator interface. To implement the List interface, you can extend the AbstractList class and provide an implementation of the add(int, E), get(int), remove(int), set(int, E), and size() methods. Since we provided these methods in our ArrayList , we can make it a complete implementation of the List interface by changing the class declaration to java public class ArrayList<E> extends AbstractList<E> implements List<E> Note that the AbstractList class implements the iterator and listIterator methods using the index associated with the elements. Another way to implement the List interface is to extend the AbstractSequentialList class, implement the listIterator and size methods, and provide an inner class that implements the ListIterator interface. This was the approach we took in our LinkedList . Thus, by changing the class declaration to java public class LinkedList<E> extends AbstractSequentialList<E> implements List<E> it becomes a complete implementation of the List interface. Our LinkedList class included the add, get, remove, and set methods. These are provided by the AbstractSequentialList , so we could remove them from our LinkedList class and still have a complete List implementation. The List and RandomAccess Interface The RandomAccess interface is applied only to those implementations in which indexed operations are efficient (e.g., ArrayList). An algorithm can then test to see if a parameter of type List is also of type RandomAccess and, if not, copy its contents into an ArrayList temporarily so that the indexed operations can proceed more efficiently. After the indexed operations are completed, the contents of the ArrayList are copied back to the original.","title":"The Collections Framework Design"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-9-the-collections-framework-design.html#9-the-collections-framework-design","text":"","title":"9. The Collections Framework Design"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-9-the-collections-framework-design.html#the-collection-interface","text":"The Collection interface specifies a subset of the methods specified in the List interface. Specifically, the add(int, E), get(int), remove(int), set(int, E), and related methods (all of which have an int parameter that represents a position) are not in the Collection interface, but the add(E) and remove(Object) methods, which do not specify a position, are included. The iterator method is also included in the Collection interface. Thus, you can use an Iterator to access all of the items in a Collection , but the order in which they are retrieved is not necessarily related to the order in which they were inserted The Collection interface is part of the Collections Framework. This interface has three subinterfaces: the List interface, the Queue interface, and the Set interface. The Java API does not provide any direct implementation of the Collection interface. The interface is used to reference collections of data in the most general way.","title":"The Collection Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-9-the-collections-framework-design.html#common-features-of-collections","text":"A few features can be considered fundamental: Collections grow as needed. Collections hold references to objects. Collections have at least two constructors: one to create an empty collection and one to make a copy of another collection. For collections implementing the List interface, the order of the elements is determined by the index of the elements. In the more general Collection, the order is not specified.","title":"Common Features of Collections"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-9-the-collections-framework-design.html#interface-javautilcollectione","text":"Modifier and Type Method and Description boolean add(E e) Ensures that this collection contains the specified element (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this collection (optional operation). void clear() Removes all of the elements from this collection (optional operation). boolean contains(Object o) Returns true if this collection contains the specified element. boolean containsAll(Collection<?> c) Returns true if this collection contains all of the elements in the specified collection. boolean equals(Object o) Compares the specified object with this collection for equality. boolean isEmpty() Returns true if this collection contains no elements. Iterator iterator() Returns an iterator over the elements in this collection. boolean remove(Object o) Removes a single instance of the specified element from this collection, if it is present (optional operation). boolean removeAll(Collection<?> c) Removes all of this collection's elements that are also contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this collection that are contained in the specified collection (optional operation). int size() Returns the number of elements in this collection. Object[] toArray() Returns an array containing all of the elements in this collection.","title":"Interface java.util.Collection&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-9-the-collections-framework-design.html#the-abstractcollection-abstractlist-and-abstractsequentiallist-classes","text":"If you look at the Java API documentation, you will see that the Collection and List interfaces specify a large number of methods. To help implement these interfaces, the Java API includes the AbstractCollection and AbstractList classes. You can think of these classes as a kit that can be used to build implementations of their corresponding interface. Most of the methods are provided, but you need to add a few to make it complete. To implement the Collection interface completely, you need only extend the AbstractCollection class, provide an implementation of the add, size, and iterator methods, and supply an inner class to implement the Iterator interface. To implement the List interface, you can extend the AbstractList class and provide an implementation of the add(int, E), get(int), remove(int), set(int, E), and size() methods. Since we provided these methods in our ArrayList , we can make it a complete implementation of the List interface by changing the class declaration to java public class ArrayList<E> extends AbstractList<E> implements List<E> Note that the AbstractList class implements the iterator and listIterator methods using the index associated with the elements. Another way to implement the List interface is to extend the AbstractSequentialList class, implement the listIterator and size methods, and provide an inner class that implements the ListIterator interface. This was the approach we took in our LinkedList . Thus, by changing the class declaration to java public class LinkedList<E> extends AbstractSequentialList<E> implements List<E> it becomes a complete implementation of the List interface. Our LinkedList class included the add, get, remove, and set methods. These are provided by the AbstractSequentialList , so we could remove them from our LinkedList class and still have a complete List implementation.","title":"The AbstractCollection, AbstractList, and AbstractSequentialList Classes"},{"location":"data-structures/chp1-lists-and-the-collections-framework/1-9-the-collections-framework-design.html#the-list-and-randomaccess-interface","text":"The RandomAccess interface is applied only to those implementations in which indexed operations are efficient (e.g., ArrayList). An algorithm can then test to see if a parameter of type List is also of type RandomAccess and, if not, copy its contents into an ArrayList temporarily so that the indexed operations can proceed more efficiently. After the indexed operations are completed, the contents of the ArrayList are copied back to the original.","title":"The List and RandomAccess Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html","text":"1. Arrays Overview Fixed length once initialized. Add or remove element at a specified position without shifting the other elements to make room/fill in the resulting gap. One feature that the array data structure provides that these classes (List classes) don\u2019t is the ability to store primitive\u2010type values. The List classes all store references to Objects, so all primitive\u2010type values must be wrapped in objects. Note that all generic classes in Java extends Object class. NOTE: Circular array implementation will be shown in Queue chapter. Performance Operations/Complexity Best-Case Average-Case Worst-Case Add O(1) (add to the end) O(N) O(N) Delete O(1) (delete from the end) O(N) O(N) Search O(1) O(N) O(N) Get O(1) O(1) O(1) Class java.util.Arrays Method Summary Modifier and Type Method Description static boolean equals(Object[] a, Object[] a2) Returns true if the two specified arrays of Objects are equal to one another. static void fill(Object[] a, Object val) Assigns the specified Object reference to each element of the specified array of Objects. static \\ T[] copyOf(T[] original, int newLength) Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. static \\ T[] copyOfRange(T[] original, int from, int to) Copies the specified range of the specified array into a new array. static String toString(Object[] a) Returns a string representation of the contents of the specified array. static void sort(Object[] a) Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. static \\ void sort(T[] a, Comparator<? super T> c) Sorts the specified array of objects according to the order induced by the specified comparator. int size() Returns the number of elements in this list. static int binarySearch(Object[] a, Object key) Searches the specified array for the specified object using the binary search algorithm. Reference: https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html // A more general method of copying an array System.arraycopy(source, sourcePos, destination, destPos, numElements); 2. List Interface Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list (optional operation). void add(int index, E element) Inserts the specified element at the specified position in this list (optional operation). E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list (optional operation). boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present (optional operation). E set(int index, E element) Replaces the element at the specified position in this list with the specified element (optional operation). int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). 3. ArrayList Overview Java uses array internally to contain the data of a ArrayList . The physical size of the array is indicated by the data field capacity . The number of data items is indicated by the data field size . The data type of the references stored in the underlying array theData (type E[]) is also determined when the MyArrayList object is declared. If no parameter type is specified, the implicit parameter type is Object, and the underlying data array is type Object[]. Class java.util.ArrayList<E> Modifier and Type Method and Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Implementation import java.util.AbstractList; import java.util.Arrays; import java.util.List; public class MyArrayList<E> extends AbstractList<E> implements List<E> { // Data Fields /** The default initial capacity */ private static final int INITIAL_CAPACITY = 10; /** The underlying data array */ private E[] data; /** The current size */ private int size = 0; /** The current capacity */ private int capacity = 0; @SuppressWarnings(\"unchecked\") public MyArrayList(){ this.capacity = INITIAL_CAPACITY; data = (E[]) new Object[capacity]; } public boolean add(E anEntry) { if (size == capacity) { reallocate(); } data[size] = anEntry; size++; return true; } public void add(int index, E anEntry) { if (index < 0 || index > size) { throw new ArrayIndexOutOfBoundsException(index); } if (size == capacity) { reallocate(); } // Shift data in elements from index to size \u2010 1 for (int i = size; i > index; i--) { data[i] = data[i - 1]; } // Insert the new item. data[index] = anEntry; size++; } public E get(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } return data[index]; } public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E oldValue = data[index]; data[index] = newValue; return oldValue; } public E remove(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E returnValue = data[index]; for (int i = index + 1; i < size; i++) { data[i - 1] = data[i]; } size--; return returnValue; } private void reallocate() { capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } public int size() { return this.size; } } Performance Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(1) add(int index, E element) O(N) get(int index) O(1) set(int index, E element) O(1) remove(int index) O(N) remove(Object o) O(N) size() O(1) Recall that when we reallocate the array, we double its size. Doubling an array of size n allows us to add n more items before we need to do another array copy. Therefore, we can add n new items after we have copied over n existing items. This averages out to 1 copy per add. Therefore, reallocation is effectively an O(1) operation, so the insertion (to any index) is still O(n). Extra Syntax: Creating a Generic Collection FORM: CollectionClassName\\ variable = new CollectionClassName<>(); CollectionClassName\\ variable = new CollectionClassName\\ (); EXAMPLE: List\\ people = new ArrayList<>(); List\\ myList = new ArrayList\\ (); ArrayList\\ numList = new ArrayList<>(); MEANING: An initially empty CollectionClassName\\ object is created that can be used to store references to objects of type E (the type parameter). The actual object type stored in an object of type CollectionClassName\\ is specified when the object is created. If the CollectionClassName on the left is an interface, the CollectionClassName on the right must be a class that implements it. Otherwise, it must be the same class or a subclass of the one on the left. The examples above show different ways to create an ArrayList. In this text, we normally specify the interface name on the left of the = operator and the implementing class name on the right as shown in the first two examples. Since the type parameter E must be the same on both sides of the assignment operator, Java 7 introduced the diamond operator <> which eliminates the need to specify the type parameter twice. We will follow this convention. In some cases, we will declare the variable type in one statement and create it in a later statement. In earlier versions of Java, generic collections were not supported. In these versions, you use the statement List yourList = new ArrayList(); to create an initially empty ArrayList. Each element of yourList is a type Object reference. The data types of the actual objects referenced by elements of yourList are not specified, and in fact, different elements can reference objects of different types. Use of the adjective \u201cgeneric\u201d is a bit confusing. A nongeneric collection in Java is very general in that it can store objects of different data types. A generic collection, however, can store objects of one specified data type only. Therefore, generics enable the compiler to do more strict type checking to detect errors at compile time instead of at run time. They also eliminate the need to downcast from type Object to a specific type. For these reasons, we will always use generic collections. Constructor Declaration for Generic Classes The constructor declaration follows. Because the constructor is for a generic class, the type parameter \\ is implied but it must not appear in the constructor heading. \u200b public MyArrayList() { \u200b capacity = INITIAL_CAPACITY; \u200b data = (E[]) new Object[capacity]; \u200b } The statement data = (E[]) new Object[capacity]; allocates storage for an array with type Object references and then casts this array object to type E[] so that it is type compatible with variable theData. Because the actual type corresponding to E is not known, the compiler issues the warning message: MyArrayList.java uses unchecked or unsafe operations. Don\u2019t be concerned about this warning\u2014everything is fine. PITFALL Declaring a Generic Array Rather than use the approach shown in the above constructor, you might try to create a generic array directly using the statement theData = new E[capacity]; // Invalid generic array type. However, this statement will not compile because Java does not allow you to create an array with an unspecified type. Remember, E is a type parameter that is not specified until a generic ArrayList object is created. Therefore, the constructor must create an array of type Object[] since Object is the superclass of all types and then downcast this array object to type E[]. 4. Single-Linked Lists Overview Java does not have a class that implements single-linked lists. Instead, it has a more general double-linked list class. Class LinkedList<E> Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Note that the LinkedList class, part of Java API package java.util , is a double-linked list. However, the API description above is still valid. Implementation import java.util.AbstractSequentialList; import java.util.List; import java.util.ListIterator; /** Class to represent a linked list with a link from each node to the next node. SingleLinkedList does not implement the List interface. */ public class SingleLinkedList<E> extends AbstractSequentialList<E> implements List<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** * Reference to list head. */ private Node<E> head = null; /** * The number of items in the list */ private int size = 0; /** Insert the specified item at index @param index The position where item is to be inserted @param item The item to be inserted @throws IndexOutOfBoundsException if index is out of range */ public void add(int index, E item) { if (index < 0 || index > size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } if (index == 0) { addFirst(item); } else { Node<E> node = getNode(index-1); addAfter(node, item); } } /** Append item to the end of the list @param item The item to be appended @return true (as specified by the Collection interface) */ public boolean add(E item) { add(size, item); return true; } /** Add an item to the front of the list. @param item The item to be added */ public void addFirst(E item) { head = new Node<>(item, head); size++; } /** Add a node after a given node @param node The node preceding the new item @param item The item to insert */ private void addAfter(Node<E> node, E item) { node.next = new Node<>(item, node.next); size++; } /** * Returns the list iterator object. * @param i the index of the iterator. * @return the list iterator object. */ @Override public ListIterator<E> listIterator(int i) { throw new UnsupportedOperationException(); } /** * Removes the element at the specified position in this list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E remove(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } E removedData; if (index == 0) { removedData = removeFirst(); } else { Node<E> prevNode = getNode(index - 1); removedData = removeAfter(prevNode); } return removedData; } /** Remove the node after a given node @param node The node before the one to be removed @return The data from the removed node, or null if there is no node to remove */ private E removeAfter(Node<E> node) { Node<E> temp = node.next; if (temp != null) { node.next = temp.next; size--; return temp.data; } else { return null; } } /** Remove the first node from the list @return The removed node's data or null if the list is empty */ private E removeFirst() { Node<E> temp = head; if (head != null) { head = head.next; } // Return data at old head or null if list is empty if (temp != null) { size--; return temp.data; } else { return null; } } /** Get the data at index @param index The position of the data to return @return The data at index @throws IndexOutOfBoundsException if index is out of range */ public E get(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); return node.data; } /** Find the node at a specified position @param index The position of the node sought @return The node at index or null if it does not exist */ private Node<E> getNode(int index) { Node<E> node = head; for (int i = 0; i < index && node != null; i++) { node = node.next; } return node; } /** Store a reference to anEntry in the element at position index. @param index The position of the item to change @param newValue The new data @return The data previously at index @throws IndexOutOfBoundsException if index is out of range */ public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); E result = node.data; node.data = newValue; return result; } /** * Return the current number of elements in the list. * @return The size of the list */ public int size(){ return size; } /** * Returns the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element. This method allows searching for * an object of type Object. * * @param target the object to search for in the list * @return the index of the first occurrence of the object in the list, or -1 if not found */ public int indexOf(Object target) { Node<E> current = head; int index = 0; while (current != null) { if (current.data.equals(target)) { return index; } current = current.next; index++; } return -1; // Return -1 if the element is not found } } Performance Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(N) - Insertion into the middle: O(N) add(int index, E element) O(N) get(int index) O(N) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) size() O(1) Extra The keyword static in the class header indicates that the Node class will not reference its outer class. (It can\u2019t because it has no methods other than constructors.) In the Java API documentation, static inner classes are also called nested classes. Generally, we want to keep the details of the Node class private. Thus, the qualifier private is applied to the class as well as to the data fields and the constructor. However, the data fields and methods of an inner class are visible anywhere within the enclosing class (also called the parent class). 5. The LinkedList Class Overview The LinkedList class, part of the Java API package java.util , is a double\u2010linked list that implements the List interface. Class java.util.LinkedList<E> Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E get(int index) Returns the element at the specified position in this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E remove() Retrieves and removes the head (first element) of this list. E removeFirst() Removes and returns the first element from this list. E removeLast() Removes and returns the last element from this list. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Reference: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html Performance Operations/Complexity Big O (Worst-Case Complexity) add(E e) - General case: O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(1) - Insertion into the middle: O(N) add(int index, E element) O(N) addFirst(E e) O(1) addLast(E e) O(1) get(int index) O(N) getFirst() O(1) getLast() O(1) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) remove() O(1) removeFirst() O(1) removeLast() O(1) size() O(1) 6. The Iterator , ListIterator , and Iterable Interfaces The Iterator Interface Overview The List interface declares the method iterator, which returns an Iterator object that will iterate over the elements of that list. The requirement for the iterator method is actually in the Collection interface, which is the superinterface for the List interface. The Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an Iterator method. An Iterator does not refer to or point to a particular object at any given time. Rather, you should think of an Iterator as pointing between objects within a list. Think of an iterator as a moving place marker that keeps track of the current position in a particular linked list. The Iterator object for a list starts at the first element in the list. The programmer can use the Iterator object\u2019s next method to retrieve the next element. Each time it does a retrieval, the Iterator object advances to the next list element, where it waits until it is needed again. We can also ask the Iterator object to determine whether the list has more elements left to process (method hasNext ). Iterator objects throw a NoSuchElementException if they are asked to retrieve the next element after all elements have been processed. You can use the Iterator remove method to remove elements from a list as you access them. You can remove only the element that was most recently accessed by next. Each call to remove must be preceded by a call to next to retrieve the next element. Interface java.util.Iterator<E> Modifier and Type Method Description boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation). Extra Efficient Access to List Elements by Iterator We can use the following loop to access the list elements in sequence, starting with the one at index 0. // Access each list element. for (int index = 0; index < aList.size(); index++) { E nextElement = aList.get(index); // Do something with the element at position index (nextElement) . . . } The loop is executed aList.size() times; thus it is O( n ). During each iteration, we call the method get to retrieve the element at position index. If we assume that the method get begins at the first list node (head), each call to method get must advance a local reference (nodeRef) to the node at position index using a loop such as: // Advance nodeRef to the element at position index. Node nodeRef = head; for (int j = 0; j < index; j++) { nodeRef = nodeRef.next; } This loop (in method get) executes index times, so it is also O( n ). Therefore, the performance of the nested loops used to process each element in a LinkedList is O( n^2 ) and is very inefficient. We would like to have an alternative way to access the elements in a linked list sequentially. Removal Using Iterator.remove versus List.remove You could also use method LinkedList.remove to remove elements from a list. However, it is more efficient to remove multiple elements from a list using Iterator.remove than it would be to use LinkedList.remove. The LinkedList.remove method removes only one element at a time, so you would need to start at the beginning of the list each time and advance down the list to each element that you wanted to remove (O(n2) process). With the Iterator.remove method, you can remove elements as they are accessed by the Iterator object without having to go back to the beginning of the list (O(n) process). The Enhanced for Loop The enhanced for loop creates an Iterator object and implicitly calls its hasNext and next methods. Other Iterator methods, such as remove, are not available. FORM : for (formalParameter : expression) { . . . } EXAMPLE : for (String nextStr : myList) { . . . } for (int nextInt : aList) { . . . } MEANING : During each repetition of the loop, the variable specified by formalParameter accesses the next element of expression, starting with the first element and ending with the last. The expression must be an array or a collection that implements the Iterable interface. The Collection interface extends the Iterable interface so that all classes that implement it are implementors of the Iterable interface (see next section). The ListIterator Interface Overview The Iterator has some limitations. It can traverse the List only in the forward direction. It also provides only a remove method, not an add method. Also, to start an Iterator somewhere other than at first List element, you must write your own loop to advance the Iterator to the desired starting position. The next method moves the iterator forward and returns the element that was jumped over. The previous method moves the iterator backward and also returns the element that was jumped over. Interface java.util.ListIterator<E> Modifier and Type Method Description void add(E e) Inserts the specified element into the list (optional operation). Inserts object obj into the list just before the item that would be returned by the next call to method next and after the item that would have been returned by method previous. If the method previous is called after add, the newly inserted object will be returned boolean hasNext() Returns true if this list iterator has more elements when traversing the list in the forward direction. boolean hasPrevious() Returns true if this list iterator has more elements when traversing the list in the reverse direction. E next() Returns the next element in the list and advances the cursor position. int nextIndex() Returns the index of the element that would be returned by a subsequent call to next(). E previous() Returns the previous element in the list and moves the cursor position backwards. int previousIndex() Returns the index of the element that would be returned by a subsequent call to previous(). void remove() Removes from the list the last element that was returned by next() or previous() (optional operation). Removes the last item returned from a call to next or previous. If a call to remove is not preceded by a call to next or previous, the IllegalStateException is thrown void set(E e) Replaces the last element returned by next() or previous() with the specified element (optional). Replaces the last item returned from a call to next or previous with obj. If a call to set is not preceded by a call to next or previous, the IllegalStateException is thrown Methods in java.util.LinkedList<E> that Return ListIterator Modifier and Type Method Description ListIterator\\ listIterator() Returns a ListIterator that begins just before the first list element. ListIterator\\ listIterator(int index) Returns a ListIterator that begins just before the position index. Comparison of Iterator and ListIterator Because the interface ListIterator<E> is a subinterface of Iterator<E> , classes that implement ListIterator must provide all of the capabilities of both. The Iterator interface requires fewer methods and can be used to iterate over more general data structures\u2014that is, structures for which an index is not meaningful and ones for which traversing in only the forward direction is required. It is for this reason that the Iterator is required by the Collection interface (more general), whereas the ListIterator is required only by the List interface (more specialized). The Iterable Interface Overview This interface requires only that a class that implements it provides an iterator method. As mentioned above, the Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an iterator method. Interface java.lang.Iterable<T> Modifier and Type Method and Description default void forEach(Consumer<? super T> action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable. 7. Double-Linked List (Linked List) Overview A double\u2010linked list object would consist of a separate object with data fields head (a reference to the first list Node), tail (a reference to the last list Node), and size (the number of Nodes). Because both ends of the list are directly accessible, now insertion at either end is O(1); insertion else- where is still O(n). Implementation We can implement most of the MyLinkedList methods by delegation to the class MyListIterator , which will implement the ListIterator interface Data Fields for Class MyLinkedList<E> (Double-Linked List) Data Field Attribute private Node head A reference to the first item in the list private Node tail A reference to the last item in the list private int size A count of the number of items in the list package datastructures.list; import java.util.*; /** Class KWLinkedList implements a double\u2010linked list and a ListIterator. */ public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>{ /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; /** The reference to the previous node. */ private Node<E> prev; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** Inner class to implement the ListIterator interface. */ private class MyListIterator implements ListIterator<E> { /** A reference to the next item. */ private Node<E> nextItem; /** A reference to the last item returned. */ private Node<E> lastItemReturned; /** The index of the current item. */ private int index = 0; /** Construct a KWListIter that will reference the ith item. @param i The index of the item to be referenced */ public MyListIterator(int i) { // Validate i parameter. if (i < 0 || i > size) { throw new IndexOutOfBoundsException(\"Invalid index \" + i); } lastItemReturned = null; // No item returned yet. // Special case of last item. if (i == size) { index = size; nextItem = null; } else { // Start at the beginning nextItem = head; for (index = 0; index < i; index++) { nextItem = nextItem.next; } } } /** Indicate whether movement forward is defined. @return true if call to next will not throw an exception */ public boolean hasNext() { return nextItem != null; } /** Move the iterator forward and return the next item. @return The next item in the list @throws NoSuchElementException if there is no such object */ public E next() { if (!hasNext()) { throw new NoSuchElementException(); } lastItemReturned = nextItem; nextItem = nextItem.next; index++; return lastItemReturned.data; } /** Indicate whether movement backward is defined. @return true if call to previous will not throw an exception */ public boolean hasPrevious() { return (nextItem == null && size != 0) || nextItem.prev != null; } /** Move the iterator backward and return the previous item. @return The previous item in the list @throws NoSuchElementException if there is no such object */ public E previous() { if (!hasPrevious()) { throw new NoSuchElementException(); } if (nextItem == null) { // Iterator is past the last element nextItem = tail; } else { nextItem = nextItem.prev; } lastItemReturned = nextItem; index--; return lastItemReturned.data; } /** * Returns the index of the element that would be returned by a subsequent call to next(). * * @return the index of the element that would be returned by a subsequent call to next(), * or the size of the list if there is no next element */ @Override public int nextIndex() { return (hasNext()) ? index : size; } /** * Returns the index of the element that would be returned by a subsequent call to previous(). * * @return the index of the element that would be returned by a subsequent call to previous(), * or -1 if there is no previous element */ @Override public int previousIndex() { return (hasPrevious()) ? index - 1 : -1; } /** * Removes from the list the last element that was returned by next() or previous(). * * This method has not been verified! * * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void remove() { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to remove\"); } Node<E> lastNext = lastItemReturned.next; Node<E> lastPrev = lastItemReturned.prev; if (lastPrev == null) { // Removing first element head = lastNext; } else { lastPrev.next = lastNext; lastItemReturned.prev = null; } if (lastNext == null) { // Removing last element tail = lastPrev; } else { lastNext.prev = lastPrev; lastItemReturned.next = null; } if (nextItem == lastItemReturned) { nextItem = lastNext; } else { index--; } lastItemReturned.data = null; lastItemReturned = null; size--; } /** * Replaces the last element returned by next() or previous() with the specified element. * * @param e the element with which to replace the last returned element * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void set(E e) { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to set\"); } lastItemReturned.data = e; } /** Add a new item between the item that will be returned by next and the item that will be returned by previous. If previous is called after add, the element added is returned. @param obj The item to be inserted */ public void add(E obj) { if (head == null) { // Add to an empty list. head = new Node<>(obj); tail = head; } else if (nextItem == head) { // Insert at head // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to the nextItem. newNode.next = nextItem; // Link nextItem to the new node. nextItem.prev = newNode; // The new node is now the head. head = newNode; } else if(nextItem == null){ // Insert at tail // Create a new node. Node<E> newNode = new Node<>(obj); // Link the tail to the new node. tail.next = newNode; // Link the new node to the tail. newNode.prev = tail; // The new node is the new tail. tail = newNode; } else { // Insert into the middle. // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to nextItem.prev. newNode.prev = nextItem.prev; nextItem.prev.next = newNode; // Link it to the nextItem. newNode.next = nextItem; nextItem.prev = newNode; } // Increase size and index and set lastItemReturned. size++; index++; lastItemReturned = null; } // End of method add. } // Data Fields /** A reference to the head of the list. */ private Node<E> head = null; /** A reference to the end of the list. */ private Node<E> tail = null; /** The size of the list. */ private int size = 0; /** Add an item at position index. @param index The position at which the object is to be inserted @param obj The object to be inserted @throws IndexOutOfBoundsException if the index is out of range (i < 0 || i > size()) */ public void add(int index, E obj) { listIterator(index).add(obj); } @Override public ListIterator<E> listIterator(int i) { return new MyListIterator(i); } /** Get the element at position index. @param index Position of item to be retrieved @return The item at index */ public E get(int index) { return listIterator(index).next(); } /** * Return the number of elements in this list. * @return The number of elements in this list. */ @Override public int size() { return size; } } Extra Inner Classes: Static and Nonstatic There are two inner classes in class LinkedList\\ : class Node and class MyListIterator. We declare Node\\ to be static because there is no need for its methods to access the data fields of its parent class (LinkedList\\ ). We can\u2019t declare MyListIterator to be static because its methods access and modify the data fields of the LinkedList object that creates the MyListIterator object. An inner class that is not static contains an implicit reference to its parent object, just as it contains an implicit reference to itself. Because MyListIterator is not static and can reference data fields of its parent class LinkedList\\ , the type parameter is considered to be previously defined; therefore, it cannot appear as part of the class name. PITFALL Defining MyListIterator as a Generic Inner Class If you define class MyListIterator as private class MyListIterator ... you will get an incompatible types syntax error when you attempt to reference data field head or tail (type Node\\ ) inside class MyListIterator. 8. Circular Linked List Overview Circularly Linked Lists: Linked lists are traditionally viewed as storing a sequence of items in a linear order, from first to last. However, there are many applications in which data can be more naturally viewed as having a cyclic order, with well-defined neighboring relationships, but no fixed beginning or end. Example Application: Round-Robin Scheduling A process is given a short turn to execute, known as a time slice, but it is interrupted when the slice ends, even if its job is not yet complete. Each active process is given its own time slice, taking turns in a cyclic order. Class CircularlyLinkedList<E> Data Fields Data Field Attribute private Node tail A reference to the last item in the list private int size A count of the number of items in the list Method Summary Modifier and Type Method Description void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. void rotate() Rotates the first element to the back of the list. E removeFirst() Removes and returns the first element from this list. Implementation public class CircularLinkedList<E> { // Nested node class identical to that of the SinglyLinkedList class private static class Node<E> { private E element; private Node<E> next; public Node(E e, Node<E> n) { element = e; next = n; } public E getElement() { return element; } public Node<E> getNext() { return next; } public void setNext(Node<E> n) { next = n; } } private Node<E> tail = null; // We store tail (but not head) private int size = 0; // Number of nodes in the list public CircularLinkedList() { } // Constructs an initially empty list // Access methods public int size() { return size; } public boolean isEmpty() { return size == 0; } public E getFirst() { // Returns (but does not remove) the first element if (isEmpty()) return null; return tail.getNext().getElement(); // The head is *after* the tail } public E getLast() { // Returns (but does not remove) the last element if (isEmpty()) return null; return tail.getElement(); } // Update methods public void rotate() { // Rotate the first element to the back of the list if (tail != null) // If empty, do nothing tail = tail.getNext(); // The old head becomes the new tail } public void addFirst(E e) { // Adds element e to the front of the list if (size == 0) { tail = new Node<>(e, null); tail.setNext(tail); // Link to itself circularly } else { Node<E> newest = new Node<>(e, tail.getNext()); tail.setNext(newest); } size++; } public void addLast(E e) { // Adds element e to the end of the list addFirst(e); // Insert new element at front of list tail = tail.getNext(); // Now new element becomes the tail } public E removeFirst() { // Removes and returns the first element if (isEmpty()) return null; // Nothing to remove Node<E> head = tail.getNext(); if (head == tail) tail = null; // Must be the only node left else tail.setNext(head.getNext()); // Removes \u201dhead\u201d from the list size--; return head.getElement(); } } TODO: The implementations of some methods are missing and should be fixed in the future. Performance Operations/Complexity Big O addFirst(E e) O(1) addLast(E e) O(1) getFirst() O(1) getLast() O(1) rotate() O(1) removeFirst() O(1) 9. The Collections Framework Design The Collection Interface The Collection interface specifies a subset of the methods specified in the List interface. Specifically, the add(int, E), get(int), remove(int), set(int, E), and related methods (all of which have an int parameter that represents a position) are not in the Collection interface, but the add(E) and remove(Object) methods, which do not specify a position, are included. The iterator method is also included in the Collection interface. Thus, you can use an Iterator to access all of the items in a Collection , but the order in which they are retrieved is not necessarily related to the order in which they were inserted The Collection interface is part of the Collections Framework. This interface has three subinterfaces: the List interface, the Queue interface, and the Set interface. The Java API does not provide any direct implementation of the Collection interface. The interface is used to reference collections of data in the most general way. Common Features of Collections A few features can be considered fundamental: Collections grow as needed. Collections hold references to objects. Collections have at least two constructors: one to create an empty collection and one to make a copy of another collection. For collections implementing the List interface, the order of the elements is determined by the index of the elements. In the more general Collection, the order is not specified. Interface java.util.Collection<E> Modifier and Type Method and Description boolean add(E e) Ensures that this collection contains the specified element (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this collection (optional operation). void clear() Removes all of the elements from this collection (optional operation). boolean contains(Object o) Returns true if this collection contains the specified element. boolean containsAll(Collection<?> c) Returns true if this collection contains all of the elements in the specified collection. boolean equals(Object o) Compares the specified object with this collection for equality. boolean isEmpty() Returns true if this collection contains no elements. Iterator iterator() Returns an iterator over the elements in this collection. boolean remove(Object o) Removes a single instance of the specified element from this collection, if it is present (optional operation). boolean removeAll(Collection<?> c) Removes all of this collection's elements that are also contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this collection that are contained in the specified collection (optional operation). int size() Returns the number of elements in this collection. Object[] toArray() Returns an array containing all of the elements in this collection. The AbstractCollection , AbstractList , and AbstractSequentialList Classes If you look at the Java API documentation, you will see that the Collection and List interfaces specify a large number of methods. To help implement these interfaces, the Java API includes the AbstractCollection and AbstractList classes. You can think of these classes as a kit that can be used to build implementations of their corresponding interface. Most of the methods are provided, but you need to add a few to make it complete. To implement the Collection interface completely, you need only extend the AbstractCollection class, provide an implementation of the add, size, and iterator methods, and supply an inner class to implement the Iterator interface. To implement the List interface, you can extend the AbstractList class and provide an implementation of the add(int, E), get(int), remove(int), set(int, E), and size() methods. Since we provided these methods in our ArrayList , we can make it a complete implementation of the List interface by changing the class declaration to java public class ArrayList<E> extends AbstractList<E> implements List<E> Note that the AbstractList class implements the iterator and listIterator methods using the index associated with the elements. Another way to implement the List interface is to extend the AbstractSequentialList class, implement the listIterator and size methods, and provide an inner class that implements the ListIterator interface. This was the approach we took in our LinkedList . Thus, by changing the class declaration to java public class LinkedList<E> extends AbstractSequentialList<E> implements List<E> it becomes a complete implementation of the List interface. Our LinkedList class included the add, get, remove, and set methods. These are provided by the AbstractSequentialList , so we could remove them from our LinkedList class and still have a complete List implementation. The List and RandomAccess Interface The RandomAccess interface is applied only to those implementations in which indexed operations are efficient (e.g., ArrayList). An algorithm can then test to see if a parameter of type List is also of type RandomAccess and, if not, copy its contents into an ArrayList temporarily so that the indexed operations can proceed more efficiently. After the indexed operations are completed, the contents of the ArrayList are copied back to the original.","title":"1. Arrays"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#1-arrays","text":"","title":"1. Arrays"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview","text":"Fixed length once initialized. Add or remove element at a specified position without shifting the other elements to make room/fill in the resulting gap. One feature that the array data structure provides that these classes (List classes) don\u2019t is the ability to store primitive\u2010type values. The List classes all store references to Objects, so all primitive\u2010type values must be wrapped in objects. Note that all generic classes in Java extends Object class. NOTE: Circular array implementation will be shown in Queue chapter.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#performance","text":"Operations/Complexity Best-Case Average-Case Worst-Case Add O(1) (add to the end) O(N) O(N) Delete O(1) (delete from the end) O(N) O(N) Search O(1) O(N) O(N) Get O(1) O(1) O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#class-javautilarrays","text":"","title":"Class java.util.Arrays"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#method-summary","text":"Modifier and Type Method Description static boolean equals(Object[] a, Object[] a2) Returns true if the two specified arrays of Objects are equal to one another. static void fill(Object[] a, Object val) Assigns the specified Object reference to each element of the specified array of Objects. static \\ T[] copyOf(T[] original, int newLength) Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. static \\ T[] copyOfRange(T[] original, int from, int to) Copies the specified range of the specified array into a new array. static String toString(Object[] a) Returns a string representation of the contents of the specified array. static void sort(Object[] a) Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. static \\ void sort(T[] a, Comparator<? super T> c) Sorts the specified array of objects according to the order induced by the specified comparator. int size() Returns the number of elements in this list. static int binarySearch(Object[] a, Object key) Searches the specified array for the specified object using the binary search algorithm. Reference: https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html // A more general method of copying an array System.arraycopy(source, sourcePos, destination, destPos, numElements);","title":"Method Summary"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#2-list-interface","text":"Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list (optional operation). void add(int index, E element) Inserts the specified element at the specified position in this list (optional operation). E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list (optional operation). boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present (optional operation). E set(int index, E element) Replaces the element at the specified position in this list with the specified element (optional operation). int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element).","title":"2. List Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#3-arraylist","text":"","title":"3. ArrayList"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_1","text":"Java uses array internally to contain the data of a ArrayList . The physical size of the array is indicated by the data field capacity . The number of data items is indicated by the data field size . The data type of the references stored in the underlying array theData (type E[]) is also determined when the MyArrayList object is declared. If no parameter type is specified, the implicit parameter type is Object, and the underlying data array is type Object[].","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#class-javautilarrayliste","text":"Modifier and Type Method and Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element).","title":"Class java.util.ArrayList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#implementation","text":"import java.util.AbstractList; import java.util.Arrays; import java.util.List; public class MyArrayList<E> extends AbstractList<E> implements List<E> { // Data Fields /** The default initial capacity */ private static final int INITIAL_CAPACITY = 10; /** The underlying data array */ private E[] data; /** The current size */ private int size = 0; /** The current capacity */ private int capacity = 0; @SuppressWarnings(\"unchecked\") public MyArrayList(){ this.capacity = INITIAL_CAPACITY; data = (E[]) new Object[capacity]; } public boolean add(E anEntry) { if (size == capacity) { reallocate(); } data[size] = anEntry; size++; return true; } public void add(int index, E anEntry) { if (index < 0 || index > size) { throw new ArrayIndexOutOfBoundsException(index); } if (size == capacity) { reallocate(); } // Shift data in elements from index to size \u2010 1 for (int i = size; i > index; i--) { data[i] = data[i - 1]; } // Insert the new item. data[index] = anEntry; size++; } public E get(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } return data[index]; } public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E oldValue = data[index]; data[index] = newValue; return oldValue; } public E remove(int index) { if (index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); } E returnValue = data[index]; for (int i = index + 1; i < size; i++) { data[i - 1] = data[i]; } size--; return returnValue; } private void reallocate() { capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } public int size() { return this.size; } }","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#performance_1","text":"Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(1) add(int index, E element) O(N) get(int index) O(1) set(int index, E element) O(1) remove(int index) O(N) remove(Object o) O(N) size() O(1) Recall that when we reallocate the array, we double its size. Doubling an array of size n allows us to add n more items before we need to do another array copy. Therefore, we can add n new items after we have copied over n existing items. This averages out to 1 copy per add. Therefore, reallocation is effectively an O(1) operation, so the insertion (to any index) is still O(n).","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#extra","text":"","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#syntax-creating-a-generic-collection","text":"FORM: CollectionClassName\\ variable = new CollectionClassName<>(); CollectionClassName\\ variable = new CollectionClassName\\ (); EXAMPLE: List\\ people = new ArrayList<>(); List\\ myList = new ArrayList\\ (); ArrayList\\ numList = new ArrayList<>(); MEANING: An initially empty CollectionClassName\\ object is created that can be used to store references to objects of type E (the type parameter). The actual object type stored in an object of type CollectionClassName\\ is specified when the object is created. If the CollectionClassName on the left is an interface, the CollectionClassName on the right must be a class that implements it. Otherwise, it must be the same class or a subclass of the one on the left. The examples above show different ways to create an ArrayList. In this text, we normally specify the interface name on the left of the = operator and the implementing class name on the right as shown in the first two examples. Since the type parameter E must be the same on both sides of the assignment operator, Java 7 introduced the diamond operator <> which eliminates the need to specify the type parameter twice. We will follow this convention. In some cases, we will declare the variable type in one statement and create it in a later statement. In earlier versions of Java, generic collections were not supported. In these versions, you use the statement List yourList = new ArrayList(); to create an initially empty ArrayList. Each element of yourList is a type Object reference. The data types of the actual objects referenced by elements of yourList are not specified, and in fact, different elements can reference objects of different types. Use of the adjective \u201cgeneric\u201d is a bit confusing. A nongeneric collection in Java is very general in that it can store objects of different data types. A generic collection, however, can store objects of one specified data type only. Therefore, generics enable the compiler to do more strict type checking to detect errors at compile time instead of at run time. They also eliminate the need to downcast from type Object to a specific type. For these reasons, we will always use generic collections.","title":"Syntax: Creating a Generic Collection"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#constructor-declaration-for-generic-classes","text":"The constructor declaration follows. Because the constructor is for a generic class, the type parameter \\ is implied but it must not appear in the constructor heading. \u200b public MyArrayList() { \u200b capacity = INITIAL_CAPACITY; \u200b data = (E[]) new Object[capacity]; \u200b } The statement data = (E[]) new Object[capacity]; allocates storage for an array with type Object references and then casts this array object to type E[] so that it is type compatible with variable theData. Because the actual type corresponding to E is not known, the compiler issues the warning message: MyArrayList.java uses unchecked or unsafe operations. Don\u2019t be concerned about this warning\u2014everything is fine.","title":"Constructor Declaration for Generic Classes"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#pitfall","text":"","title":"PITFALL"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#declaring-a-generic-array","text":"Rather than use the approach shown in the above constructor, you might try to create a generic array directly using the statement theData = new E[capacity]; // Invalid generic array type. However, this statement will not compile because Java does not allow you to create an array with an unspecified type. Remember, E is a type parameter that is not specified until a generic ArrayList object is created. Therefore, the constructor must create an array of type Object[] since Object is the superclass of all types and then downcast this array object to type E[].","title":"Declaring a Generic Array"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#4-single-linked-lists","text":"","title":"4. Single-Linked Lists"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_2","text":"Java does not have a class that implements single-linked lists. Instead, it has a more general double-linked list class.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#class-linkedliste","text":"Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. E get(int index) Returns the element at the specified position in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Note that the LinkedList class, part of Java API package java.util , is a double-linked list. However, the API description above is still valid.","title":"Class LinkedList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#implementation_1","text":"import java.util.AbstractSequentialList; import java.util.List; import java.util.ListIterator; /** Class to represent a linked list with a link from each node to the next node. SingleLinkedList does not implement the List interface. */ public class SingleLinkedList<E> extends AbstractSequentialList<E> implements List<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** * Reference to list head. */ private Node<E> head = null; /** * The number of items in the list */ private int size = 0; /** Insert the specified item at index @param index The position where item is to be inserted @param item The item to be inserted @throws IndexOutOfBoundsException if index is out of range */ public void add(int index, E item) { if (index < 0 || index > size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } if (index == 0) { addFirst(item); } else { Node<E> node = getNode(index-1); addAfter(node, item); } } /** Append item to the end of the list @param item The item to be appended @return true (as specified by the Collection interface) */ public boolean add(E item) { add(size, item); return true; } /** Add an item to the front of the list. @param item The item to be added */ public void addFirst(E item) { head = new Node<>(item, head); size++; } /** Add a node after a given node @param node The node preceding the new item @param item The item to insert */ private void addAfter(Node<E> node, E item) { node.next = new Node<>(item, node.next); size++; } /** * Returns the list iterator object. * @param i the index of the iterator. * @return the list iterator object. */ @Override public ListIterator<E> listIterator(int i) { throw new UnsupportedOperationException(); } /** * Removes the element at the specified position in this list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException if the index is out of range */ public E remove(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } E removedData; if (index == 0) { removedData = removeFirst(); } else { Node<E> prevNode = getNode(index - 1); removedData = removeAfter(prevNode); } return removedData; } /** Remove the node after a given node @param node The node before the one to be removed @return The data from the removed node, or null if there is no node to remove */ private E removeAfter(Node<E> node) { Node<E> temp = node.next; if (temp != null) { node.next = temp.next; size--; return temp.data; } else { return null; } } /** Remove the first node from the list @return The removed node's data or null if the list is empty */ private E removeFirst() { Node<E> temp = head; if (head != null) { head = head.next; } // Return data at old head or null if list is empty if (temp != null) { size--; return temp.data; } else { return null; } } /** Get the data at index @param index The position of the data to return @return The data at index @throws IndexOutOfBoundsException if index is out of range */ public E get(int index) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); return node.data; } /** Find the node at a specified position @param index The position of the node sought @return The node at index or null if it does not exist */ private Node<E> getNode(int index) { Node<E> node = head; for (int i = 0; i < index && node != null; i++) { node = node.next; } return node; } /** Store a reference to anEntry in the element at position index. @param index The position of the item to change @param newValue The new data @return The data previously at index @throws IndexOutOfBoundsException if index is out of range */ public E set(int index, E newValue) { if (index < 0 || index >= size) { throw new IndexOutOfBoundsException(Integer.toString(index)); } Node<E> node = getNode(index); E result = node.data; node.data = newValue; return result; } /** * Return the current number of elements in the list. * @return The size of the list */ public int size(){ return size; } /** * Returns the index of the first occurrence of the specified element in this list, * or -1 if this list does not contain the element. This method allows searching for * an object of type Object. * * @param target the object to search for in the list * @return the index of the first occurrence of the object in the list, or -1 if not found */ public int indexOf(Object target) { Node<E> current = head; int index = 0; while (current != null) { if (current.data.equals(target)) { return index; } current = current.next; index++; } return -1; // Return -1 if the element is not found } }","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#performance_2","text":"Operations/Complexity Big O (Worst-Case Complexity) add(E e) O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(N) - Insertion into the middle: O(N) add(int index, E element) O(N) get(int index) O(N) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) size() O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#extra_1","text":"The keyword static in the class header indicates that the Node class will not reference its outer class. (It can\u2019t because it has no methods other than constructors.) In the Java API documentation, static inner classes are also called nested classes. Generally, we want to keep the details of the Node class private. Thus, the qualifier private is applied to the class as well as to the data fields and the constructor. However, the data fields and methods of an inner class are visible anywhere within the enclosing class (also called the parent class).","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#5-the-linkedlist-class","text":"","title":"5. The LinkedList Class"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_3","text":"The LinkedList class, part of the Java API package java.util , is a double\u2010linked list that implements the List interface.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#class-javautillinkedliste","text":"Modifier and Type Method Description boolean add(E e) Appends the specified element to the end of this list. void add(int index, E element) Inserts the specified element at the specified position in this list. void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E get(int index) Returns the element at the specified position in this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. int indexOf(Object o) Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. Iterator\\ iterator() Returns an iterator over the elements in this list in proper sequence. E remove(int index) Removes the element at the specified position in this list. boolean remove(Object o) Removes the first occurrence of the specified element from this list, if it is present. E remove() Retrieves and removes the head (first element) of this list. E removeFirst() Removes and returns the first element from this list. E removeLast() Removes and returns the last element from this list. E set(int index, E element) Replaces the element at the specified position in this list with the specified element. int size() Returns the number of elements in this list. Object[] toArray() Returns an array containing all of the elements in this list in proper sequence (from first to last element). Reference: https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html","title":"Class java.util.LinkedList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#performance_3","text":"Operations/Complexity Big O (Worst-Case Complexity) add(E e) - General case: O(N) - Insertion at the beginning: O(1) - Insertion in the end: O(1) - Insertion into the middle: O(N) add(int index, E element) O(N) addFirst(E e) O(1) addLast(E e) O(1) get(int index) O(N) getFirst() O(1) getLast() O(1) set(int index, E element) O(N) remove(int index) O(N) remove(Object o) O(N) remove() O(1) removeFirst() O(1) removeLast() O(1) size() O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#6-the-iterator-listiterator-and-iterable-interfaces","text":"","title":"6. The Iterator, ListIterator, and Iterable Interfaces"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#the-iterator-interface","text":"","title":"The Iterator Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_4","text":"The List interface declares the method iterator, which returns an Iterator object that will iterate over the elements of that list. The requirement for the iterator method is actually in the Collection interface, which is the superinterface for the List interface. The Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an Iterator method. An Iterator does not refer to or point to a particular object at any given time. Rather, you should think of an Iterator as pointing between objects within a list. Think of an iterator as a moving place marker that keeps track of the current position in a particular linked list. The Iterator object for a list starts at the first element in the list. The programmer can use the Iterator object\u2019s next method to retrieve the next element. Each time it does a retrieval, the Iterator object advances to the next list element, where it waits until it is needed again. We can also ask the Iterator object to determine whether the list has more elements left to process (method hasNext ). Iterator objects throw a NoSuchElementException if they are asked to retrieve the next element after all elements have been processed. You can use the Iterator remove method to remove elements from a list as you access them. You can remove only the element that was most recently accessed by next. Each call to remove must be preceded by a call to next to retrieve the next element.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#interface-javautiliteratore","text":"Modifier and Type Method Description boolean hasNext() Returns true if the iteration has more elements. E next() Returns the next element in the iteration. default void remove() Removes from the underlying collection the last element returned by this iterator (optional operation).","title":"Interface java.util.Iterator&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#extra_2","text":"","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#efficient-access-to-list-elements-by-iterator","text":"We can use the following loop to access the list elements in sequence, starting with the one at index 0. // Access each list element. for (int index = 0; index < aList.size(); index++) { E nextElement = aList.get(index); // Do something with the element at position index (nextElement) . . . } The loop is executed aList.size() times; thus it is O( n ). During each iteration, we call the method get to retrieve the element at position index. If we assume that the method get begins at the first list node (head), each call to method get must advance a local reference (nodeRef) to the node at position index using a loop such as: // Advance nodeRef to the element at position index. Node nodeRef = head; for (int j = 0; j < index; j++) { nodeRef = nodeRef.next; } This loop (in method get) executes index times, so it is also O( n ). Therefore, the performance of the nested loops used to process each element in a LinkedList is O( n^2 ) and is very inefficient. We would like to have an alternative way to access the elements in a linked list sequentially.","title":"Efficient Access to List Elements by Iterator"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#removal-using-iteratorremove-versus-listremove","text":"You could also use method LinkedList.remove to remove elements from a list. However, it is more efficient to remove multiple elements from a list using Iterator.remove than it would be to use LinkedList.remove. The LinkedList.remove method removes only one element at a time, so you would need to start at the beginning of the list each time and advance down the list to each element that you wanted to remove (O(n2) process). With the Iterator.remove method, you can remove elements as they are accessed by the Iterator object without having to go back to the beginning of the list (O(n) process).","title":"Removal Using Iterator.remove versus List.remove"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#the-enhanced-for-loop","text":"The enhanced for loop creates an Iterator object and implicitly calls its hasNext and next methods. Other Iterator methods, such as remove, are not available. FORM : for (formalParameter : expression) { . . . } EXAMPLE : for (String nextStr : myList) { . . . } for (int nextInt : aList) { . . . } MEANING : During each repetition of the loop, the variable specified by formalParameter accesses the next element of expression, starting with the first element and ending with the last. The expression must be an array or a collection that implements the Iterable interface. The Collection interface extends the Iterable interface so that all classes that implement it are implementors of the Iterable interface (see next section).","title":"The Enhanced for Loop"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#the-listiterator-interface","text":"","title":"The ListIterator Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_5","text":"The Iterator has some limitations. It can traverse the List only in the forward direction. It also provides only a remove method, not an add method. Also, to start an Iterator somewhere other than at first List element, you must write your own loop to advance the Iterator to the desired starting position. The next method moves the iterator forward and returns the element that was jumped over. The previous method moves the iterator backward and also returns the element that was jumped over.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#interface-javautillistiteratore","text":"Modifier and Type Method Description void add(E e) Inserts the specified element into the list (optional operation). Inserts object obj into the list just before the item that would be returned by the next call to method next and after the item that would have been returned by method previous. If the method previous is called after add, the newly inserted object will be returned boolean hasNext() Returns true if this list iterator has more elements when traversing the list in the forward direction. boolean hasPrevious() Returns true if this list iterator has more elements when traversing the list in the reverse direction. E next() Returns the next element in the list and advances the cursor position. int nextIndex() Returns the index of the element that would be returned by a subsequent call to next(). E previous() Returns the previous element in the list and moves the cursor position backwards. int previousIndex() Returns the index of the element that would be returned by a subsequent call to previous(). void remove() Removes from the list the last element that was returned by next() or previous() (optional operation). Removes the last item returned from a call to next or previous. If a call to remove is not preceded by a call to next or previous, the IllegalStateException is thrown void set(E e) Replaces the last element returned by next() or previous() with the specified element (optional). Replaces the last item returned from a call to next or previous with obj. If a call to set is not preceded by a call to next or previous, the IllegalStateException is thrown","title":"Interface java.util.ListIterator&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#methods-in-javautillinkedliste-that-return-listiterator","text":"Modifier and Type Method Description ListIterator\\ listIterator() Returns a ListIterator that begins just before the first list element. ListIterator\\ listIterator(int index) Returns a ListIterator that begins just before the position index.","title":"Methods in java.util.LinkedList&lt;E&gt; that Return ListIterator"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#comparison-of-iterator-and-listiterator","text":"Because the interface ListIterator<E> is a subinterface of Iterator<E> , classes that implement ListIterator must provide all of the capabilities of both. The Iterator interface requires fewer methods and can be used to iterate over more general data structures\u2014that is, structures for which an index is not meaningful and ones for which traversing in only the forward direction is required. It is for this reason that the Iterator is required by the Collection interface (more general), whereas the ListIterator is required only by the List interface (more specialized).","title":"Comparison of Iterator and ListIterator"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#the-iterable-interface","text":"","title":"The Iterable Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_6","text":"This interface requires only that a class that implements it provides an iterator method. As mentioned above, the Collection interface extends the Iterable interface, so all classes that implement the List interface (a subinterface of Collection ) must provide an iterator method.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#interface-javalangiterablet","text":"Modifier and Type Method and Description default void forEach(Consumer<? super T> action) Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Iterator iterator() Returns an iterator over elements of type T. default Spliterator spliterator() Creates a Spliterator over the elements described by this Iterable.","title":"Interface java.lang.Iterable&lt;T&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#7-double-linked-list-linked-list","text":"","title":"7. Double-Linked List (Linked List)"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_7","text":"A double\u2010linked list object would consist of a separate object with data fields head (a reference to the first list Node), tail (a reference to the last list Node), and size (the number of Nodes). Because both ends of the list are directly accessible, now insertion at either end is O(1); insertion else- where is still O(n).","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#implementation_2","text":"We can implement most of the MyLinkedList methods by delegation to the class MyListIterator , which will implement the ListIterator interface","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#data-fields-for-class-mylinkedliste-double-linked-list","text":"Data Field Attribute private Node head A reference to the first item in the list private Node tail A reference to the last item in the list private int size A count of the number of items in the list package datastructures.list; import java.util.*; /** Class KWLinkedList implements a double\u2010linked list and a ListIterator. */ public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>{ /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; /** The reference to the previous node. */ private Node<E> prev; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } /** Inner class to implement the ListIterator interface. */ private class MyListIterator implements ListIterator<E> { /** A reference to the next item. */ private Node<E> nextItem; /** A reference to the last item returned. */ private Node<E> lastItemReturned; /** The index of the current item. */ private int index = 0; /** Construct a KWListIter that will reference the ith item. @param i The index of the item to be referenced */ public MyListIterator(int i) { // Validate i parameter. if (i < 0 || i > size) { throw new IndexOutOfBoundsException(\"Invalid index \" + i); } lastItemReturned = null; // No item returned yet. // Special case of last item. if (i == size) { index = size; nextItem = null; } else { // Start at the beginning nextItem = head; for (index = 0; index < i; index++) { nextItem = nextItem.next; } } } /** Indicate whether movement forward is defined. @return true if call to next will not throw an exception */ public boolean hasNext() { return nextItem != null; } /** Move the iterator forward and return the next item. @return The next item in the list @throws NoSuchElementException if there is no such object */ public E next() { if (!hasNext()) { throw new NoSuchElementException(); } lastItemReturned = nextItem; nextItem = nextItem.next; index++; return lastItemReturned.data; } /** Indicate whether movement backward is defined. @return true if call to previous will not throw an exception */ public boolean hasPrevious() { return (nextItem == null && size != 0) || nextItem.prev != null; } /** Move the iterator backward and return the previous item. @return The previous item in the list @throws NoSuchElementException if there is no such object */ public E previous() { if (!hasPrevious()) { throw new NoSuchElementException(); } if (nextItem == null) { // Iterator is past the last element nextItem = tail; } else { nextItem = nextItem.prev; } lastItemReturned = nextItem; index--; return lastItemReturned.data; } /** * Returns the index of the element that would be returned by a subsequent call to next(). * * @return the index of the element that would be returned by a subsequent call to next(), * or the size of the list if there is no next element */ @Override public int nextIndex() { return (hasNext()) ? index : size; } /** * Returns the index of the element that would be returned by a subsequent call to previous(). * * @return the index of the element that would be returned by a subsequent call to previous(), * or -1 if there is no previous element */ @Override public int previousIndex() { return (hasPrevious()) ? index - 1 : -1; } /** * Removes from the list the last element that was returned by next() or previous(). * * This method has not been verified! * * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void remove() { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to remove\"); } Node<E> lastNext = lastItemReturned.next; Node<E> lastPrev = lastItemReturned.prev; if (lastPrev == null) { // Removing first element head = lastNext; } else { lastPrev.next = lastNext; lastItemReturned.prev = null; } if (lastNext == null) { // Removing last element tail = lastPrev; } else { lastNext.prev = lastPrev; lastItemReturned.next = null; } if (nextItem == lastItemReturned) { nextItem = lastNext; } else { index--; } lastItemReturned.data = null; lastItemReturned = null; size--; } /** * Replaces the last element returned by next() or previous() with the specified element. * * @param e the element with which to replace the last returned element * @throws IllegalStateException if no element has been previously returned by next() or previous() */ @Override public void set(E e) { if (lastItemReturned == null) { throw new IllegalStateException(\"No element to set\"); } lastItemReturned.data = e; } /** Add a new item between the item that will be returned by next and the item that will be returned by previous. If previous is called after add, the element added is returned. @param obj The item to be inserted */ public void add(E obj) { if (head == null) { // Add to an empty list. head = new Node<>(obj); tail = head; } else if (nextItem == head) { // Insert at head // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to the nextItem. newNode.next = nextItem; // Link nextItem to the new node. nextItem.prev = newNode; // The new node is now the head. head = newNode; } else if(nextItem == null){ // Insert at tail // Create a new node. Node<E> newNode = new Node<>(obj); // Link the tail to the new node. tail.next = newNode; // Link the new node to the tail. newNode.prev = tail; // The new node is the new tail. tail = newNode; } else { // Insert into the middle. // Create a new node. Node<E> newNode = new Node<>(obj); // Link it to nextItem.prev. newNode.prev = nextItem.prev; nextItem.prev.next = newNode; // Link it to the nextItem. newNode.next = nextItem; nextItem.prev = newNode; } // Increase size and index and set lastItemReturned. size++; index++; lastItemReturned = null; } // End of method add. } // Data Fields /** A reference to the head of the list. */ private Node<E> head = null; /** A reference to the end of the list. */ private Node<E> tail = null; /** The size of the list. */ private int size = 0; /** Add an item at position index. @param index The position at which the object is to be inserted @param obj The object to be inserted @throws IndexOutOfBoundsException if the index is out of range (i < 0 || i > size()) */ public void add(int index, E obj) { listIterator(index).add(obj); } @Override public ListIterator<E> listIterator(int i) { return new MyListIterator(i); } /** Get the element at position index. @param index Position of item to be retrieved @return The item at index */ public E get(int index) { return listIterator(index).next(); } /** * Return the number of elements in this list. * @return The number of elements in this list. */ @Override public int size() { return size; } }","title":"Data Fields for Class MyLinkedList&lt;E&gt; (Double-Linked List)"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#extra_3","text":"","title":"Extra"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#inner-classes-static-and-nonstatic","text":"There are two inner classes in class LinkedList\\ : class Node and class MyListIterator. We declare Node\\ to be static because there is no need for its methods to access the data fields of its parent class (LinkedList\\ ). We can\u2019t declare MyListIterator to be static because its methods access and modify the data fields of the LinkedList object that creates the MyListIterator object. An inner class that is not static contains an implicit reference to its parent object, just as it contains an implicit reference to itself. Because MyListIterator is not static and can reference data fields of its parent class LinkedList\\ , the type parameter is considered to be previously defined; therefore, it cannot appear as part of the class name.","title":"Inner Classes: Static and Nonstatic"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#pitfall_1","text":"Defining MyListIterator as a Generic Inner Class If you define class MyListIterator as private class MyListIterator ... you will get an incompatible types syntax error when you attempt to reference data field head or tail (type Node\\ ) inside class MyListIterator.","title":"PITFALL"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#8-circular-linked-list","text":"","title":"8. Circular Linked List"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#overview_8","text":"Circularly Linked Lists: Linked lists are traditionally viewed as storing a sequence of items in a linear order, from first to last. However, there are many applications in which data can be more naturally viewed as having a cyclic order, with well-defined neighboring relationships, but no fixed beginning or end. Example Application: Round-Robin Scheduling A process is given a short turn to execute, known as a time slice, but it is interrupted when the slice ends, even if its job is not yet complete. Each active process is given its own time slice, taking turns in a cyclic order.","title":"Overview"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#class-circularlylinkedliste","text":"","title":"Class CircularlyLinkedList&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#data-fields","text":"Data Field Attribute private Node tail A reference to the last item in the list private int size A count of the number of items in the list","title":"Data Fields"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#method-summary_1","text":"Modifier and Type Method Description void addFirst(E e) Inserts the specified element at the beginning of this list. void addLast(E e) Appends the specified element to the end of this list. E getFirst() Returns the first element in this list. E getLast() Returns the last element in this list. void rotate() Rotates the first element to the back of the list. E removeFirst() Removes and returns the first element from this list.","title":"Method Summary"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#implementation_3","text":"public class CircularLinkedList<E> { // Nested node class identical to that of the SinglyLinkedList class private static class Node<E> { private E element; private Node<E> next; public Node(E e, Node<E> n) { element = e; next = n; } public E getElement() { return element; } public Node<E> getNext() { return next; } public void setNext(Node<E> n) { next = n; } } private Node<E> tail = null; // We store tail (but not head) private int size = 0; // Number of nodes in the list public CircularLinkedList() { } // Constructs an initially empty list // Access methods public int size() { return size; } public boolean isEmpty() { return size == 0; } public E getFirst() { // Returns (but does not remove) the first element if (isEmpty()) return null; return tail.getNext().getElement(); // The head is *after* the tail } public E getLast() { // Returns (but does not remove) the last element if (isEmpty()) return null; return tail.getElement(); } // Update methods public void rotate() { // Rotate the first element to the back of the list if (tail != null) // If empty, do nothing tail = tail.getNext(); // The old head becomes the new tail } public void addFirst(E e) { // Adds element e to the front of the list if (size == 0) { tail = new Node<>(e, null); tail.setNext(tail); // Link to itself circularly } else { Node<E> newest = new Node<>(e, tail.getNext()); tail.setNext(newest); } size++; } public void addLast(E e) { // Adds element e to the end of the list addFirst(e); // Insert new element at front of list tail = tail.getNext(); // Now new element becomes the tail } public E removeFirst() { // Removes and returns the first element if (isEmpty()) return null; // Nothing to remove Node<E> head = tail.getNext(); if (head == tail) tail = null; // Must be the only node left else tail.setNext(head.getNext()); // Removes \u201dhead\u201d from the list size--; return head.getElement(); } } TODO: The implementations of some methods are missing and should be fixed in the future.","title":"Implementation"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#performance_4","text":"Operations/Complexity Big O addFirst(E e) O(1) addLast(E e) O(1) getFirst() O(1) getLast() O(1) rotate() O(1) removeFirst() O(1)","title":"Performance"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#9-the-collections-framework-design","text":"","title":"9. The Collections Framework Design"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#the-collection-interface","text":"The Collection interface specifies a subset of the methods specified in the List interface. Specifically, the add(int, E), get(int), remove(int), set(int, E), and related methods (all of which have an int parameter that represents a position) are not in the Collection interface, but the add(E) and remove(Object) methods, which do not specify a position, are included. The iterator method is also included in the Collection interface. Thus, you can use an Iterator to access all of the items in a Collection , but the order in which they are retrieved is not necessarily related to the order in which they were inserted The Collection interface is part of the Collections Framework. This interface has three subinterfaces: the List interface, the Queue interface, and the Set interface. The Java API does not provide any direct implementation of the Collection interface. The interface is used to reference collections of data in the most general way.","title":"The Collection Interface"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#common-features-of-collections","text":"A few features can be considered fundamental: Collections grow as needed. Collections hold references to objects. Collections have at least two constructors: one to create an empty collection and one to make a copy of another collection. For collections implementing the List interface, the order of the elements is determined by the index of the elements. In the more general Collection, the order is not specified.","title":"Common Features of Collections"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#interface-javautilcollectione","text":"Modifier and Type Method and Description boolean add(E e) Ensures that this collection contains the specified element (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this collection (optional operation). void clear() Removes all of the elements from this collection (optional operation). boolean contains(Object o) Returns true if this collection contains the specified element. boolean containsAll(Collection<?> c) Returns true if this collection contains all of the elements in the specified collection. boolean equals(Object o) Compares the specified object with this collection for equality. boolean isEmpty() Returns true if this collection contains no elements. Iterator iterator() Returns an iterator over the elements in this collection. boolean remove(Object o) Removes a single instance of the specified element from this collection, if it is present (optional operation). boolean removeAll(Collection<?> c) Removes all of this collection's elements that are also contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this collection that are contained in the specified collection (optional operation). int size() Returns the number of elements in this collection. Object[] toArray() Returns an array containing all of the elements in this collection.","title":"Interface java.util.Collection&lt;E&gt;"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#the-abstractcollection-abstractlist-and-abstractsequentiallist-classes","text":"If you look at the Java API documentation, you will see that the Collection and List interfaces specify a large number of methods. To help implement these interfaces, the Java API includes the AbstractCollection and AbstractList classes. You can think of these classes as a kit that can be used to build implementations of their corresponding interface. Most of the methods are provided, but you need to add a few to make it complete. To implement the Collection interface completely, you need only extend the AbstractCollection class, provide an implementation of the add, size, and iterator methods, and supply an inner class to implement the Iterator interface. To implement the List interface, you can extend the AbstractList class and provide an implementation of the add(int, E), get(int), remove(int), set(int, E), and size() methods. Since we provided these methods in our ArrayList , we can make it a complete implementation of the List interface by changing the class declaration to java public class ArrayList<E> extends AbstractList<E> implements List<E> Note that the AbstractList class implements the iterator and listIterator methods using the index associated with the elements. Another way to implement the List interface is to extend the AbstractSequentialList class, implement the listIterator and size methods, and provide an inner class that implements the ListIterator interface. This was the approach we took in our LinkedList . Thus, by changing the class declaration to java public class LinkedList<E> extends AbstractSequentialList<E> implements List<E> it becomes a complete implementation of the List interface. Our LinkedList class included the add, get, remove, and set methods. These are provided by the AbstractSequentialList , so we could remove them from our LinkedList class and still have a complete List implementation.","title":"The AbstractCollection, AbstractList, and AbstractSequentialList Classes"},{"location":"data-structures/chp1-lists-and-the-collections-framework/chp1-lists-and-the-collections-framework.html#the-list-and-randomaccess-interface","text":"The RandomAccess interface is applied only to those implementations in which indexed operations are efficient (e.g., ArrayList). An algorithm can then test to see if a parameter of type List is also of type RandomAccess and, if not, copy its contents into an ArrayList temporarily so that the indexed operations can proceed more efficiently. After the indexed operations are completed, the contents of the ArrayList are copied back to the original.","title":"The List and RandomAccess Interface"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html","text":"1. Stack Overview A stack is a data structure with the property that only the top element of the stack is accessible. In a stack, the top element is the data value that was most recently stored in the stack. Sometimes this storage policy is known as last-in, first-out, or LIFO. Stack ADT Modifier and Type Method Description boolean empty() Tests if this stack is empty. E peek() Looks at the object at the top of this stack without removing it from the stack. E pop() Removes the object at the top of this stack and returns that object as the value of this function. E push(E item) Pushes an item onto the top of this stack. Class java.util.Stack<E> The java.util.Stack class is part of the original Java API but is not recommended for new applications. Instead, the Java designers recommend that we use the java.util.Deque interface and the java.util.ArrayDeque class to provide the methods listed above. The Deque interface specifies the methods in our interface StackInt (see Table) and also those needed for a queue. We will discuss the Deque interface and class ArrayDeque later. Our Interface Stack<E> /** * A collection of objects that are inserted and removed according to the last-in * first-out principle. Although similar in purpose, this interface differs from * java.util.Stack. */ public interface Stack<E> { /** * Returns the number of elements in the stack. * * @return number of elements in the stack */ int size(); /** * Tests whether the stack is empty. * * @return true if the stack is empty, false otherwise */ boolean empty(); /** * Inserts an element at the top of the stack. * * @param e the element to be inserted */ void push(E e); /** * Returns, but does not remove, the element at the top of the stack. * * @return top element in the stack (or null if empty) */ E top(); /** * Removes and returns the top element from the stack. * * @return element removed (or null if empty) */ E pop(); } Performance Operations Big O (Worst-case Complexity) empty() O(1) peek() O(1) pop() O(1) push(E item) O(1) Implementation We are going to cover two ways of implementing a Stack: Array (or ArrayList can also be adapted) LinkedList Array-Based Stack Implementation The following class implements generic Stack<E> interface. Implementation public class ArrayStack<E> implements Stack<E> { public static final int INITIAL_CAPACITY = 10; // Default array capacity private E[] data; // Generic array used for storage private int top = -1; // Index of the top element in the stack private int capacity; public ArrayStack() { this(INITIAL_CAPACITY); // Constructs stack with default capacity } public ArrayStack(int capacity) { // Constructs stack with given capacity this.capacity = capacity; data = (E[]) new Object[capacity]; // Safe cast; compiler may give warning } public int size() { return (top + 1); } public boolean empty() { return (top == -1); } public void push(E e) throws IllegalStateException { if (size() == data.length) { reallocate(); } data[++top] = e; // Increment t before storing the new item } public E top() { if (empty()) return null; return data[top]; } public E pop() { if (empty()) return null; E answer = data[top]; data[top] = null; // Dereference to help garbage collection top--; return answer; } private void reallocate(){ capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } } **Drawbacks of Array-Based Implementation ** Fixed-capacity array If the application needs much less space than the reserved capacity, memory is wasted . Performance of a stack realized by an array. The space usage is O(N) , where N is the size of the array, determined at the time the stack is instantiated, and independent from the number n \\leq N of elements that are actually in the stack. When the stack has reached the capacity, it will refuse storing a new element throwing IllegalStateException . This problem can be fixed by using ArrayList as adapter instead of implementation from scratch using Array . Singly-Linked List-Based Stack Implementation import java.util.LinkedList; public class LinkedStack<E> implements Stack<E> { private LinkedList<E> list = new LinkedList<>(); // An empty list public LinkedStack() { } // New stack relies on the initially empty list public int size() { return list.size(); } public boolean empty() { return list.isEmpty(); } public void push(E element) { list.addFirst(element); } public E top() { return list.getFirst(); } public E pop() { return list.removeFirst(); } } Extra The Adapter Pattern The adapter design pattern applies to any context where we effectively want to modify an existing class so that its methods match those of a related, but different, class or interface. One general way to apply the adapter pattern is to define a new class in such a way that it contains an instance of the existing class as a hidden field, and then to implement each method of the new class using methods of this hidden instance variable. By applying the adapter pattern in this way, we have created a new class that performs some of the same functions as an existing class, but repackaged in a more convenient way. Comparisons of Stack Implementations As we discussed before, in array-based implementation If the application needs much less space than the reserved capacity, memory is wasted . Whereas a linked list based implementation has the advantage of using exactly as much storage as needed for the stack. However, also note that since a linked-list node stores 2 data field references for the previous and next node references and 1 data field for stored data element, a linked-list based implementation of the full size is 3 times more expensive in terms of memory than a full array-based stack.","title":"Stacks"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#1-stack","text":"","title":"1. Stack"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#overview","text":"A stack is a data structure with the property that only the top element of the stack is accessible. In a stack, the top element is the data value that was most recently stored in the stack. Sometimes this storage policy is known as last-in, first-out, or LIFO.","title":"Overview"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#stack-adt","text":"Modifier and Type Method Description boolean empty() Tests if this stack is empty. E peek() Looks at the object at the top of this stack without removing it from the stack. E pop() Removes the object at the top of this stack and returns that object as the value of this function. E push(E item) Pushes an item onto the top of this stack.","title":"Stack ADT"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#class-javautilstacke","text":"The java.util.Stack class is part of the original Java API but is not recommended for new applications. Instead, the Java designers recommend that we use the java.util.Deque interface and the java.util.ArrayDeque class to provide the methods listed above. The Deque interface specifies the methods in our interface StackInt (see Table) and also those needed for a queue. We will discuss the Deque interface and class ArrayDeque later.","title":"Class java.util.Stack&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#our-interface-stacke","text":"/** * A collection of objects that are inserted and removed according to the last-in * first-out principle. Although similar in purpose, this interface differs from * java.util.Stack. */ public interface Stack<E> { /** * Returns the number of elements in the stack. * * @return number of elements in the stack */ int size(); /** * Tests whether the stack is empty. * * @return true if the stack is empty, false otherwise */ boolean empty(); /** * Inserts an element at the top of the stack. * * @param e the element to be inserted */ void push(E e); /** * Returns, but does not remove, the element at the top of the stack. * * @return top element in the stack (or null if empty) */ E top(); /** * Removes and returns the top element from the stack. * * @return element removed (or null if empty) */ E pop(); }","title":"Our Interface Stack&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#performance","text":"Operations Big O (Worst-case Complexity) empty() O(1) peek() O(1) pop() O(1) push(E item) O(1)","title":"Performance"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#implementation","text":"We are going to cover two ways of implementing a Stack: Array (or ArrayList can also be adapted) LinkedList","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#array-based-stack-implementation","text":"The following class implements generic Stack<E> interface.","title":"Array-Based Stack Implementation"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#implementation_1","text":"public class ArrayStack<E> implements Stack<E> { public static final int INITIAL_CAPACITY = 10; // Default array capacity private E[] data; // Generic array used for storage private int top = -1; // Index of the top element in the stack private int capacity; public ArrayStack() { this(INITIAL_CAPACITY); // Constructs stack with default capacity } public ArrayStack(int capacity) { // Constructs stack with given capacity this.capacity = capacity; data = (E[]) new Object[capacity]; // Safe cast; compiler may give warning } public int size() { return (top + 1); } public boolean empty() { return (top == -1); } public void push(E e) throws IllegalStateException { if (size() == data.length) { reallocate(); } data[++top] = e; // Increment t before storing the new item } public E top() { if (empty()) return null; return data[top]; } public E pop() { if (empty()) return null; E answer = data[top]; data[top] = null; // Dereference to help garbage collection top--; return answer; } private void reallocate(){ capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } } **Drawbacks of Array-Based Implementation ** Fixed-capacity array If the application needs much less space than the reserved capacity, memory is wasted . Performance of a stack realized by an array. The space usage is O(N) , where N is the size of the array, determined at the time the stack is instantiated, and independent from the number n \\leq N of elements that are actually in the stack. When the stack has reached the capacity, it will refuse storing a new element throwing IllegalStateException . This problem can be fixed by using ArrayList as adapter instead of implementation from scratch using Array .","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#singly-linked-list-based-stack","text":"","title":"Singly-Linked List-Based Stack"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#implementation_2","text":"import java.util.LinkedList; public class LinkedStack<E> implements Stack<E> { private LinkedList<E> list = new LinkedList<>(); // An empty list public LinkedStack() { } // New stack relies on the initially empty list public int size() { return list.size(); } public boolean empty() { return list.isEmpty(); } public void push(E element) { list.addFirst(element); } public E top() { return list.getFirst(); } public E pop() { return list.removeFirst(); } }","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#extra","text":"","title":"Extra"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#the-adapter-pattern","text":"The adapter design pattern applies to any context where we effectively want to modify an existing class so that its methods match those of a related, but different, class or interface. One general way to apply the adapter pattern is to define a new class in such a way that it contains an instance of the existing class as a hidden field, and then to implement each method of the new class using methods of this hidden instance variable. By applying the adapter pattern in this way, we have created a new class that performs some of the same functions as an existing class, but repackaged in a more convenient way.","title":"The Adapter Pattern"},{"location":"data-structures/chp2-stacks-and-queues/2-1-stacks.html#comparisons-of-stack-implementations","text":"As we discussed before, in array-based implementation If the application needs much less space than the reserved capacity, memory is wasted . Whereas a linked list based implementation has the advantage of using exactly as much storage as needed for the stack. However, also note that since a linked-list node stores 2 data field references for the previous and next node references and 1 data field for stored data element, a linked-list based implementation of the full size is 3 times more expensive in terms of memory than a full array-based stack.","title":"Comparisons of Stack Implementations"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html","text":"2. Queue Overview Another fundamental data structure is the queue. It is a close \u201ccousin\u201d of the stack, but a queue is a collection of objects that are inserted and removed according to the first-in, first-out (FIFO) principle. Interface java.util.Queue<E> Modifier and Type Method Description boolean add(E e) Inserts the specified element into this queue if space is available, returning true upon success. Throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into this queue if space is available, returning true upon success. E element() Retrieves, but does not remove, the head of this queue. E peek() Retrieves, but does not remove, the head of this queue. Returns null if the queue is empty. E poll() Retrieves and removes the head of this queue. Returns null if the queue is empty. E remove() Retrieves and removes the head of this queue. Throws NoSuchElementException if the queue is empty. Implementation Circular Array-Based Queue package datastructures.queue; import java.util.AbstractQueue; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue; /** Implements the Queue interface using a circular array. */ public class ArrayQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** Index of the front of the queue. */ private int front; /** Index of the rear of the queue. */ private int rear; /** Current size of the queue. */ private int size; /** Current capacity of the queue. */ private int capacity; /** Default capacity of the queue. */ private static final int DEFAULT_CAPACITY = 10; /** Array to hold the data. */ private E[] data; // Constructors /** Construct a queue with the default initial capacity. */ public ArrayQueue() { this(DEFAULT_CAPACITY); } @SuppressWarnings(\"unchecked\") /** Construct a queue with the specified initial capacity. @param initCapacity The initial capacity */ public ArrayQueue(int initCapacity) { capacity = initCapacity; data = (E[]) new Object[capacity]; front = 0; rear = capacity-1; size = 0; } // Public Methods /** Inserts an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { if (size == capacity) { reallocate(); } size++; rear = (rear + 1) % capacity; data[rear] = item; return true; } /** Returns the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return data[front]; } /** Removes the entry at the front of the queue and returns it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful or null if not */ @Override public E poll() { if (size == 0) { return null; } E result = data[front]; front = (front + 1) % capacity; size--; return result; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } @Override public Iterator<E> iterator() { return new ArrayQueueIterator(); } @Override public int size() { return size; } // Private Methods /** Double the capacity and reallocate the data. @pre The array is filled to capacity. @post The capacity is doubled and the first half of the expanded array is filled with data. */ @SuppressWarnings(\"unchecked\") private void reallocate() { int newCapacity = 2 * capacity; E[] newData = (E[]) new Object[newCapacity]; int j = front; for (int i = 0; i < size; i++) { newData[i] = data[j]; j = (j + 1) % capacity; } front = 0; rear = size-1; capacity = newCapacity; data = newData; } /** Inner class to implement the Iterator<E> interface. */ private class ArrayQueueIterator implements Iterator<E> { // Data Fields // Index of next element private int index; // Count of elements accessed so far private int count = 0; // Methods // Constructor /** Initializes the Iter object to reference the first queue element. */ public ArrayQueueIterator() { index = front; } /** Returns true if there are more elements in the queue to access. */ @Override public boolean hasNext() { return count < size; } /** Returns the next element in the queue. @pre index references the next element to access. @post index and count are incremented. @return The element with subscript index */ @Override public E next() { if (!hasNext()) { throw new NoSuchElementException(); } E returnValue = data[index]; index = (index + 1) % capacity; count++; return returnValue; } /** Remove the item accessed by the Iter object \u2013 not implemented. */ @Override public void remove() { throw new UnsupportedOperationException(); } } } Increasing Queue Capacity When the capacity is reached, we double the capacity and copy the array into the new one, as was done for the ArrayList. However, we can\u2019t simply use the reallocate method we developed for the ArrayList because of the circular nature of the array. We can\u2019t copy over elements from the original array to the first half of the expanded array, maintaining their position. We must first copy the elements from position front through the end of the original array to the beginning of the expanded array; then copy the elements from the beginning of the original array through rear to follow those in the expanded array. Single-Linked List-Based Queue package datastructures.queue; import java.util.*; /** Implements the Queue interface using a single\u2010linked list. */ public class ListQueue<E> extends AbstractQueue<E> implements Queue<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } // Data Fields /** Reference to front of queue. */ private Node<E> front; /** Reference to rear of queue. */ private Node<E> rear; /** Size of queue. */ private int size; // Insert inner class Node<E> for single\u2010linked list here. // (See Listing 2.1.) // Methods /** Insert an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { // Check for empty queue. if (front == null) { rear = new Node<>(item); front = rear; } else { // Allocate a new node at end, store item in it, and // link it to old end of queue. rear.next = new Node<>(item); rear = rear.next; } size++; return true; } /** Remove the entry at the front of the queue and return it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful, or null if not */ @Override public E poll() { E item = peek(); // Retrieve item at front. if (item == null) return null; // Remove item at front. front = front.next; size--; return item; // Return data at front of queue. } /** Return the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return front.data; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } // Insert class Iter. @Override public Iterator<E> iterator() { return null; } @Override public int size() { return size; } } Double-Linked List-Based Queue Use java.util.LinkedList class as adapter class. public class DoubleLinkedQueue<E> extends AbstractQueue<E> implements Queue<E> { private LinkedList<E> list; // an empty list public DoubleLinkedQueue( ) { list = new LinkedList<>(); } @Override public boolean add(E e) { return list.add(e); // Appends e to the end of the list } @Override public boolean offer(E e) { return list.add(e); // Appends e to the end of the list } @Override public E remove() { return list.remove(); // Removes the element in the beginning of the list } @Override public E poll() { return list.remove(); } @Override public E element() { return list.getFirst(); } @Override public E peek() { return list.getFirst(); } @Override public Iterator<E> iterator() { return list.iterator(); } @Override public int size() { return list.size(); } } Comparing the Three Implementations As mentioned earlier, all three implementations of the Queue interface are comparable in terms of computation time. All operations are O(1) regardless of the implementation. Although reallocating an array is an O(n) operation, it is amortized over n items, so the cost per item is O(1). In terms of storage requirements, both linked\u2010list implementations require more storage because of the extra space required for links. To perform an analysis of the storage requirements, you need to know that Java stores a reference to the data for a queue element in each node in addition to the links. Therefore, each node for a single\u2010linked list would store a total of two references (one for the data and one for the link), a node for a double\u2010linked list would store a total of three references, and a node for a circular array would store just one reference. Therefore, a double-linked list would require 1.5 times the storage required for a single\u2010linked list with the same number of elements. A circular array that is filled to capacity would require half the storage of a single\u2010linked list to store the same number of elements. However, if the array were just reallocated, half the array would be empty, so it would require the same storage as a single\u2010linked list.","title":"Queues"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#2-queue","text":"","title":"2. Queue"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#overview","text":"Another fundamental data structure is the queue. It is a close \u201ccousin\u201d of the stack, but a queue is a collection of objects that are inserted and removed according to the first-in, first-out (FIFO) principle.","title":"Overview"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#interface-javautilqueuee","text":"Modifier and Type Method Description boolean add(E e) Inserts the specified element into this queue if space is available, returning true upon success. Throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into this queue if space is available, returning true upon success. E element() Retrieves, but does not remove, the head of this queue. E peek() Retrieves, but does not remove, the head of this queue. Returns null if the queue is empty. E poll() Retrieves and removes the head of this queue. Returns null if the queue is empty. E remove() Retrieves and removes the head of this queue. Throws NoSuchElementException if the queue is empty.","title":"Interface java.util.Queue&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#implementation","text":"","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#circular-array-based-queue","text":"package datastructures.queue; import java.util.AbstractQueue; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue; /** Implements the Queue interface using a circular array. */ public class ArrayQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** Index of the front of the queue. */ private int front; /** Index of the rear of the queue. */ private int rear; /** Current size of the queue. */ private int size; /** Current capacity of the queue. */ private int capacity; /** Default capacity of the queue. */ private static final int DEFAULT_CAPACITY = 10; /** Array to hold the data. */ private E[] data; // Constructors /** Construct a queue with the default initial capacity. */ public ArrayQueue() { this(DEFAULT_CAPACITY); } @SuppressWarnings(\"unchecked\") /** Construct a queue with the specified initial capacity. @param initCapacity The initial capacity */ public ArrayQueue(int initCapacity) { capacity = initCapacity; data = (E[]) new Object[capacity]; front = 0; rear = capacity-1; size = 0; } // Public Methods /** Inserts an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { if (size == capacity) { reallocate(); } size++; rear = (rear + 1) % capacity; data[rear] = item; return true; } /** Returns the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return data[front]; } /** Removes the entry at the front of the queue and returns it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful or null if not */ @Override public E poll() { if (size == 0) { return null; } E result = data[front]; front = (front + 1) % capacity; size--; return result; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } @Override public Iterator<E> iterator() { return new ArrayQueueIterator(); } @Override public int size() { return size; } // Private Methods /** Double the capacity and reallocate the data. @pre The array is filled to capacity. @post The capacity is doubled and the first half of the expanded array is filled with data. */ @SuppressWarnings(\"unchecked\") private void reallocate() { int newCapacity = 2 * capacity; E[] newData = (E[]) new Object[newCapacity]; int j = front; for (int i = 0; i < size; i++) { newData[i] = data[j]; j = (j + 1) % capacity; } front = 0; rear = size-1; capacity = newCapacity; data = newData; } /** Inner class to implement the Iterator<E> interface. */ private class ArrayQueueIterator implements Iterator<E> { // Data Fields // Index of next element private int index; // Count of elements accessed so far private int count = 0; // Methods // Constructor /** Initializes the Iter object to reference the first queue element. */ public ArrayQueueIterator() { index = front; } /** Returns true if there are more elements in the queue to access. */ @Override public boolean hasNext() { return count < size; } /** Returns the next element in the queue. @pre index references the next element to access. @post index and count are incremented. @return The element with subscript index */ @Override public E next() { if (!hasNext()) { throw new NoSuchElementException(); } E returnValue = data[index]; index = (index + 1) % capacity; count++; return returnValue; } /** Remove the item accessed by the Iter object \u2013 not implemented. */ @Override public void remove() { throw new UnsupportedOperationException(); } } }","title":"Circular Array-Based Queue"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#increasing-queue-capacity","text":"When the capacity is reached, we double the capacity and copy the array into the new one, as was done for the ArrayList. However, we can\u2019t simply use the reallocate method we developed for the ArrayList because of the circular nature of the array. We can\u2019t copy over elements from the original array to the first half of the expanded array, maintaining their position. We must first copy the elements from position front through the end of the original array to the beginning of the expanded array; then copy the elements from the beginning of the original array through rear to follow those in the expanded array.","title":"Increasing Queue Capacity"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#single-linked-list-based-queue","text":"package datastructures.queue; import java.util.*; /** Implements the Queue interface using a single\u2010linked list. */ public class ListQueue<E> extends AbstractQueue<E> implements Queue<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } // Data Fields /** Reference to front of queue. */ private Node<E> front; /** Reference to rear of queue. */ private Node<E> rear; /** Size of queue. */ private int size; // Insert inner class Node<E> for single\u2010linked list here. // (See Listing 2.1.) // Methods /** Insert an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { // Check for empty queue. if (front == null) { rear = new Node<>(item); front = rear; } else { // Allocate a new node at end, store item in it, and // link it to old end of queue. rear.next = new Node<>(item); rear = rear.next; } size++; return true; } /** Remove the entry at the front of the queue and return it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful, or null if not */ @Override public E poll() { E item = peek(); // Retrieve item at front. if (item == null) return null; // Remove item at front. front = front.next; size--; return item; // Return data at front of queue. } /** Return the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return front.data; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } // Insert class Iter. @Override public Iterator<E> iterator() { return null; } @Override public int size() { return size; } }","title":"Single-Linked List-Based Queue"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#double-linked-list-based-queue","text":"Use java.util.LinkedList class as adapter class. public class DoubleLinkedQueue<E> extends AbstractQueue<E> implements Queue<E> { private LinkedList<E> list; // an empty list public DoubleLinkedQueue( ) { list = new LinkedList<>(); } @Override public boolean add(E e) { return list.add(e); // Appends e to the end of the list } @Override public boolean offer(E e) { return list.add(e); // Appends e to the end of the list } @Override public E remove() { return list.remove(); // Removes the element in the beginning of the list } @Override public E poll() { return list.remove(); } @Override public E element() { return list.getFirst(); } @Override public E peek() { return list.getFirst(); } @Override public Iterator<E> iterator() { return list.iterator(); } @Override public int size() { return list.size(); } }","title":"Double-Linked List-Based Queue"},{"location":"data-structures/chp2-stacks-and-queues/2-2-queues.html#comparing-the-three-implementations","text":"As mentioned earlier, all three implementations of the Queue interface are comparable in terms of computation time. All operations are O(1) regardless of the implementation. Although reallocating an array is an O(n) operation, it is amortized over n items, so the cost per item is O(1). In terms of storage requirements, both linked\u2010list implementations require more storage because of the extra space required for links. To perform an analysis of the storage requirements, you need to know that Java stores a reference to the data for a queue element in each node in addition to the links. Therefore, each node for a single\u2010linked list would store a total of two references (one for the data and one for the link), a node for a double\u2010linked list would store a total of three references, and a node for a circular array would store just one reference. Therefore, a double-linked list would require 1.5 times the storage required for a single\u2010linked list with the same number of elements. A circular array that is filled to capacity would require half the storage of a single\u2010linked list to store the same number of elements. However, if the array were just reallocated, half the array would be empty, so it would require the same storage as a single\u2010linked list.","title":"Comparing the Three Implementations"},{"location":"data-structures/chp2-stacks-and-queues/2-3-deques.html","text":"3. Deque Overview The name deque (pronounced \"deck\") is short for double\u2010ended queue, which means that it is a data structure that allows insertions and removals from both ends (front and rear). Interface java.util.Deque<E> Modifier and Type Method Description boolean add(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, throws IllegalStateException if no space is available. void addFirst(E e) Inserts the specified element at the front of this deque, throws IllegalStateException if no space is available. void addLast(E e) Inserts the specified element at the end of this deque, throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, returns true upon success, false if no space is available. boolean offerFirst(E e) Inserts the specified element at the front of this deque unless it would violate capacity restrictions. boolean offerLast(E e) Inserts the specified element at the end of this deque unless it would violate capacity restrictions. E poll() Retrieves and removes the head of the queue represented by this deque, returns null if this deque is empty. E pollFirst() Retrieves and removes the first element of this deque, returns null if this deque is empty. E pollLast() Retrieves and removes the last element of this deque, returns null if this deque is empty. E remove() Retrieves and removes the head of the queue represented by this deque. E removeFirst() Retrieves and removes the first element of this deque. E removeLast() Retrieves and removes the last element of this deque. E peek() Retrieves, but does not remove, the head of the queue represented by this deque, returns null if this deque is empty. E peekFirst() Retrieves, but does not remove, the first element of this deque, returns null if this deque is empty. E peekLast() Retrieves, but does not remove, the last element of this deque, returns null if this deque is empty. E element() Retrieves, but does not remove, the head of the queue represented by this deque. E getFirst() Retrieves, but does not remove, the first element of this deque. E getLast() Retrieves, but does not remove, the last element of this deque. boolean removeFirstOccurrence(Object o) Removes the first occurrence of the specified element from this deque. boolean removeLastOccurrence(Object o) Removes the last occurrence of the specified element from this deque. int size() Returns the number of elements in this deque. Iterator<E> iterator() Returns an iterator over the elements in this deque in proper sequence. Iterator<E> descendingIterator() Returns an iterator over the elements in this deque in reverse sequential order. boolean contains(Object o) Returns true if this deque contains the specified element. void push(E e) Pushes an element onto the stack represented by this deque (at the head) if space is available, throws IllegalStateException if no space is available. E pop() Pops an element from the stack represented by this deque. boolean remove(Object o) Removes the first occurrence of the specified element from this deque. Implementation The Java Collections Framework provides four implementations of the Deque interface, including ArrayDeque and LinkedList . ArrayDeque utilizes a resizable circular array like our class ArrayQueue and is the recommended implementation because, unlike LinkedList, it does not support indexed operations. Using a Deque as a Queue Using a Deque as a Stack","title":"Deques"},{"location":"data-structures/chp2-stacks-and-queues/2-3-deques.html#3-deque","text":"","title":"3. Deque"},{"location":"data-structures/chp2-stacks-and-queues/2-3-deques.html#overview","text":"The name deque (pronounced \"deck\") is short for double\u2010ended queue, which means that it is a data structure that allows insertions and removals from both ends (front and rear).","title":"Overview"},{"location":"data-structures/chp2-stacks-and-queues/2-3-deques.html#interface-javautildequee","text":"Modifier and Type Method Description boolean add(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, throws IllegalStateException if no space is available. void addFirst(E e) Inserts the specified element at the front of this deque, throws IllegalStateException if no space is available. void addLast(E e) Inserts the specified element at the end of this deque, throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, returns true upon success, false if no space is available. boolean offerFirst(E e) Inserts the specified element at the front of this deque unless it would violate capacity restrictions. boolean offerLast(E e) Inserts the specified element at the end of this deque unless it would violate capacity restrictions. E poll() Retrieves and removes the head of the queue represented by this deque, returns null if this deque is empty. E pollFirst() Retrieves and removes the first element of this deque, returns null if this deque is empty. E pollLast() Retrieves and removes the last element of this deque, returns null if this deque is empty. E remove() Retrieves and removes the head of the queue represented by this deque. E removeFirst() Retrieves and removes the first element of this deque. E removeLast() Retrieves and removes the last element of this deque. E peek() Retrieves, but does not remove, the head of the queue represented by this deque, returns null if this deque is empty. E peekFirst() Retrieves, but does not remove, the first element of this deque, returns null if this deque is empty. E peekLast() Retrieves, but does not remove, the last element of this deque, returns null if this deque is empty. E element() Retrieves, but does not remove, the head of the queue represented by this deque. E getFirst() Retrieves, but does not remove, the first element of this deque. E getLast() Retrieves, but does not remove, the last element of this deque. boolean removeFirstOccurrence(Object o) Removes the first occurrence of the specified element from this deque. boolean removeLastOccurrence(Object o) Removes the last occurrence of the specified element from this deque. int size() Returns the number of elements in this deque. Iterator<E> iterator() Returns an iterator over the elements in this deque in proper sequence. Iterator<E> descendingIterator() Returns an iterator over the elements in this deque in reverse sequential order. boolean contains(Object o) Returns true if this deque contains the specified element. void push(E e) Pushes an element onto the stack represented by this deque (at the head) if space is available, throws IllegalStateException if no space is available. E pop() Pops an element from the stack represented by this deque. boolean remove(Object o) Removes the first occurrence of the specified element from this deque.","title":"Interface java.util.Deque&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/2-3-deques.html#implementation","text":"The Java Collections Framework provides four implementations of the Deque interface, including ArrayDeque and LinkedList . ArrayDeque utilizes a resizable circular array like our class ArrayQueue and is the recommended implementation because, unlike LinkedList, it does not support indexed operations.","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/2-3-deques.html#using-a-deque-as-a-queue","text":"","title":"Using a Deque as a Queue"},{"location":"data-structures/chp2-stacks-and-queues/2-3-deques.html#using-a-deque-as-a-stack","text":"","title":"Using a Deque as a Stack"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html","text":"1. Stack Overview A stack is a data structure with the property that only the top element of the stack is accessible. In a stack, the top element is the data value that was most recently stored in the stack. Sometimes this storage policy is known as last-in, first-out, or LIFO. Stack ADT Modifier and Type Method Description boolean empty() Tests if this stack is empty. E peek() Looks at the object at the top of this stack without removing it from the stack. E pop() Removes the object at the top of this stack and returns that object as the value of this function. E push(E item) Pushes an item onto the top of this stack. Class java.util.Stack<E> The java.util.Stack class is part of the original Java API but is not recommended for new applications. Instead, the Java designers recommend that we use the java.util.Deque interface and the java.util.ArrayDeque class to provide the methods listed above. The Deque interface specifies the methods in our interface StackInt (see Table) and also those needed for a queue. We will discuss the Deque interface and class ArrayDeque later. Our Interface Stack<E> /** * A collection of objects that are inserted and removed according to the last-in * first-out principle. Although similar in purpose, this interface differs from * java.util.Stack. */ public interface Stack<E> { /** * Returns the number of elements in the stack. * * @return number of elements in the stack */ int size(); /** * Tests whether the stack is empty. * * @return true if the stack is empty, false otherwise */ boolean empty(); /** * Inserts an element at the top of the stack. * * @param e the element to be inserted */ void push(E e); /** * Returns, but does not remove, the element at the top of the stack. * * @return top element in the stack (or null if empty) */ E top(); /** * Removes and returns the top element from the stack. * * @return element removed (or null if empty) */ E pop(); } Performance Operations Big O (Worst-case Complexity) empty() O(1) peek() O(1) pop() O(1) push(E item) O(1) Implementation We are going to cover two ways of implementing a Stack: Array (or ArrayList can also be adapted) LinkedList Array-Based Stack Implementation The following class implements generic Stack<E> interface. Implementation public class ArrayStack<E> implements Stack<E> { public static final int INITIAL_CAPACITY = 10; // Default array capacity private E[] data; // Generic array used for storage private int top = -1; // Index of the top element in the stack private int capacity; public ArrayStack() { this(INITIAL_CAPACITY); // Constructs stack with default capacity } public ArrayStack(int capacity) { // Constructs stack with given capacity this.capacity = capacity; data = (E[]) new Object[capacity]; // Safe cast; compiler may give warning } public int size() { return (top + 1); } public boolean empty() { return (top == -1); } public void push(E e) throws IllegalStateException { if (size() == data.length) { reallocate(); } data[++top] = e; // Increment t before storing the new item } public E top() { if (empty()) return null; return data[top]; } public E pop() { if (empty()) return null; E answer = data[top]; data[top] = null; // Dereference to help garbage collection top--; return answer; } private void reallocate(){ capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } } **Drawbacks of Array-Based Implementation ** Fixed-capacity array If the application needs much less space than the reserved capacity, memory is wasted . Performance of a stack realized by an array. The space usage is O(N) , where N is the size of the array, determined at the time the stack is instantiated, and independent from the number n \\leq N of elements that are actually in the stack. When the stack has reached the capacity, it will refuse storing a new element throwing IllegalStateException . This problem can be fixed by using ArrayList as adapter instead of implementation from scratch using Array . Singly-Linked List-Based Stack Implementation import java.util.LinkedList; public class LinkedStack<E> implements Stack<E> { private LinkedList<E> list = new LinkedList<>(); // An empty list public LinkedStack() { } // New stack relies on the initially empty list public int size() { return list.size(); } public boolean empty() { return list.isEmpty(); } public void push(E element) { list.addFirst(element); } public E top() { return list.getFirst(); } public E pop() { return list.removeFirst(); } } Extra The Adapter Pattern The adapter design pattern applies to any context where we effectively want to modify an existing class so that its methods match those of a related, but different, class or interface. One general way to apply the adapter pattern is to define a new class in such a way that it contains an instance of the existing class as a hidden field, and then to implement each method of the new class using methods of this hidden instance variable. By applying the adapter pattern in this way, we have created a new class that performs some of the same functions as an existing class, but repackaged in a more convenient way. Comparisons of Stack Implementations As we discussed before, in array-based implementation If the application needs much less space than the reserved capacity, memory is wasted . Whereas a linked list based implementation has the advantage of using exactly as much storage as needed for the stack. However, also note that since a linked-list node stores 2 data field references for the previous and next node references and 1 data field for stored data element, a linked-list based implementation of the full size is 3 times more expensive in terms of memory than a full array-based stack. 2. Queue Overview Another fundamental data structure is the queue. It is a close \u201ccousin\u201d of the stack, but a queue is a collection of objects that are inserted and removed according to the first-in, first-out (FIFO) principle. Interface java.util.Queue<E> Modifier and Type Method Description boolean add(E e) Inserts the specified element into this queue if space is available, returning true upon success. Throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into this queue if space is available, returning true upon success. E element() Retrieves, but does not remove, the head of this queue. E peek() Retrieves, but does not remove, the head of this queue. Returns null if the queue is empty. E poll() Retrieves and removes the head of this queue. Returns null if the queue is empty. E remove() Retrieves and removes the head of this queue. Throws NoSuchElementException if the queue is empty. Implementation Circular Array-Based Queue package datastructures.queue; import java.util.AbstractQueue; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue; /** Implements the Queue interface using a circular array. */ public class ArrayQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** Index of the front of the queue. */ private int front; /** Index of the rear of the queue. */ private int rear; /** Current size of the queue. */ private int size; /** Current capacity of the queue. */ private int capacity; /** Default capacity of the queue. */ private static final int DEFAULT_CAPACITY = 10; /** Array to hold the data. */ private E[] data; // Constructors /** Construct a queue with the default initial capacity. */ public ArrayQueue() { this(DEFAULT_CAPACITY); } @SuppressWarnings(\"unchecked\") /** Construct a queue with the specified initial capacity. @param initCapacity The initial capacity */ public ArrayQueue(int initCapacity) { capacity = initCapacity; data = (E[]) new Object[capacity]; front = 0; rear = capacity-1; size = 0; } // Public Methods /** Inserts an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { if (size == capacity) { reallocate(); } size++; rear = (rear + 1) % capacity; data[rear] = item; return true; } /** Returns the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return data[front]; } /** Removes the entry at the front of the queue and returns it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful or null if not */ @Override public E poll() { if (size == 0) { return null; } E result = data[front]; front = (front + 1) % capacity; size--; return result; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } @Override public Iterator<E> iterator() { return new ArrayQueueIterator(); } @Override public int size() { return size; } // Private Methods /** Double the capacity and reallocate the data. @pre The array is filled to capacity. @post The capacity is doubled and the first half of the expanded array is filled with data. */ @SuppressWarnings(\"unchecked\") private void reallocate() { int newCapacity = 2 * capacity; E[] newData = (E[]) new Object[newCapacity]; int j = front; for (int i = 0; i < size; i++) { newData[i] = data[j]; j = (j + 1) % capacity; } front = 0; rear = size-1; capacity = newCapacity; data = newData; } /** Inner class to implement the Iterator<E> interface. */ private class ArrayQueueIterator implements Iterator<E> { // Data Fields // Index of next element private int index; // Count of elements accessed so far private int count = 0; // Methods // Constructor /** Initializes the Iter object to reference the first queue element. */ public ArrayQueueIterator() { index = front; } /** Returns true if there are more elements in the queue to access. */ @Override public boolean hasNext() { return count < size; } /** Returns the next element in the queue. @pre index references the next element to access. @post index and count are incremented. @return The element with subscript index */ @Override public E next() { if (!hasNext()) { throw new NoSuchElementException(); } E returnValue = data[index]; index = (index + 1) % capacity; count++; return returnValue; } /** Remove the item accessed by the Iter object \u2013 not implemented. */ @Override public void remove() { throw new UnsupportedOperationException(); } } } Increasing Queue Capacity When the capacity is reached, we double the capacity and copy the array into the new one, as was done for the ArrayList. However, we can\u2019t simply use the reallocate method we developed for the ArrayList because of the circular nature of the array. We can\u2019t copy over elements from the original array to the first half of the expanded array, maintaining their position. We must first copy the elements from position front through the end of the original array to the beginning of the expanded array; then copy the elements from the beginning of the original array through rear to follow those in the expanded array. Single-Linked List-Based Queue package datastructures.queue; import java.util.*; /** Implements the Queue interface using a single\u2010linked list. */ public class ListQueue<E> extends AbstractQueue<E> implements Queue<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } // Data Fields /** Reference to front of queue. */ private Node<E> front; /** Reference to rear of queue. */ private Node<E> rear; /** Size of queue. */ private int size; // Insert inner class Node<E> for single\u2010linked list here. // (See Listing 2.1.) // Methods /** Insert an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { // Check for empty queue. if (front == null) { rear = new Node<>(item); front = rear; } else { // Allocate a new node at end, store item in it, and // link it to old end of queue. rear.next = new Node<>(item); rear = rear.next; } size++; return true; } /** Remove the entry at the front of the queue and return it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful, or null if not */ @Override public E poll() { E item = peek(); // Retrieve item at front. if (item == null) return null; // Remove item at front. front = front.next; size--; return item; // Return data at front of queue. } /** Return the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return front.data; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } // Insert class Iter. @Override public Iterator<E> iterator() { return null; } @Override public int size() { return size; } } Double-Linked List-Based Queue Use java.util.LinkedList class as adapter class. public class DoubleLinkedQueue<E> extends AbstractQueue<E> implements Queue<E> { private LinkedList<E> list; // an empty list public DoubleLinkedQueue( ) { list = new LinkedList<>(); } @Override public boolean add(E e) { return list.add(e); // Appends e to the end of the list } @Override public boolean offer(E e) { return list.add(e); // Appends e to the end of the list } @Override public E remove() { return list.remove(); // Removes the element in the beginning of the list } @Override public E poll() { return list.remove(); } @Override public E element() { return list.getFirst(); } @Override public E peek() { return list.getFirst(); } @Override public Iterator<E> iterator() { return list.iterator(); } @Override public int size() { return list.size(); } } Comparing the Three Implementations As mentioned earlier, all three implementations of the Queue interface are comparable in terms of computation time. All operations are O(1) regardless of the implementation. Although reallocating an array is an O(n) operation, it is amortized over n items, so the cost per item is O(1). In terms of storage requirements, both linked\u2010list implementations require more storage because of the extra space required for links. To perform an analysis of the storage requirements, you need to know that Java stores a reference to the data for a queue element in each node in addition to the links. Therefore, each node for a single\u2010linked list would store a total of two references (one for the data and one for the link), a node for a double\u2010linked list would store a total of three references, and a node for a circular array would store just one reference. Therefore, a double-linked list would require 1.5 times the storage required for a single\u2010linked list with the same number of elements. A circular array that is filled to capacity would require half the storage of a single\u2010linked list to store the same number of elements. However, if the array were just reallocated, half the array would be empty, so it would require the same storage as a single\u2010linked list. 3. Deque Overview The name deque (pronounced \"deck\") is short for double\u2010ended queue, which means that it is a data structure that allows insertions and removals from both ends (front and rear). Interface java.util.Deque<E> Modifier and Type Method Description boolean add(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, throws IllegalStateException if no space is available. void addFirst(E e) Inserts the specified element at the front of this deque, throws IllegalStateException if no space is available. void addLast(E e) Inserts the specified element at the end of this deque, throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, returns true upon success, false if no space is available. boolean offerFirst(E e) Inserts the specified element at the front of this deque unless it would violate capacity restrictions. boolean offerLast(E e) Inserts the specified element at the end of this deque unless it would violate capacity restrictions. E poll() Retrieves and removes the head of the queue represented by this deque, returns null if this deque is empty. E pollFirst() Retrieves and removes the first element of this deque, returns null if this deque is empty. E pollLast() Retrieves and removes the last element of this deque, returns null if this deque is empty. E remove() Retrieves and removes the head of the queue represented by this deque. E removeFirst() Retrieves and removes the first element of this deque. E removeLast() Retrieves and removes the last element of this deque. E peek() Retrieves, but does not remove, the head of the queue represented by this deque, returns null if this deque is empty. E peekFirst() Retrieves, but does not remove, the first element of this deque, returns null if this deque is empty. E peekLast() Retrieves, but does not remove, the last element of this deque, returns null if this deque is empty. E element() Retrieves, but does not remove, the head of the queue represented by this deque. E getFirst() Retrieves, but does not remove, the first element of this deque. E getLast() Retrieves, but does not remove, the last element of this deque. boolean removeFirstOccurrence(Object o) Removes the first occurrence of the specified element from this deque. boolean removeLastOccurrence(Object o) Removes the last occurrence of the specified element from this deque. int size() Returns the number of elements in this deque. Iterator<E> iterator() Returns an iterator over the elements in this deque in proper sequence. Iterator<E> descendingIterator() Returns an iterator over the elements in this deque in reverse sequential order. boolean contains(Object o) Returns true if this deque contains the specified element. void push(E e) Pushes an element onto the stack represented by this deque (at the head) if space is available, throws IllegalStateException if no space is available. E pop() Pops an element from the stack represented by this deque. boolean remove(Object o) Removes the first occurrence of the specified element from this deque. Implementation The Java Collections Framework provides four implementations of the Deque interface, including ArrayDeque and LinkedList . ArrayDeque utilizes a resizable circular array like our class ArrayQueue and is the recommended implementation because, unlike LinkedList, it does not support indexed operations. Using a Deque as a Queue Using a Deque as a Stack","title":"1. Stack"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#1-stack","text":"","title":"1. Stack"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#overview","text":"A stack is a data structure with the property that only the top element of the stack is accessible. In a stack, the top element is the data value that was most recently stored in the stack. Sometimes this storage policy is known as last-in, first-out, or LIFO.","title":"Overview"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#stack-adt","text":"Modifier and Type Method Description boolean empty() Tests if this stack is empty. E peek() Looks at the object at the top of this stack without removing it from the stack. E pop() Removes the object at the top of this stack and returns that object as the value of this function. E push(E item) Pushes an item onto the top of this stack.","title":"Stack ADT"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#class-javautilstacke","text":"The java.util.Stack class is part of the original Java API but is not recommended for new applications. Instead, the Java designers recommend that we use the java.util.Deque interface and the java.util.ArrayDeque class to provide the methods listed above. The Deque interface specifies the methods in our interface StackInt (see Table) and also those needed for a queue. We will discuss the Deque interface and class ArrayDeque later.","title":"Class java.util.Stack&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#our-interface-stacke","text":"/** * A collection of objects that are inserted and removed according to the last-in * first-out principle. Although similar in purpose, this interface differs from * java.util.Stack. */ public interface Stack<E> { /** * Returns the number of elements in the stack. * * @return number of elements in the stack */ int size(); /** * Tests whether the stack is empty. * * @return true if the stack is empty, false otherwise */ boolean empty(); /** * Inserts an element at the top of the stack. * * @param e the element to be inserted */ void push(E e); /** * Returns, but does not remove, the element at the top of the stack. * * @return top element in the stack (or null if empty) */ E top(); /** * Removes and returns the top element from the stack. * * @return element removed (or null if empty) */ E pop(); }","title":"Our Interface Stack&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#performance","text":"Operations Big O (Worst-case Complexity) empty() O(1) peek() O(1) pop() O(1) push(E item) O(1)","title":"Performance"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#implementation","text":"We are going to cover two ways of implementing a Stack: Array (or ArrayList can also be adapted) LinkedList","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#array-based-stack-implementation","text":"The following class implements generic Stack<E> interface.","title":"Array-Based Stack Implementation"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#implementation_1","text":"public class ArrayStack<E> implements Stack<E> { public static final int INITIAL_CAPACITY = 10; // Default array capacity private E[] data; // Generic array used for storage private int top = -1; // Index of the top element in the stack private int capacity; public ArrayStack() { this(INITIAL_CAPACITY); // Constructs stack with default capacity } public ArrayStack(int capacity) { // Constructs stack with given capacity this.capacity = capacity; data = (E[]) new Object[capacity]; // Safe cast; compiler may give warning } public int size() { return (top + 1); } public boolean empty() { return (top == -1); } public void push(E e) throws IllegalStateException { if (size() == data.length) { reallocate(); } data[++top] = e; // Increment t before storing the new item } public E top() { if (empty()) return null; return data[top]; } public E pop() { if (empty()) return null; E answer = data[top]; data[top] = null; // Dereference to help garbage collection top--; return answer; } private void reallocate(){ capacity = 2 * capacity; data = Arrays.copyOf(data, capacity); } } **Drawbacks of Array-Based Implementation ** Fixed-capacity array If the application needs much less space than the reserved capacity, memory is wasted . Performance of a stack realized by an array. The space usage is O(N) , where N is the size of the array, determined at the time the stack is instantiated, and independent from the number n \\leq N of elements that are actually in the stack. When the stack has reached the capacity, it will refuse storing a new element throwing IllegalStateException . This problem can be fixed by using ArrayList as adapter instead of implementation from scratch using Array .","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#singly-linked-list-based-stack","text":"","title":"Singly-Linked List-Based Stack"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#implementation_2","text":"import java.util.LinkedList; public class LinkedStack<E> implements Stack<E> { private LinkedList<E> list = new LinkedList<>(); // An empty list public LinkedStack() { } // New stack relies on the initially empty list public int size() { return list.size(); } public boolean empty() { return list.isEmpty(); } public void push(E element) { list.addFirst(element); } public E top() { return list.getFirst(); } public E pop() { return list.removeFirst(); } }","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#extra","text":"","title":"Extra"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#the-adapter-pattern","text":"The adapter design pattern applies to any context where we effectively want to modify an existing class so that its methods match those of a related, but different, class or interface. One general way to apply the adapter pattern is to define a new class in such a way that it contains an instance of the existing class as a hidden field, and then to implement each method of the new class using methods of this hidden instance variable. By applying the adapter pattern in this way, we have created a new class that performs some of the same functions as an existing class, but repackaged in a more convenient way.","title":"The Adapter Pattern"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#comparisons-of-stack-implementations","text":"As we discussed before, in array-based implementation If the application needs much less space than the reserved capacity, memory is wasted . Whereas a linked list based implementation has the advantage of using exactly as much storage as needed for the stack. However, also note that since a linked-list node stores 2 data field references for the previous and next node references and 1 data field for stored data element, a linked-list based implementation of the full size is 3 times more expensive in terms of memory than a full array-based stack.","title":"Comparisons of Stack Implementations"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#2-queue","text":"","title":"2. Queue"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#overview_1","text":"Another fundamental data structure is the queue. It is a close \u201ccousin\u201d of the stack, but a queue is a collection of objects that are inserted and removed according to the first-in, first-out (FIFO) principle.","title":"Overview"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#interface-javautilqueuee","text":"Modifier and Type Method Description boolean add(E e) Inserts the specified element into this queue if space is available, returning true upon success. Throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into this queue if space is available, returning true upon success. E element() Retrieves, but does not remove, the head of this queue. E peek() Retrieves, but does not remove, the head of this queue. Returns null if the queue is empty. E poll() Retrieves and removes the head of this queue. Returns null if the queue is empty. E remove() Retrieves and removes the head of this queue. Throws NoSuchElementException if the queue is empty.","title":"Interface java.util.Queue&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#implementation_3","text":"","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#circular-array-based-queue","text":"package datastructures.queue; import java.util.AbstractQueue; import java.util.Iterator; import java.util.NoSuchElementException; import java.util.Queue; /** Implements the Queue interface using a circular array. */ public class ArrayQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** Index of the front of the queue. */ private int front; /** Index of the rear of the queue. */ private int rear; /** Current size of the queue. */ private int size; /** Current capacity of the queue. */ private int capacity; /** Default capacity of the queue. */ private static final int DEFAULT_CAPACITY = 10; /** Array to hold the data. */ private E[] data; // Constructors /** Construct a queue with the default initial capacity. */ public ArrayQueue() { this(DEFAULT_CAPACITY); } @SuppressWarnings(\"unchecked\") /** Construct a queue with the specified initial capacity. @param initCapacity The initial capacity */ public ArrayQueue(int initCapacity) { capacity = initCapacity; data = (E[]) new Object[capacity]; front = 0; rear = capacity-1; size = 0; } // Public Methods /** Inserts an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { if (size == capacity) { reallocate(); } size++; rear = (rear + 1) % capacity; data[rear] = item; return true; } /** Returns the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return data[front]; } /** Removes the entry at the front of the queue and returns it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful or null if not */ @Override public E poll() { if (size == 0) { return null; } E result = data[front]; front = (front + 1) % capacity; size--; return result; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } @Override public Iterator<E> iterator() { return new ArrayQueueIterator(); } @Override public int size() { return size; } // Private Methods /** Double the capacity and reallocate the data. @pre The array is filled to capacity. @post The capacity is doubled and the first half of the expanded array is filled with data. */ @SuppressWarnings(\"unchecked\") private void reallocate() { int newCapacity = 2 * capacity; E[] newData = (E[]) new Object[newCapacity]; int j = front; for (int i = 0; i < size; i++) { newData[i] = data[j]; j = (j + 1) % capacity; } front = 0; rear = size-1; capacity = newCapacity; data = newData; } /** Inner class to implement the Iterator<E> interface. */ private class ArrayQueueIterator implements Iterator<E> { // Data Fields // Index of next element private int index; // Count of elements accessed so far private int count = 0; // Methods // Constructor /** Initializes the Iter object to reference the first queue element. */ public ArrayQueueIterator() { index = front; } /** Returns true if there are more elements in the queue to access. */ @Override public boolean hasNext() { return count < size; } /** Returns the next element in the queue. @pre index references the next element to access. @post index and count are incremented. @return The element with subscript index */ @Override public E next() { if (!hasNext()) { throw new NoSuchElementException(); } E returnValue = data[index]; index = (index + 1) % capacity; count++; return returnValue; } /** Remove the item accessed by the Iter object \u2013 not implemented. */ @Override public void remove() { throw new UnsupportedOperationException(); } } }","title":"Circular Array-Based Queue"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#increasing-queue-capacity","text":"When the capacity is reached, we double the capacity and copy the array into the new one, as was done for the ArrayList. However, we can\u2019t simply use the reallocate method we developed for the ArrayList because of the circular nature of the array. We can\u2019t copy over elements from the original array to the first half of the expanded array, maintaining their position. We must first copy the elements from position front through the end of the original array to the beginning of the expanded array; then copy the elements from the beginning of the original array through rear to follow those in the expanded array.","title":"Increasing Queue Capacity"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#single-linked-list-based-queue","text":"package datastructures.queue; import java.util.*; /** Implements the Queue interface using a single\u2010linked list. */ public class ListQueue<E> extends AbstractQueue<E> implements Queue<E> { /** A Node is the building block for a single\u2010linked list. */ private static class Node<E> { // Data Fields /** The reference to the data. */ private E data; /** The reference to the next node. */ private Node<E> next; // Constructors /** Creates a new node with a null next field. @param dataItem The data stored */ private Node(E dataItem) { data = dataItem; next = null; } /** Creates a new node that references another node. @param dataItem The data stored @param nodeRef The node referenced by new node */ private Node(E dataItem, Node<E> nodeRef) { data = dataItem; next = nodeRef; } } // Data Fields /** Reference to front of queue. */ private Node<E> front; /** Reference to rear of queue. */ private Node<E> rear; /** Size of queue. */ private int size; // Insert inner class Node<E> for single\u2010linked list here. // (See Listing 2.1.) // Methods /** Insert an item at the rear of the queue. @post item is added to the rear of the queue. @param item The element to add @return true (always successful) */ @Override public boolean offer(E item) { // Check for empty queue. if (front == null) { rear = new Node<>(item); front = rear; } else { // Allocate a new node at end, store item in it, and // link it to old end of queue. rear.next = new Node<>(item); rear = rear.next; } size++; return true; } /** Remove the entry at the front of the queue and return it if the queue is not empty. @post front references item that was second in the queue. @return The item removed if successful, or null if not */ @Override public E poll() { E item = peek(); // Retrieve item at front. if (item == null) return null; // Remove item at front. front = front.next; size--; return item; // Return data at front of queue. } /** Return the item at the front of the queue without removing it. @return The item at the front of the queue if successful; return null if the queue is empty */ @Override public E peek() { if (size == 0) return null; else return front.data; } @Override public boolean add(E e) { return offer(e); } @Override public E element() { return peek(); } @Override public E remove() { return poll(); } // Insert class Iter. @Override public Iterator<E> iterator() { return null; } @Override public int size() { return size; } }","title":"Single-Linked List-Based Queue"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#double-linked-list-based-queue","text":"Use java.util.LinkedList class as adapter class. public class DoubleLinkedQueue<E> extends AbstractQueue<E> implements Queue<E> { private LinkedList<E> list; // an empty list public DoubleLinkedQueue( ) { list = new LinkedList<>(); } @Override public boolean add(E e) { return list.add(e); // Appends e to the end of the list } @Override public boolean offer(E e) { return list.add(e); // Appends e to the end of the list } @Override public E remove() { return list.remove(); // Removes the element in the beginning of the list } @Override public E poll() { return list.remove(); } @Override public E element() { return list.getFirst(); } @Override public E peek() { return list.getFirst(); } @Override public Iterator<E> iterator() { return list.iterator(); } @Override public int size() { return list.size(); } }","title":"Double-Linked List-Based Queue"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#comparing-the-three-implementations","text":"As mentioned earlier, all three implementations of the Queue interface are comparable in terms of computation time. All operations are O(1) regardless of the implementation. Although reallocating an array is an O(n) operation, it is amortized over n items, so the cost per item is O(1). In terms of storage requirements, both linked\u2010list implementations require more storage because of the extra space required for links. To perform an analysis of the storage requirements, you need to know that Java stores a reference to the data for a queue element in each node in addition to the links. Therefore, each node for a single\u2010linked list would store a total of two references (one for the data and one for the link), a node for a double\u2010linked list would store a total of three references, and a node for a circular array would store just one reference. Therefore, a double-linked list would require 1.5 times the storage required for a single\u2010linked list with the same number of elements. A circular array that is filled to capacity would require half the storage of a single\u2010linked list to store the same number of elements. However, if the array were just reallocated, half the array would be empty, so it would require the same storage as a single\u2010linked list.","title":"Comparing the Three Implementations"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#3-deque","text":"","title":"3. Deque"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#overview_2","text":"The name deque (pronounced \"deck\") is short for double\u2010ended queue, which means that it is a data structure that allows insertions and removals from both ends (front and rear).","title":"Overview"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#interface-javautildequee","text":"Modifier and Type Method Description boolean add(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, throws IllegalStateException if no space is available. void addFirst(E e) Inserts the specified element at the front of this deque, throws IllegalStateException if no space is available. void addLast(E e) Inserts the specified element at the end of this deque, throws IllegalStateException if no space is available. boolean offer(E e) Inserts the specified element into the queue represented by this deque (at the tail) if space is available, returns true upon success, false if no space is available. boolean offerFirst(E e) Inserts the specified element at the front of this deque unless it would violate capacity restrictions. boolean offerLast(E e) Inserts the specified element at the end of this deque unless it would violate capacity restrictions. E poll() Retrieves and removes the head of the queue represented by this deque, returns null if this deque is empty. E pollFirst() Retrieves and removes the first element of this deque, returns null if this deque is empty. E pollLast() Retrieves and removes the last element of this deque, returns null if this deque is empty. E remove() Retrieves and removes the head of the queue represented by this deque. E removeFirst() Retrieves and removes the first element of this deque. E removeLast() Retrieves and removes the last element of this deque. E peek() Retrieves, but does not remove, the head of the queue represented by this deque, returns null if this deque is empty. E peekFirst() Retrieves, but does not remove, the first element of this deque, returns null if this deque is empty. E peekLast() Retrieves, but does not remove, the last element of this deque, returns null if this deque is empty. E element() Retrieves, but does not remove, the head of the queue represented by this deque. E getFirst() Retrieves, but does not remove, the first element of this deque. E getLast() Retrieves, but does not remove, the last element of this deque. boolean removeFirstOccurrence(Object o) Removes the first occurrence of the specified element from this deque. boolean removeLastOccurrence(Object o) Removes the last occurrence of the specified element from this deque. int size() Returns the number of elements in this deque. Iterator<E> iterator() Returns an iterator over the elements in this deque in proper sequence. Iterator<E> descendingIterator() Returns an iterator over the elements in this deque in reverse sequential order. boolean contains(Object o) Returns true if this deque contains the specified element. void push(E e) Pushes an element onto the stack represented by this deque (at the head) if space is available, throws IllegalStateException if no space is available. E pop() Pops an element from the stack represented by this deque. boolean remove(Object o) Removes the first occurrence of the specified element from this deque.","title":"Interface java.util.Deque&lt;E&gt;"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#implementation_4","text":"The Java Collections Framework provides four implementations of the Deque interface, including ArrayDeque and LinkedList . ArrayDeque utilizes a resizable circular array like our class ArrayQueue and is the recommended implementation because, unlike LinkedList, it does not support indexed operations.","title":"Implementation"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#using-a-deque-as-a-queue","text":"","title":"Using a Deque as a Queue"},{"location":"data-structures/chp2-stacks-and-queues/chp2-stacks-and-queues.html#using-a-deque-as-a-stack","text":"","title":"Using a Deque as a Stack"},{"location":"data-structures/chp3-trees/chp3-trees.html","text":"5. Trees Tree Terminology root : The node at the top of a tree. It has no parents. edge (branch) : The link from a node to its successor. children : The successors of a node. parent : The predecessor of a node. siblings : The nodes that have the same parent. leaf : A node that has no children. external nodes : Leaves are also known as external nodes. internal nodes : Non-leaf nodes are also known as internal nodes. subtree of a node : A tree whose root is a child of that node. depth : The depth of a node is the length of the path from the root to the node. level : The set of all nodes at given depth is called the level of the tree. The root node is at level zero . level and depth describe the same concept but level is a tree-oriented term while depth is a node-oriented term (e.g. level of tree vs depth of node). height : The height of a node is the length of the path from that node to the deepest node. The height of a tree is the length of the path from the root to the deepest node in the tree. A (rooted) tree with only one node (the root) has a height of zero . height of the tree : The height of root node. depth of the tree : The maximum depth among all the nodes in the tree. For a given tree, height of the tree = depth of the tree . size : The size of a node is the number of descendants it has including itself. skew tree : If every node in a tree has only one child (except leaf nodes). left skew tree : If every node has only left child. right skew tree: If every node has only right child. strict binary tree : All nodes have either 2 children or 0 children (leaf nodes). full binary tree : All nodes have exactly 2 children except the leaf nodes in the final level, level n, for a tree of height n. In other words, a binary tree is full binary tree if each node has exactly two children and all leaf nodes are at the same level. complete binary tree : A complete binary tree is a full binary tree through level n -1 with some extra leaf nodes at level n and all of the nodes at level n are towards the left of the tree. Binary Trees A set of nodes T is a binary tree if either of the following is true: T is empty Else, its root node has two subtrees, T_L and T_R , such that they are binary trees. A tree is called binary tree if each node has at most two children. Observe that a binary tree has a recursive definition. Binary Search Tree A set of nodes in T is a binary search tree if either of the following is true T is empty Else, its root node has two subtrees, T_L and T_R , such that they are binary search trees and the value in the root node of T is greater than all values in T_L and is less than all values in T_R . Observe that a binary search tree has a recursive definition as well. Searching a Binary Tree if the tree is empty Return null (target is not found). else if the target matches the root node\u2019s data Return the data stored at the root node. else if the target is less than the root node\u2019s data Return the result of searching the left subtree of the root. else Return the result of searching the right subtree of the root. Just as with a binary search of an array, each probe into the binary search tree has the potential of eliminating half the elements in the tree. If the binary search tree is relatively balanced (i.e., the depths of the leaves are approximately the same), searching a binary search tree is an O(log n) process, just like a binary search of an ordered array. Tree Traversals Preorder Traversal if the tree is empty Return. else Visit the root. Preorder traverse the left subtree Preorder traverse the right subtree Inorder Traversal if the tree is empty Return. else Inorder traverse the left subtree Visit the root. Inorder traverse the right subtree Postorder Traversal if the tree is empty Return. else Postorder traverse the left subtree Postorder traverse the right subtree Visit the root. Implementing a Binary Tree Class Class BinaryTree<E> Data Field/Attribute Description protected Node<E> root Reference to the root of the tree Constructor/Behavior Description public BinaryTree() Constructs an empty binary tree protected BinaryTree(Node<E> root) Constructs a binary tree with the given node as the root public BinaryTree(E data, BinaryTree<E> leftTree, BinaryTree<E> rightTree) Constructs a binary tree with the given data at the root and the two given subtrees Method/Behavior Description public BinaryTree<E> getLeftSubtree() Returns the left subtree public BinaryTree<E> getRightSubtree() Returns the right subtree public E getData() Returns the data in the root public boolean isLeaf() Returns true if this tree is a leaf, false otherwise public String toString() Returns a String representation of the tree public void preOrderTraversal() Prints the output of preorder traversal public void inOrderTraversal() Prints the output of inorder traversal public void postOrderTraversal() Prints the output of postorder traversal package datastructures.tree; import java.io.Serializable; import java.util.Comparator; import java.util.Scanner; public class BinaryTree<E> implements Serializable{ /** Class to encapsulate a tree node. */ protected static class Node<E> implements Serializable { // Data Fields /** The information stored in this node. */ protected E data; /** Reference to the left child. */ protected Node<E> left; /** Reference to the right child. */ protected Node<E> right; // Constructors /** Construct a node with given data and no children. @param data The data to store in this node */ public Node(E data) { this.data = data; left = null; right = null; } // Methods /** Return a string representation of the node. @return A string representation of the data fields */ public String toString () { return data.toString(); } } // Data Field /** The root of the binary tree */ protected Node<E> root; // Data Fields /** Return value from the public add method. */ protected boolean addReturn; /** Return value from the public delete method. */ protected E deleteReturn; public BinaryTree() { root = null; } protected BinaryTree(Node<E> root) { this.root = root; } /** Constructs a new binary tree with data in its root leftTree as its left subtree and rightTree as its right subtree. */ public BinaryTree(E data, BinaryTree<E> leftTree, BinaryTree<E> rightTree) { root = new Node<>(data); if (leftTree != null) { root.left = leftTree.root; } else { root.left = null; } if (rightTree != null) { root.right = rightTree.root; } else { root.right = null; } } /** Return the left subtree. @return The left subtree or null if either the root or the left subtree is null */ public BinaryTree<E> getLeftSubtree() { if (root != null && root.left != null) { return new BinaryTree<>(root.left); } else { return null; } } /** Return the right subtree. @return The right subtree or null if either the root or the right subtree is null */ public BinaryTree<E> getRightSubtree() { if (root != null && root.right != null) { return new BinaryTree<>(root.right); } else { return null; } } /** Determine whether this tree is a leaf. @return true if the root has no children */ public boolean isLeaf() { return (root.left == null && root.right == null); } public String toString() { StringBuilder sb = new StringBuilder(); toString(root, 1, sb); return sb.toString(); } /** Converts a sub\u2010tree to a string. Performs a preorder traversal. @param node The local root @param depth The depth @param sb The StringBuilder to save the output */ private void toString(Node<E> node, int depth, StringBuilder sb) { for (int i = 1; i < depth; i++) { sb.append(\" \"); } if (node == null) { sb.append(\"null\\n\"); } else { sb.append(node.toString()); sb.append(\"\\n\"); toString(node.left, depth + 1, sb); toString(node.right, depth + 1, sb); } } public void preOrderTraversal(){ preOrderTraversal(root); } private void preOrderTraversal(Node<E> node){ if(node != null){ System.out.println(node.toString()); preOrderTraversal(node.left); preOrderTraversal(node.right); } } public void inOrderTraversal(){ inOrderTraversal(root); } private void inOrderTraversal(Node<E> node){ if(node != null){ inOrderTraversal(node.left); System.out.println(node.toString()); inOrderTraversal(node.right); } } public void postOrderTraversal(){ postOrderTraversal(root); } private void postOrderTraversal(Node<E> node){ if(node != null){ postOrderTraversal(node.left); postOrderTraversal(node.right); System.out.println(node.toString()); } } } Implementing a BinarySearchTree Class Interface SearchTree<E> Method Description boolean add(E item) Inserts item where it belongs in the tree. Returns true if item is inserted; false if it isn\u2019t (already in tree) boolean contains(E target) Returns true if target is found in the tree E search(E target) Returns a reference to the data in the node that is equal to target . If no such node is found, returns null E delete(E target) Removes target (if found) from the tree and returns it; otherwise, returns null boolean remove(E target) Removes target (if found) from the tree and returns true; otherwise, returns false Operations Search if the tree is empty Return null (target is not found). else if the target matches the root node\u2019s data Return the data stored at the root node. else if the target is less than the root node\u2019s data Return the result of searching the left subtree of the root. else Return the result of searching the right subtree of the root. Insert if the root is null Replace empty tree with a new tree with the item at the root and return true. else if the item is equal to root.data The item is already in the tree; return false. else if the item is less than root.data Recursively insert the item in the left subtree. else Recursively insert the item in the right subtree. Remove if the root is null The item is not in tree \u2013 return null. Compare the item to the data at the local root. if the item is less than the data at the local root Return the result of deleting from the left subtree. else if the item is greater than the local root Return the result of deleting from the right subtree. else # The item is in the local root Store the data in the local root in deleteReturn. if the local root has no children Set the parent of the local root to reference null. else if the local root has one child Set the parent of the local root to reference that child. else # Find the inorder predecessor if the left child has no right child it is the inorder predecessor Set the parent of the local root to reference the left child. else Find the rightmost node in the right subtree of the left child. Copy its data into the local root\u2019s data and remove it by setting its parent to reference its left child. Implementation package datastructures.tree; import java.util.NoSuchElementException; public class BinarySearchTree<E extends Comparable<E>> extends BinaryTree<E> implements SearchTree<E> { // Data Fields /** Return value from the public add method. */ protected boolean addReturn; /** Return value from the public delete method. */ protected E deleteReturn; /** Starter method find. pre: The target object must implement the Comparable interface. @param target The Comparable object being sought @return The object, if found, otherwise null */ public E search(E target) { return search(root, target); } /** Recursive find method. @param localRoot The local subtree's root @param target The object being sought @return The object, if found, otherwise null */ private E search(Node<E> localRoot, E target) { if (localRoot == null) return null; // Compare the target with the data field at the root. int compResult = target.compareTo(localRoot.data); if (compResult == 0) return localRoot.data; else if (compResult < 0) return search(localRoot.left, target); else return search(localRoot.right, target); } /** Starter method add. pre: The object to insert must implement the Comparable interface. @param item The object being inserted @return true if the object is inserted, false if the object already exists in the tree */ public boolean add(E item) { root = add(root, item); return addReturn; } /** Recursive add method. post: The data field addReturn is set true if the item is added to the tree, false if the item is already in the tree. @param localRoot The local root of the subtree @param item The object to be inserted @return The new local root that now contains the inserted item */ private Node<E> add(Node<E> localRoot, E item) { if (localRoot == null) { // item is not in the tree \u2014 insert it. addReturn = true; return new Node<>(item); } else if (item.compareTo(localRoot.data) == 0) { // item is equal to localRoot.data addReturn = false; return localRoot; } else if (item.compareTo(localRoot.data) < 0) { // item is less than localRoot.data localRoot.left = add(localRoot.left, item); return localRoot; } else { // item is greater than localRoot.data localRoot.right = add(localRoot.right, item); return localRoot; } } /** Starter method delete. post: The object is not in the tree. @param target The object to be deleted @return The object deleted from the tree or null if the object was not in the tree @throws ClassCastException if target does not implement Comparable */ public E delete(E target) { root = delete(root, target); return deleteReturn; } /** Recursive delete method. post: The item is not in the tree; deleteReturn is equal to the deleted item as it was stored in the tree or null if the item was not found. @param localRoot The root of the current subtree @param item The item to be deleted @return The modified local root that does not contain the item */ private Node<E> delete(Node<E> localRoot, E item) { if (localRoot == null) { // item is not in the tree. deleteReturn = null; return localRoot; } // Search for item to delete. int compResult = item.compareTo(localRoot.data); if (compResult < 0) { // item is smaller than localRoot.data. localRoot.left = delete(localRoot.left, item); } else if (compResult > 0) { // item is larger than localRoot.data. localRoot.right = delete(localRoot.right, item); } else { // item is at local root. deleteReturn = localRoot.data; if (localRoot.left == null) { // If there is no left child, return right child // which can also be null. return localRoot.right; } else if (localRoot.right == null) { // If there is no right child, return left child. return localRoot.left; } else { // Node being deleted has 2 children, replace the data with inorder predecessor. localRoot.data = getMin(localRoot.right); localRoot.right = delete(localRoot.right, localRoot.data); } } return localRoot; } private E getMin(){ if(root == null){ throw new NoSuchElementException(); } return getMin(root); } private E getMin(Node<E> localRoot){ if(localRoot.left == null){ return localRoot.data; } else{ return getMin(localRoot.left); } } @Override public boolean remove(E target) { root = delete(root, target); return deleteReturn != null; } @Override public boolean contains(E target) { return search(target) != null; } }","title":"Trees"},{"location":"data-structures/chp3-trees/chp3-trees.html#5-trees","text":"","title":"5. Trees"},{"location":"data-structures/chp3-trees/chp3-trees.html#tree-terminology","text":"root : The node at the top of a tree. It has no parents. edge (branch) : The link from a node to its successor. children : The successors of a node. parent : The predecessor of a node. siblings : The nodes that have the same parent. leaf : A node that has no children. external nodes : Leaves are also known as external nodes. internal nodes : Non-leaf nodes are also known as internal nodes. subtree of a node : A tree whose root is a child of that node. depth : The depth of a node is the length of the path from the root to the node. level : The set of all nodes at given depth is called the level of the tree. The root node is at level zero . level and depth describe the same concept but level is a tree-oriented term while depth is a node-oriented term (e.g. level of tree vs depth of node). height : The height of a node is the length of the path from that node to the deepest node. The height of a tree is the length of the path from the root to the deepest node in the tree. A (rooted) tree with only one node (the root) has a height of zero . height of the tree : The height of root node. depth of the tree : The maximum depth among all the nodes in the tree. For a given tree, height of the tree = depth of the tree . size : The size of a node is the number of descendants it has including itself. skew tree : If every node in a tree has only one child (except leaf nodes). left skew tree : If every node has only left child. right skew tree: If every node has only right child. strict binary tree : All nodes have either 2 children or 0 children (leaf nodes). full binary tree : All nodes have exactly 2 children except the leaf nodes in the final level, level n, for a tree of height n. In other words, a binary tree is full binary tree if each node has exactly two children and all leaf nodes are at the same level. complete binary tree : A complete binary tree is a full binary tree through level n -1 with some extra leaf nodes at level n and all of the nodes at level n are towards the left of the tree.","title":"Tree Terminology"},{"location":"data-structures/chp3-trees/chp3-trees.html#binary-trees","text":"A set of nodes T is a binary tree if either of the following is true: T is empty Else, its root node has two subtrees, T_L and T_R , such that they are binary trees. A tree is called binary tree if each node has at most two children. Observe that a binary tree has a recursive definition.","title":"Binary Trees"},{"location":"data-structures/chp3-trees/chp3-trees.html#binary-search-tree","text":"A set of nodes in T is a binary search tree if either of the following is true T is empty Else, its root node has two subtrees, T_L and T_R , such that they are binary search trees and the value in the root node of T is greater than all values in T_L and is less than all values in T_R . Observe that a binary search tree has a recursive definition as well.","title":"Binary Search Tree"},{"location":"data-structures/chp3-trees/chp3-trees.html#searching-a-binary-tree","text":"if the tree is empty Return null (target is not found). else if the target matches the root node\u2019s data Return the data stored at the root node. else if the target is less than the root node\u2019s data Return the result of searching the left subtree of the root. else Return the result of searching the right subtree of the root. Just as with a binary search of an array, each probe into the binary search tree has the potential of eliminating half the elements in the tree. If the binary search tree is relatively balanced (i.e., the depths of the leaves are approximately the same), searching a binary search tree is an O(log n) process, just like a binary search of an ordered array.","title":"Searching a Binary Tree"},{"location":"data-structures/chp3-trees/chp3-trees.html#tree-traversals","text":"","title":"Tree Traversals"},{"location":"data-structures/chp3-trees/chp3-trees.html#preorder-traversal","text":"if the tree is empty Return. else Visit the root. Preorder traverse the left subtree Preorder traverse the right subtree","title":"Preorder Traversal"},{"location":"data-structures/chp3-trees/chp3-trees.html#inorder-traversal","text":"if the tree is empty Return. else Inorder traverse the left subtree Visit the root. Inorder traverse the right subtree","title":"Inorder Traversal"},{"location":"data-structures/chp3-trees/chp3-trees.html#postorder-traversal","text":"if the tree is empty Return. else Postorder traverse the left subtree Postorder traverse the right subtree Visit the root.","title":"Postorder Traversal"},{"location":"data-structures/chp3-trees/chp3-trees.html#implementing-a-binary-tree-class","text":"","title":"Implementing a Binary Tree Class"},{"location":"data-structures/chp3-trees/chp3-trees.html#class-binarytreee","text":"Data Field/Attribute Description protected Node<E> root Reference to the root of the tree Constructor/Behavior Description public BinaryTree() Constructs an empty binary tree protected BinaryTree(Node<E> root) Constructs a binary tree with the given node as the root public BinaryTree(E data, BinaryTree<E> leftTree, BinaryTree<E> rightTree) Constructs a binary tree with the given data at the root and the two given subtrees Method/Behavior Description public BinaryTree<E> getLeftSubtree() Returns the left subtree public BinaryTree<E> getRightSubtree() Returns the right subtree public E getData() Returns the data in the root public boolean isLeaf() Returns true if this tree is a leaf, false otherwise public String toString() Returns a String representation of the tree public void preOrderTraversal() Prints the output of preorder traversal public void inOrderTraversal() Prints the output of inorder traversal public void postOrderTraversal() Prints the output of postorder traversal package datastructures.tree; import java.io.Serializable; import java.util.Comparator; import java.util.Scanner; public class BinaryTree<E> implements Serializable{ /** Class to encapsulate a tree node. */ protected static class Node<E> implements Serializable { // Data Fields /** The information stored in this node. */ protected E data; /** Reference to the left child. */ protected Node<E> left; /** Reference to the right child. */ protected Node<E> right; // Constructors /** Construct a node with given data and no children. @param data The data to store in this node */ public Node(E data) { this.data = data; left = null; right = null; } // Methods /** Return a string representation of the node. @return A string representation of the data fields */ public String toString () { return data.toString(); } } // Data Field /** The root of the binary tree */ protected Node<E> root; // Data Fields /** Return value from the public add method. */ protected boolean addReturn; /** Return value from the public delete method. */ protected E deleteReturn; public BinaryTree() { root = null; } protected BinaryTree(Node<E> root) { this.root = root; } /** Constructs a new binary tree with data in its root leftTree as its left subtree and rightTree as its right subtree. */ public BinaryTree(E data, BinaryTree<E> leftTree, BinaryTree<E> rightTree) { root = new Node<>(data); if (leftTree != null) { root.left = leftTree.root; } else { root.left = null; } if (rightTree != null) { root.right = rightTree.root; } else { root.right = null; } } /** Return the left subtree. @return The left subtree or null if either the root or the left subtree is null */ public BinaryTree<E> getLeftSubtree() { if (root != null && root.left != null) { return new BinaryTree<>(root.left); } else { return null; } } /** Return the right subtree. @return The right subtree or null if either the root or the right subtree is null */ public BinaryTree<E> getRightSubtree() { if (root != null && root.right != null) { return new BinaryTree<>(root.right); } else { return null; } } /** Determine whether this tree is a leaf. @return true if the root has no children */ public boolean isLeaf() { return (root.left == null && root.right == null); } public String toString() { StringBuilder sb = new StringBuilder(); toString(root, 1, sb); return sb.toString(); } /** Converts a sub\u2010tree to a string. Performs a preorder traversal. @param node The local root @param depth The depth @param sb The StringBuilder to save the output */ private void toString(Node<E> node, int depth, StringBuilder sb) { for (int i = 1; i < depth; i++) { sb.append(\" \"); } if (node == null) { sb.append(\"null\\n\"); } else { sb.append(node.toString()); sb.append(\"\\n\"); toString(node.left, depth + 1, sb); toString(node.right, depth + 1, sb); } } public void preOrderTraversal(){ preOrderTraversal(root); } private void preOrderTraversal(Node<E> node){ if(node != null){ System.out.println(node.toString()); preOrderTraversal(node.left); preOrderTraversal(node.right); } } public void inOrderTraversal(){ inOrderTraversal(root); } private void inOrderTraversal(Node<E> node){ if(node != null){ inOrderTraversal(node.left); System.out.println(node.toString()); inOrderTraversal(node.right); } } public void postOrderTraversal(){ postOrderTraversal(root); } private void postOrderTraversal(Node<E> node){ if(node != null){ postOrderTraversal(node.left); postOrderTraversal(node.right); System.out.println(node.toString()); } } }","title":"Class BinaryTree&lt;E&gt;"},{"location":"data-structures/chp3-trees/chp3-trees.html#implementing-a-binarysearchtree-class","text":"","title":"Implementing a BinarySearchTree Class"},{"location":"data-structures/chp3-trees/chp3-trees.html#interface-searchtreee","text":"Method Description boolean add(E item) Inserts item where it belongs in the tree. Returns true if item is inserted; false if it isn\u2019t (already in tree) boolean contains(E target) Returns true if target is found in the tree E search(E target) Returns a reference to the data in the node that is equal to target . If no such node is found, returns null E delete(E target) Removes target (if found) from the tree and returns it; otherwise, returns null boolean remove(E target) Removes target (if found) from the tree and returns true; otherwise, returns false","title":"Interface SearchTree&lt;E&gt;"},{"location":"data-structures/chp3-trees/chp3-trees.html#operations","text":"","title":"Operations"},{"location":"data-structures/chp3-trees/chp3-trees.html#search","text":"if the tree is empty Return null (target is not found). else if the target matches the root node\u2019s data Return the data stored at the root node. else if the target is less than the root node\u2019s data Return the result of searching the left subtree of the root. else Return the result of searching the right subtree of the root.","title":"Search"},{"location":"data-structures/chp3-trees/chp3-trees.html#insert","text":"if the root is null Replace empty tree with a new tree with the item at the root and return true. else if the item is equal to root.data The item is already in the tree; return false. else if the item is less than root.data Recursively insert the item in the left subtree. else Recursively insert the item in the right subtree.","title":"Insert"},{"location":"data-structures/chp3-trees/chp3-trees.html#remove","text":"if the root is null The item is not in tree \u2013 return null. Compare the item to the data at the local root. if the item is less than the data at the local root Return the result of deleting from the left subtree. else if the item is greater than the local root Return the result of deleting from the right subtree. else # The item is in the local root Store the data in the local root in deleteReturn. if the local root has no children Set the parent of the local root to reference null. else if the local root has one child Set the parent of the local root to reference that child. else # Find the inorder predecessor if the left child has no right child it is the inorder predecessor Set the parent of the local root to reference the left child. else Find the rightmost node in the right subtree of the left child. Copy its data into the local root\u2019s data and remove it by setting its parent to reference its left child.","title":"Remove"},{"location":"data-structures/chp3-trees/chp3-trees.html#implementation","text":"package datastructures.tree; import java.util.NoSuchElementException; public class BinarySearchTree<E extends Comparable<E>> extends BinaryTree<E> implements SearchTree<E> { // Data Fields /** Return value from the public add method. */ protected boolean addReturn; /** Return value from the public delete method. */ protected E deleteReturn; /** Starter method find. pre: The target object must implement the Comparable interface. @param target The Comparable object being sought @return The object, if found, otherwise null */ public E search(E target) { return search(root, target); } /** Recursive find method. @param localRoot The local subtree's root @param target The object being sought @return The object, if found, otherwise null */ private E search(Node<E> localRoot, E target) { if (localRoot == null) return null; // Compare the target with the data field at the root. int compResult = target.compareTo(localRoot.data); if (compResult == 0) return localRoot.data; else if (compResult < 0) return search(localRoot.left, target); else return search(localRoot.right, target); } /** Starter method add. pre: The object to insert must implement the Comparable interface. @param item The object being inserted @return true if the object is inserted, false if the object already exists in the tree */ public boolean add(E item) { root = add(root, item); return addReturn; } /** Recursive add method. post: The data field addReturn is set true if the item is added to the tree, false if the item is already in the tree. @param localRoot The local root of the subtree @param item The object to be inserted @return The new local root that now contains the inserted item */ private Node<E> add(Node<E> localRoot, E item) { if (localRoot == null) { // item is not in the tree \u2014 insert it. addReturn = true; return new Node<>(item); } else if (item.compareTo(localRoot.data) == 0) { // item is equal to localRoot.data addReturn = false; return localRoot; } else if (item.compareTo(localRoot.data) < 0) { // item is less than localRoot.data localRoot.left = add(localRoot.left, item); return localRoot; } else { // item is greater than localRoot.data localRoot.right = add(localRoot.right, item); return localRoot; } } /** Starter method delete. post: The object is not in the tree. @param target The object to be deleted @return The object deleted from the tree or null if the object was not in the tree @throws ClassCastException if target does not implement Comparable */ public E delete(E target) { root = delete(root, target); return deleteReturn; } /** Recursive delete method. post: The item is not in the tree; deleteReturn is equal to the deleted item as it was stored in the tree or null if the item was not found. @param localRoot The root of the current subtree @param item The item to be deleted @return The modified local root that does not contain the item */ private Node<E> delete(Node<E> localRoot, E item) { if (localRoot == null) { // item is not in the tree. deleteReturn = null; return localRoot; } // Search for item to delete. int compResult = item.compareTo(localRoot.data); if (compResult < 0) { // item is smaller than localRoot.data. localRoot.left = delete(localRoot.left, item); } else if (compResult > 0) { // item is larger than localRoot.data. localRoot.right = delete(localRoot.right, item); } else { // item is at local root. deleteReturn = localRoot.data; if (localRoot.left == null) { // If there is no left child, return right child // which can also be null. return localRoot.right; } else if (localRoot.right == null) { // If there is no right child, return left child. return localRoot.left; } else { // Node being deleted has 2 children, replace the data with inorder predecessor. localRoot.data = getMin(localRoot.right); localRoot.right = delete(localRoot.right, localRoot.data); } } return localRoot; } private E getMin(){ if(root == null){ throw new NoSuchElementException(); } return getMin(root); } private E getMin(Node<E> localRoot){ if(localRoot.left == null){ return localRoot.data; } else{ return getMin(localRoot.left); } } @Override public boolean remove(E target) { root = delete(root, target); return deleteReturn != null; } @Override public boolean contains(E target) { return search(target) != null; } }","title":"Implementation"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html","text":"1. Heaps Overview At each level of a heap, the value in a node is less than all values in its two subtrees. Implies that minimum element is always the root (a \"min-heap\"). Variation : \"max-heap\" stores largest element at root, reverses ordering More formally, a heap is a complete binary tree with the following properties: The value in the root is the smallest item in the tree. Every subtree is a heap. Operations Insertion Insert the new item in the next position at the bottom of the heap. while new item is not at the root and new item is smaller than its parent Swap the new item with its parent, moving the new item up the heap. Removal Remove the item in the root node by replacing it with the last item in the heap (LIH). while item LIH has children, and item LIH is larger than either of its children Swap item LIH with its smaller child, moving LIH down the heap. Implementation Because a heap is a complete binary tree, we can implement it efficiently using an array (or ArrayList) instead of a linked data structure. Definitions: Root index = 0 For a node at position p left child = 2p + 1 right child = 2p +2 parent: (c - 1)/2 public class Heap<E extends Comparable<E>> implements IPriorityQueue<E> { private E[] elements; private int size; private int capacity; public static final int INITIAL_CAPACITY = 10; // constructs a new empty priority queue public Heap() { this(INITIAL_CAPACITY); } public Heap(int capacity){ this.elements = (E[]) new Object[capacity]; this.size = 0; this.capacity = capacity; } // Adds the given value to this priority queue in order. public void add(E value) { // resize to enlarge the heap if necessary if (size == capacity) { reallocate(); } elements[size] = value; // add as rightmost leaf // \"bubble up\" as necessary to fix ordering int index = size; boolean found = false; while (!found && hasParent(index)) { int parent = parent(index); if (elements[index].compareTo(elements[parent]) < 0) { swap(elements, index, parent(index)); index = parent(index); } else { found = true; // found proper location; stop } } size++; } public E peek() { return elements[0]; } public E remove() { // precondition: queue is not empty E result = elements[0]; // last leaf -> root elements[0] = elements[size - 1]; size--; int index = 0; // \"bubble down\" to fix ordering boolean found = false; while (!found && hasLeftChild(index)) { int left = leftChild(index); int right = rightChild(index); int child = left; if (hasRightChild(index) && elements[right].compareTo(elements[left]) < 0) { child = right; } if (elements[index].compareTo(elements[child]) > 0) { swap(elements, index, child); index = child; } else { found = true; // found proper location; stop } } return result; } @Override public void clear() { Arrays.fill(elements, null); size = 0; } @Override public boolean isEmpty() { return size > 0; } @Override public int size() { return size; } // helpers for navigating indexes up/down the tree private int parent(int index) { return (index - 1)/2; } private int leftChild(int index) { return 2 * index + 1; } private int rightChild(int index) { return 2 * index + 2; } private boolean hasParent(int index) { return index > 0; } private boolean hasLeftChild(int index) { return leftChild(index) < size; } private boolean hasRightChild(int index) { return rightChild(index) < size; } private void swap(E[] a, int index1, int index2) { E temp = a[index1]; a[index1] = a[index2]; a[index2] = temp; } private void reallocate(){ this.capacity = 2 * this.capacity; elements = Arrays.copyOf(elements, capacity); } } Performance Operations Big-O Complexity Add O(logN) [height of tree] Peek O(1) Remove O(logN) [height of tree]","title":"Heaps"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html#1-heaps","text":"","title":"1. Heaps"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html#overview","text":"At each level of a heap, the value in a node is less than all values in its two subtrees. Implies that minimum element is always the root (a \"min-heap\"). Variation : \"max-heap\" stores largest element at root, reverses ordering More formally, a heap is a complete binary tree with the following properties: The value in the root is the smallest item in the tree. Every subtree is a heap.","title":"Overview"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html#operations","text":"","title":"Operations"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html#insertion","text":"Insert the new item in the next position at the bottom of the heap. while new item is not at the root and new item is smaller than its parent Swap the new item with its parent, moving the new item up the heap.","title":"Insertion"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html#removal","text":"Remove the item in the root node by replacing it with the last item in the heap (LIH). while item LIH has children, and item LIH is larger than either of its children Swap item LIH with its smaller child, moving LIH down the heap.","title":"Removal"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html#implementation","text":"Because a heap is a complete binary tree, we can implement it efficiently using an array (or ArrayList) instead of a linked data structure. Definitions: Root index = 0 For a node at position p left child = 2p + 1 right child = 2p +2 parent: (c - 1)/2 public class Heap<E extends Comparable<E>> implements IPriorityQueue<E> { private E[] elements; private int size; private int capacity; public static final int INITIAL_CAPACITY = 10; // constructs a new empty priority queue public Heap() { this(INITIAL_CAPACITY); } public Heap(int capacity){ this.elements = (E[]) new Object[capacity]; this.size = 0; this.capacity = capacity; } // Adds the given value to this priority queue in order. public void add(E value) { // resize to enlarge the heap if necessary if (size == capacity) { reallocate(); } elements[size] = value; // add as rightmost leaf // \"bubble up\" as necessary to fix ordering int index = size; boolean found = false; while (!found && hasParent(index)) { int parent = parent(index); if (elements[index].compareTo(elements[parent]) < 0) { swap(elements, index, parent(index)); index = parent(index); } else { found = true; // found proper location; stop } } size++; } public E peek() { return elements[0]; } public E remove() { // precondition: queue is not empty E result = elements[0]; // last leaf -> root elements[0] = elements[size - 1]; size--; int index = 0; // \"bubble down\" to fix ordering boolean found = false; while (!found && hasLeftChild(index)) { int left = leftChild(index); int right = rightChild(index); int child = left; if (hasRightChild(index) && elements[right].compareTo(elements[left]) < 0) { child = right; } if (elements[index].compareTo(elements[child]) > 0) { swap(elements, index, child); index = child; } else { found = true; // found proper location; stop } } return result; } @Override public void clear() { Arrays.fill(elements, null); size = 0; } @Override public boolean isEmpty() { return size > 0; } @Override public int size() { return size; } // helpers for navigating indexes up/down the tree private int parent(int index) { return (index - 1)/2; } private int leftChild(int index) { return 2 * index + 1; } private int rightChild(int index) { return 2 * index + 2; } private boolean hasParent(int index) { return index > 0; } private boolean hasLeftChild(int index) { return leftChild(index) < size; } private boolean hasRightChild(int index) { return rightChild(index) < size; } private void swap(E[] a, int index1, int index2) { E temp = a[index1]; a[index1] = a[index2]; a[index2] = temp; } private void reallocate(){ this.capacity = 2 * this.capacity; elements = Arrays.copyOf(elements, capacity); } }","title":"Implementation"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-1-heaps.html#performance","text":"Operations Big-O Complexity Add O(logN) [height of tree] Peek O(1) Remove O(logN) [height of tree]","title":"Performance"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-2-priority-queues.html","text":"2. Priority Queues Overview A priority queue is a data structure in which only the highest priority item is accessible. In computer science, a heap is used as the basis of a very efficient algorithm for sorting arrays, called heapsort (we'll cover later). The heap is also used to implement a special kind of queue called a priority queue. However, the heap is not very useful as an abstract data type (ADT) on its own. Consequently, we will not create a Heap interface or code a class that implements it. Instead we will incorporate its algorithms when we implement a priority queue class and heapsort. Class java.util.PriorityQueue<E> Constructor Description PriorityQueue() Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering. PriorityQueue(Comparator<? super E> comparator) Creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator. Modifier and Type Method Description boolean add(E e) Inserts the specified element into this priority queue. void clear() Removes all of the elements from this priority queue. Comparator<? super E> comparator() Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the natural ordering of its elements. boolean contains(Object o) Returns true if this queue contains the specified element. Iterator<E> iterator() Returns an iterator over the elements in this queue. boolean offer(E e) Inserts the specified element into this priority queue. E peek() Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. E poll() Retrieves and removes the head of this queue, or returns null if this queue is empty. boolean remove(Object o) Removes a single instance of the specified element from this queue, if it is present. int size() Returns the number of elements in this collection. The class java.util.PriorityQueue uses an array of type Object[] for heap storage. Class PriorityQueue<E> In our case, as an example, we use ArrayList for implementing a PriorityQueue class. Data Field/Attribute Description ArrayList<E> theData An ArrayList to hold the data Comparator<E> comparator An optional object that implements the Comparator<E> interface by providing a compare method Constructor Description KWPriorityQueue() Constructs a heap-based priority queue that uses the elements' natural ordering KWPriorityQueue(Comparator<E> comp) Constructs a heap-based priority queue that uses the compare method of Comparator comp to determine the ordering of the elements Private Method Description private int compare(E left, E right) Compares two objects and returns a negative number if object left is less than object right , zero if they are equal, and a positive number if object left is greater than object right private void swap(int i, int j) Exchanges the object references in theData at indexes i and j package datastructures.heap; import java.util.*; /** The PriorityQueue implements the Queue interface by building a heap in an ArrayList. The heap is structured so that the \u201csmallest\u201d item is at the top. */ public class PriorityQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** * The ArrayList to hold the data. */ private ArrayList<E> data; /** * An optional reference to a Comparator object. */ Comparator<E> comparator = null; // Methods // Constructor public PriorityQueue() { data = new ArrayList<>(); } /** Creates a heap\u2010based priority queue with the specified initial capacity that orders its elements according to the specified comparator. @param capacity The initial capacity for this priority queue @param comp The comparator used to order this priority queue @throws IllegalArgumentException if capacity is less than 1 */ public PriorityQueue(int capacity, Comparator<E> comp) { if (capacity < 1) throw new IllegalArgumentException(); data = new ArrayList<>(); comparator = comp; } /** * Insert an item into the priority queue. * pre: The ArrayList theData is in heap order. * post: The item is in the priority queue and * theData is in heap order. * * @param item The item to be inserted * @throws NullPointerException if the item to be inserted is null. */ @Override public boolean offer(E item) { // Add the item to the heap. data.add(item); // child is newly inserted item. int child = data.size()-1; int parent = (child - 1) /2; // Find child's parent. // Reheap while (parent >= 0 && compare(data.get(parent), data.get(child)) > 0) { swap(parent, child); child = parent; parent = (child - 1) /2; } return true; } /** * Remove an item from the priority queue * pre: The ArrayList theData is in heap order. * post: Removed smallest item, theData is in heap order. * * @return The item with the smallest priority value or null if empty. */ @Override public E poll() { if (isEmpty()) { return null; } // Save the top of the heap. E result = data.get(0); // If only one item then remove it. if (data.size() == 1) { data.remove(0); return result; } /* Remove the last item from the ArrayList and place it into the first position. */ data.set(0, data.remove(data.size() - 1)); // The parent starts at the top. int parent = 0; while (true) { int leftChild = 2 * parent + 1; if (leftChild >= data.size()) { break; // Out of heap. } int rightChild = leftChild + 1; int minChild = leftChild; // Assume leftChild is smaller. // See whether rightChild is smaller. if (rightChild < data.size() && compare(data.get(leftChild), data.get(rightChild)) > 0) { minChild = rightChild; } // assert: minChild is the index of the smaller child. // Move smaller child up heap if necessary. if (compare(data.get(parent), data.get(minChild)) > 0) { swap(parent, minChild); parent = minChild; } else { // Heap property is restored. break; } } return result; } @Override public E peek() { return data.get(0); } /** Compare two items using either a Comparator object's compare method or their natural ordering using method compareTo. @pre: If comparator is null, left and right implement Comparable<E>. @param left One item @param right The other item @return Negative int if left less than right, 0 if left equals right, positive int if left > right @throws ClassCastException if items are not Comparable */ @SuppressWarnings(\"unchecked\") private int compare(E left, E right) { if (comparator != null) { // A Comparator is defined. return comparator.compare(left, right); } else { // Use left's compareTo method. return ((Comparable<E>) left).compareTo(right); } } @Override public Iterator<E> iterator() { return null; } @Override public int size() { return data.size(); } private void swap(int index1, int index2) { E temp = data.get(index1); data.set(index1, data.get(index2)); data.set(index2, temp); } }","title":"Priority Queues"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-2-priority-queues.html#2-priority-queues","text":"","title":"2. Priority Queues"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-2-priority-queues.html#overview","text":"A priority queue is a data structure in which only the highest priority item is accessible. In computer science, a heap is used as the basis of a very efficient algorithm for sorting arrays, called heapsort (we'll cover later). The heap is also used to implement a special kind of queue called a priority queue. However, the heap is not very useful as an abstract data type (ADT) on its own. Consequently, we will not create a Heap interface or code a class that implements it. Instead we will incorporate its algorithms when we implement a priority queue class and heapsort.","title":"Overview"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-2-priority-queues.html#class-javautilpriorityqueuee","text":"Constructor Description PriorityQueue() Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering. PriorityQueue(Comparator<? super E> comparator) Creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator. Modifier and Type Method Description boolean add(E e) Inserts the specified element into this priority queue. void clear() Removes all of the elements from this priority queue. Comparator<? super E> comparator() Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the natural ordering of its elements. boolean contains(Object o) Returns true if this queue contains the specified element. Iterator<E> iterator() Returns an iterator over the elements in this queue. boolean offer(E e) Inserts the specified element into this priority queue. E peek() Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. E poll() Retrieves and removes the head of this queue, or returns null if this queue is empty. boolean remove(Object o) Removes a single instance of the specified element from this queue, if it is present. int size() Returns the number of elements in this collection. The class java.util.PriorityQueue uses an array of type Object[] for heap storage.","title":"Class java.util.PriorityQueue&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-2-priority-queues.html#class-priorityqueuee","text":"In our case, as an example, we use ArrayList for implementing a PriorityQueue class. Data Field/Attribute Description ArrayList<E> theData An ArrayList to hold the data Comparator<E> comparator An optional object that implements the Comparator<E> interface by providing a compare method Constructor Description KWPriorityQueue() Constructs a heap-based priority queue that uses the elements' natural ordering KWPriorityQueue(Comparator<E> comp) Constructs a heap-based priority queue that uses the compare method of Comparator comp to determine the ordering of the elements Private Method Description private int compare(E left, E right) Compares two objects and returns a negative number if object left is less than object right , zero if they are equal, and a positive number if object left is greater than object right private void swap(int i, int j) Exchanges the object references in theData at indexes i and j package datastructures.heap; import java.util.*; /** The PriorityQueue implements the Queue interface by building a heap in an ArrayList. The heap is structured so that the \u201csmallest\u201d item is at the top. */ public class PriorityQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** * The ArrayList to hold the data. */ private ArrayList<E> data; /** * An optional reference to a Comparator object. */ Comparator<E> comparator = null; // Methods // Constructor public PriorityQueue() { data = new ArrayList<>(); } /** Creates a heap\u2010based priority queue with the specified initial capacity that orders its elements according to the specified comparator. @param capacity The initial capacity for this priority queue @param comp The comparator used to order this priority queue @throws IllegalArgumentException if capacity is less than 1 */ public PriorityQueue(int capacity, Comparator<E> comp) { if (capacity < 1) throw new IllegalArgumentException(); data = new ArrayList<>(); comparator = comp; } /** * Insert an item into the priority queue. * pre: The ArrayList theData is in heap order. * post: The item is in the priority queue and * theData is in heap order. * * @param item The item to be inserted * @throws NullPointerException if the item to be inserted is null. */ @Override public boolean offer(E item) { // Add the item to the heap. data.add(item); // child is newly inserted item. int child = data.size()-1; int parent = (child - 1) /2; // Find child's parent. // Reheap while (parent >= 0 && compare(data.get(parent), data.get(child)) > 0) { swap(parent, child); child = parent; parent = (child - 1) /2; } return true; } /** * Remove an item from the priority queue * pre: The ArrayList theData is in heap order. * post: Removed smallest item, theData is in heap order. * * @return The item with the smallest priority value or null if empty. */ @Override public E poll() { if (isEmpty()) { return null; } // Save the top of the heap. E result = data.get(0); // If only one item then remove it. if (data.size() == 1) { data.remove(0); return result; } /* Remove the last item from the ArrayList and place it into the first position. */ data.set(0, data.remove(data.size() - 1)); // The parent starts at the top. int parent = 0; while (true) { int leftChild = 2 * parent + 1; if (leftChild >= data.size()) { break; // Out of heap. } int rightChild = leftChild + 1; int minChild = leftChild; // Assume leftChild is smaller. // See whether rightChild is smaller. if (rightChild < data.size() && compare(data.get(leftChild), data.get(rightChild)) > 0) { minChild = rightChild; } // assert: minChild is the index of the smaller child. // Move smaller child up heap if necessary. if (compare(data.get(parent), data.get(minChild)) > 0) { swap(parent, minChild); parent = minChild; } else { // Heap property is restored. break; } } return result; } @Override public E peek() { return data.get(0); } /** Compare two items using either a Comparator object's compare method or their natural ordering using method compareTo. @pre: If comparator is null, left and right implement Comparable<E>. @param left One item @param right The other item @return Negative int if left less than right, 0 if left equals right, positive int if left > right @throws ClassCastException if items are not Comparable */ @SuppressWarnings(\"unchecked\") private int compare(E left, E right) { if (comparator != null) { // A Comparator is defined. return comparator.compare(left, right); } else { // Use left's compareTo method. return ((Comparable<E>) left).compareTo(right); } } @Override public Iterator<E> iterator() { return null; } @Override public int size() { return data.size(); } private void swap(int index1, int index2) { E temp = data.get(index1); data.set(index1, data.get(index2)); data.set(index2, temp); } }","title":"Class PriorityQueue&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-3-interface-comparable-and-comparator.html","text":"Interface Comparable<E> and Comparator<E> How do we compare elements in a PriorityQueue? Interface Comparable<E> In many cases, we will insert objects that implement Comparable<E> and use their natural ordering as specified by method compareTo . Comparable<E> is used to define the natural ordering of an object type. Interface Comparator<E> However, we may need to insert objects that do not implement Comparable<E> , or we may want to specify a different ordering from that defined by the object\u2019s compareTo method. For example, files to be printed may be ordered by their name using the compareTo method, but we may want to assign priority based on their length. The Java API contains the Comparator<E> interface, which allows us to specify alternative ways to compare objects. An implementer of the Comparator<E> interface must define a compare method that is similar to compareTo except that it has two parameters. public interface Comparator<T> { public int compare(T first, T second); } Example public class RectangleAreaComparator implements Comparator<Rectangle> { // compare in ascending order by area (WxH) public int compare(Rectangle r1, Rectangle r2) { return r1.getArea() - r2.getArea(); } } Using Comparators TreeSet, TreeMap , PriorityQueue can use Comparator: java Comparator<Rectangle> comp = new RectangleAreaComparator(); Set<Rectangle> set = new TreeSet<Rectangle>(comp); Queue<Rectangle> pq = new PriorityQueue<Rectangle>(10,comp); Searching and sorting methods can accept Comparators. java Arrays.binarySearch(array, value, comparator) Arrays.sort(array, comparator) Collections.binarySearch(list, comparator) Collections.max(collection, comparator) Collections.min(collection, comparator) Collections.sort(list, comparator) Methods are provided to reverse a Comparator's ordering: java public static Comparator Collections.reverseOrder() public static Comparator Collections.reverseOrder(comparator) Example: Using Comparator for ordering a Priority Queue public class LengthComparator implements Comparator<String> { public int compare(String s1, String s2) { if (s1.length() != s2.length()) { // if lengths are unequal, compare by length return s1.length() - s2.length(); } else { // break ties by ABC order return s1.compareTo(s2); } } } Queue<String> pq = new PriorityQueue<String>(100, new LengthComparator()); Observe that, in the example, we are still making use of the fact that the class String is implementing Comparable<E> interface to define its own natural ordering by implementing compareTo method.","title":"Interface Comparable and Comparator"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-3-interface-comparable-and-comparator.html#interface-comparablee-and-comparatore","text":"How do we compare elements in a PriorityQueue?","title":"Interface Comparable&lt;E&gt; and Comparator&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-3-interface-comparable-and-comparator.html#interface-comparablee","text":"In many cases, we will insert objects that implement Comparable<E> and use their natural ordering as specified by method compareTo . Comparable<E> is used to define the natural ordering of an object type.","title":"Interface Comparable&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-3-interface-comparable-and-comparator.html#interface-comparatore","text":"However, we may need to insert objects that do not implement Comparable<E> , or we may want to specify a different ordering from that defined by the object\u2019s compareTo method. For example, files to be printed may be ordered by their name using the compareTo method, but we may want to assign priority based on their length. The Java API contains the Comparator<E> interface, which allows us to specify alternative ways to compare objects. An implementer of the Comparator<E> interface must define a compare method that is similar to compareTo except that it has two parameters. public interface Comparator<T> { public int compare(T first, T second); } Example public class RectangleAreaComparator implements Comparator<Rectangle> { // compare in ascending order by area (WxH) public int compare(Rectangle r1, Rectangle r2) { return r1.getArea() - r2.getArea(); } }","title":"Interface Comparator&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/4-3-interface-comparable-and-comparator.html#using-comparators","text":"TreeSet, TreeMap , PriorityQueue can use Comparator: java Comparator<Rectangle> comp = new RectangleAreaComparator(); Set<Rectangle> set = new TreeSet<Rectangle>(comp); Queue<Rectangle> pq = new PriorityQueue<Rectangle>(10,comp); Searching and sorting methods can accept Comparators. java Arrays.binarySearch(array, value, comparator) Arrays.sort(array, comparator) Collections.binarySearch(list, comparator) Collections.max(collection, comparator) Collections.min(collection, comparator) Collections.sort(list, comparator) Methods are provided to reverse a Comparator's ordering: java public static Comparator Collections.reverseOrder() public static Comparator Collections.reverseOrder(comparator) Example: Using Comparator for ordering a Priority Queue public class LengthComparator implements Comparator<String> { public int compare(String s1, String s2) { if (s1.length() != s2.length()) { // if lengths are unequal, compare by length return s1.length() - s2.length(); } else { // break ties by ABC order return s1.compareTo(s2); } } } Queue<String> pq = new PriorityQueue<String>(100, new LengthComparator()); Observe that, in the example, we are still making use of the fact that the class String is implementing Comparable<E> interface to define its own natural ordering by implementing compareTo method.","title":"Using Comparators"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html","text":"1. Heaps Overview At each level of a heap, the value in a node is less than all values in its two subtrees. Implies that minimum element is always the root (a \"min-heap\"). Variation : \"max-heap\" stores largest element at root, reverses ordering More formally, a heap is a complete binary tree with the following properties: The value in the root is the smallest item in the tree. Every subtree is a heap. Operations Insertion Insert the new item in the next position at the bottom of the heap. while new item is not at the root and new item is smaller than its parent Swap the new item with its parent, moving the new item up the heap. Removal Remove the item in the root node by replacing it with the last item in the heap (LIH). while item LIH has children, and item LIH is larger than either of its children Swap item LIH with its smaller child, moving LIH down the heap. Implementation Because a heap is a complete binary tree, we can implement it efficiently using an array (or ArrayList) instead of a linked data structure. Definitions: Root index = 0 For a node at position p left child = 2p + 1 right child = 2p +2 parent: (c - 1)/2 public class Heap<E extends Comparable<E>> implements IPriorityQueue<E> { private E[] elements; private int size; private int capacity; public static final int INITIAL_CAPACITY = 10; // constructs a new empty priority queue public Heap() { this(INITIAL_CAPACITY); } public Heap(int capacity){ this.elements = (E[]) new Object[capacity]; this.size = 0; this.capacity = capacity; } // Adds the given value to this priority queue in order. public void add(E value) { // resize to enlarge the heap if necessary if (size == capacity) { reallocate(); } elements[size] = value; // add as rightmost leaf // \"bubble up\" as necessary to fix ordering int index = size; boolean found = false; while (!found && hasParent(index)) { int parent = parent(index); if (elements[index].compareTo(elements[parent]) < 0) { swap(elements, index, parent(index)); index = parent(index); } else { found = true; // found proper location; stop } } size++; } public E peek() { return elements[0]; } public E remove() { // precondition: queue is not empty E result = elements[0]; // last leaf -> root elements[0] = elements[size - 1]; size--; int index = 0; // \"bubble down\" to fix ordering boolean found = false; while (!found && hasLeftChild(index)) { int left = leftChild(index); int right = rightChild(index); int child = left; if (hasRightChild(index) && elements[right].compareTo(elements[left]) < 0) { child = right; } if (elements[index].compareTo(elements[child]) > 0) { swap(elements, index, child); index = child; } else { found = true; // found proper location; stop } } return result; } @Override public void clear() { Arrays.fill(elements, null); size = 0; } @Override public boolean isEmpty() { return size > 0; } @Override public int size() { return size; } // helpers for navigating indexes up/down the tree private int parent(int index) { return (index - 1)/2; } private int leftChild(int index) { return 2 * index + 1; } private int rightChild(int index) { return 2 * index + 2; } private boolean hasParent(int index) { return index > 0; } private boolean hasLeftChild(int index) { return leftChild(index) < size; } private boolean hasRightChild(int index) { return rightChild(index) < size; } private void swap(E[] a, int index1, int index2) { E temp = a[index1]; a[index1] = a[index2]; a[index2] = temp; } private void reallocate(){ this.capacity = 2 * this.capacity; elements = Arrays.copyOf(elements, capacity); } } Performance Operations Big-O Complexity Add O(logN) [height of tree] Peek O(1) Remove O(logN) [height of tree] 2. Priority Queues Overview A priority queue is a data structure in which only the highest priority item is accessible. In computer science, a heap is used as the basis of a very efficient algorithm for sorting arrays, called heapsort (we'll cover later). The heap is also used to implement a special kind of queue called a priority queue. However, the heap is not very useful as an abstract data type (ADT) on its own. Consequently, we will not create a Heap interface or code a class that implements it. Instead we will incorporate its algorithms when we implement a priority queue class and heapsort. Class java.util.PriorityQueue<E> Constructor Description PriorityQueue() Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering. PriorityQueue(Comparator<? super E> comparator) Creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator. Modifier and Type Method Description boolean add(E e) Inserts the specified element into this priority queue. void clear() Removes all of the elements from this priority queue. Comparator<? super E> comparator() Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the natural ordering of its elements. boolean contains(Object o) Returns true if this queue contains the specified element. Iterator<E> iterator() Returns an iterator over the elements in this queue. boolean offer(E e) Inserts the specified element into this priority queue. E peek() Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. E poll() Retrieves and removes the head of this queue, or returns null if this queue is empty. boolean remove(Object o) Removes a single instance of the specified element from this queue, if it is present. int size() Returns the number of elements in this collection. The class java.util.PriorityQueue uses an array of type Object[] for heap storage. Class PriorityQueue<E> In our case, as an example, we use ArrayList for implementing a PriorityQueue class. Data Field/Attribute Description ArrayList<E> theData An ArrayList to hold the data Comparator<E> comparator An optional object that implements the Comparator<E> interface by providing a compare method Constructor Description KWPriorityQueue() Constructs a heap-based priority queue that uses the elements' natural ordering KWPriorityQueue(Comparator<E> comp) Constructs a heap-based priority queue that uses the compare method of Comparator comp to determine the ordering of the elements Private Method Description private int compare(E left, E right) Compares two objects and returns a negative number if object left is less than object right , zero if they are equal, and a positive number if object left is greater than object right private void swap(int i, int j) Exchanges the object references in theData at indexes i and j package datastructures.heap; import java.util.*; /** The PriorityQueue implements the Queue interface by building a heap in an ArrayList. The heap is structured so that the \u201csmallest\u201d item is at the top. */ public class PriorityQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** * The ArrayList to hold the data. */ private ArrayList<E> data; /** * An optional reference to a Comparator object. */ Comparator<E> comparator = null; // Methods // Constructor public PriorityQueue() { data = new ArrayList<>(); } /** Creates a heap\u2010based priority queue with the specified initial capacity that orders its elements according to the specified comparator. @param capacity The initial capacity for this priority queue @param comp The comparator used to order this priority queue @throws IllegalArgumentException if capacity is less than 1 */ public PriorityQueue(int capacity, Comparator<E> comp) { if (capacity < 1) throw new IllegalArgumentException(); data = new ArrayList<>(); comparator = comp; } /** * Insert an item into the priority queue. * pre: The ArrayList theData is in heap order. * post: The item is in the priority queue and * theData is in heap order. * * @param item The item to be inserted * @throws NullPointerException if the item to be inserted is null. */ @Override public boolean offer(E item) { // Add the item to the heap. data.add(item); // child is newly inserted item. int child = data.size()-1; int parent = (child - 1) /2; // Find child's parent. // Reheap while (parent >= 0 && compare(data.get(parent), data.get(child)) > 0) { swap(parent, child); child = parent; parent = (child - 1) /2; } return true; } /** * Remove an item from the priority queue * pre: The ArrayList theData is in heap order. * post: Removed smallest item, theData is in heap order. * * @return The item with the smallest priority value or null if empty. */ @Override public E poll() { if (isEmpty()) { return null; } // Save the top of the heap. E result = data.get(0); // If only one item then remove it. if (data.size() == 1) { data.remove(0); return result; } /* Remove the last item from the ArrayList and place it into the first position. */ data.set(0, data.remove(data.size() - 1)); // The parent starts at the top. int parent = 0; while (true) { int leftChild = 2 * parent + 1; if (leftChild >= data.size()) { break; // Out of heap. } int rightChild = leftChild + 1; int minChild = leftChild; // Assume leftChild is smaller. // See whether rightChild is smaller. if (rightChild < data.size() && compare(data.get(leftChild), data.get(rightChild)) > 0) { minChild = rightChild; } // assert: minChild is the index of the smaller child. // Move smaller child up heap if necessary. if (compare(data.get(parent), data.get(minChild)) > 0) { swap(parent, minChild); parent = minChild; } else { // Heap property is restored. break; } } return result; } @Override public E peek() { return data.get(0); } /** Compare two items using either a Comparator object's compare method or their natural ordering using method compareTo. @pre: If comparator is null, left and right implement Comparable<E>. @param left One item @param right The other item @return Negative int if left less than right, 0 if left equals right, positive int if left > right @throws ClassCastException if items are not Comparable */ @SuppressWarnings(\"unchecked\") private int compare(E left, E right) { if (comparator != null) { // A Comparator is defined. return comparator.compare(left, right); } else { // Use left's compareTo method. return ((Comparable<E>) left).compareTo(right); } } @Override public Iterator<E> iterator() { return null; } @Override public int size() { return data.size(); } private void swap(int index1, int index2) { E temp = data.get(index1); data.set(index1, data.get(index2)); data.set(index2, temp); } } Interface Comparable<E> and Comparator<E> How do we compare elements in a PriorityQueue? Interface Comparable<E> In many cases, we will insert objects that implement Comparable<E> and use their natural ordering as specified by method compareTo . Comparable<E> is used to define the natural ordering of an object type. Interface Comparator<E> However, we may need to insert objects that do not implement Comparable<E> , or we may want to specify a different ordering from that defined by the object\u2019s compareTo method. For example, files to be printed may be ordered by their name using the compareTo method, but we may want to assign priority based on their length. The Java API contains the Comparator<E> interface, which allows us to specify alternative ways to compare objects. An implementer of the Comparator<E> interface must define a compare method that is similar to compareTo except that it has two parameters. public interface Comparator<T> { public int compare(T first, T second); } Example public class RectangleAreaComparator implements Comparator<Rectangle> { // compare in ascending order by area (WxH) public int compare(Rectangle r1, Rectangle r2) { return r1.getArea() - r2.getArea(); } } Using Comparators TreeSet, TreeMap , PriorityQueue can use Comparator: java Comparator<Rectangle> comp = new RectangleAreaComparator(); Set<Rectangle> set = new TreeSet<Rectangle>(comp); Queue<Rectangle> pq = new PriorityQueue<Rectangle>(10,comp); Searching and sorting methods can accept Comparators. java Arrays.binarySearch(array, value, comparator) Arrays.sort(array, comparator) Collections.binarySearch(list, comparator) Collections.max(collection, comparator) Collections.min(collection, comparator) Collections.sort(list, comparator) Methods are provided to reverse a Comparator's ordering: java public static Comparator Collections.reverseOrder() public static Comparator Collections.reverseOrder(comparator) Example: Using Comparator for ordering a Priority Queue public class LengthComparator implements Comparator<String> { public int compare(String s1, String s2) { if (s1.length() != s2.length()) { // if lengths are unequal, compare by length return s1.length() - s2.length(); } else { // break ties by ABC order return s1.compareTo(s2); } } } Queue<String> pq = new PriorityQueue<String>(100, new LengthComparator()); Observe that, in the example, we are still making use of the fact that the class String is implementing Comparable<E> interface to define its own natural ordering by implementing compareTo method.","title":"1. Heaps"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#1-heaps","text":"","title":"1. Heaps"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#overview","text":"At each level of a heap, the value in a node is less than all values in its two subtrees. Implies that minimum element is always the root (a \"min-heap\"). Variation : \"max-heap\" stores largest element at root, reverses ordering More formally, a heap is a complete binary tree with the following properties: The value in the root is the smallest item in the tree. Every subtree is a heap.","title":"Overview"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#operations","text":"","title":"Operations"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#insertion","text":"Insert the new item in the next position at the bottom of the heap. while new item is not at the root and new item is smaller than its parent Swap the new item with its parent, moving the new item up the heap.","title":"Insertion"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#removal","text":"Remove the item in the root node by replacing it with the last item in the heap (LIH). while item LIH has children, and item LIH is larger than either of its children Swap item LIH with its smaller child, moving LIH down the heap.","title":"Removal"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#implementation","text":"Because a heap is a complete binary tree, we can implement it efficiently using an array (or ArrayList) instead of a linked data structure. Definitions: Root index = 0 For a node at position p left child = 2p + 1 right child = 2p +2 parent: (c - 1)/2 public class Heap<E extends Comparable<E>> implements IPriorityQueue<E> { private E[] elements; private int size; private int capacity; public static final int INITIAL_CAPACITY = 10; // constructs a new empty priority queue public Heap() { this(INITIAL_CAPACITY); } public Heap(int capacity){ this.elements = (E[]) new Object[capacity]; this.size = 0; this.capacity = capacity; } // Adds the given value to this priority queue in order. public void add(E value) { // resize to enlarge the heap if necessary if (size == capacity) { reallocate(); } elements[size] = value; // add as rightmost leaf // \"bubble up\" as necessary to fix ordering int index = size; boolean found = false; while (!found && hasParent(index)) { int parent = parent(index); if (elements[index].compareTo(elements[parent]) < 0) { swap(elements, index, parent(index)); index = parent(index); } else { found = true; // found proper location; stop } } size++; } public E peek() { return elements[0]; } public E remove() { // precondition: queue is not empty E result = elements[0]; // last leaf -> root elements[0] = elements[size - 1]; size--; int index = 0; // \"bubble down\" to fix ordering boolean found = false; while (!found && hasLeftChild(index)) { int left = leftChild(index); int right = rightChild(index); int child = left; if (hasRightChild(index) && elements[right].compareTo(elements[left]) < 0) { child = right; } if (elements[index].compareTo(elements[child]) > 0) { swap(elements, index, child); index = child; } else { found = true; // found proper location; stop } } return result; } @Override public void clear() { Arrays.fill(elements, null); size = 0; } @Override public boolean isEmpty() { return size > 0; } @Override public int size() { return size; } // helpers for navigating indexes up/down the tree private int parent(int index) { return (index - 1)/2; } private int leftChild(int index) { return 2 * index + 1; } private int rightChild(int index) { return 2 * index + 2; } private boolean hasParent(int index) { return index > 0; } private boolean hasLeftChild(int index) { return leftChild(index) < size; } private boolean hasRightChild(int index) { return rightChild(index) < size; } private void swap(E[] a, int index1, int index2) { E temp = a[index1]; a[index1] = a[index2]; a[index2] = temp; } private void reallocate(){ this.capacity = 2 * this.capacity; elements = Arrays.copyOf(elements, capacity); } }","title":"Implementation"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#performance","text":"Operations Big-O Complexity Add O(logN) [height of tree] Peek O(1) Remove O(logN) [height of tree]","title":"Performance"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#2-priority-queues","text":"","title":"2. Priority Queues"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#overview_1","text":"A priority queue is a data structure in which only the highest priority item is accessible. In computer science, a heap is used as the basis of a very efficient algorithm for sorting arrays, called heapsort (we'll cover later). The heap is also used to implement a special kind of queue called a priority queue. However, the heap is not very useful as an abstract data type (ADT) on its own. Consequently, we will not create a Heap interface or code a class that implements it. Instead we will incorporate its algorithms when we implement a priority queue class and heapsort.","title":"Overview"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#class-javautilpriorityqueuee","text":"Constructor Description PriorityQueue() Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their natural ordering. PriorityQueue(Comparator<? super E> comparator) Creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator. Modifier and Type Method Description boolean add(E e) Inserts the specified element into this priority queue. void clear() Removes all of the elements from this priority queue. Comparator<? super E> comparator() Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the natural ordering of its elements. boolean contains(Object o) Returns true if this queue contains the specified element. Iterator<E> iterator() Returns an iterator over the elements in this queue. boolean offer(E e) Inserts the specified element into this priority queue. E peek() Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. E poll() Retrieves and removes the head of this queue, or returns null if this queue is empty. boolean remove(Object o) Removes a single instance of the specified element from this queue, if it is present. int size() Returns the number of elements in this collection. The class java.util.PriorityQueue uses an array of type Object[] for heap storage.","title":"Class java.util.PriorityQueue&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#class-priorityqueuee","text":"In our case, as an example, we use ArrayList for implementing a PriorityQueue class. Data Field/Attribute Description ArrayList<E> theData An ArrayList to hold the data Comparator<E> comparator An optional object that implements the Comparator<E> interface by providing a compare method Constructor Description KWPriorityQueue() Constructs a heap-based priority queue that uses the elements' natural ordering KWPriorityQueue(Comparator<E> comp) Constructs a heap-based priority queue that uses the compare method of Comparator comp to determine the ordering of the elements Private Method Description private int compare(E left, E right) Compares two objects and returns a negative number if object left is less than object right , zero if they are equal, and a positive number if object left is greater than object right private void swap(int i, int j) Exchanges the object references in theData at indexes i and j package datastructures.heap; import java.util.*; /** The PriorityQueue implements the Queue interface by building a heap in an ArrayList. The heap is structured so that the \u201csmallest\u201d item is at the top. */ public class PriorityQueue<E> extends AbstractQueue<E> implements Queue<E> { // Data Fields /** * The ArrayList to hold the data. */ private ArrayList<E> data; /** * An optional reference to a Comparator object. */ Comparator<E> comparator = null; // Methods // Constructor public PriorityQueue() { data = new ArrayList<>(); } /** Creates a heap\u2010based priority queue with the specified initial capacity that orders its elements according to the specified comparator. @param capacity The initial capacity for this priority queue @param comp The comparator used to order this priority queue @throws IllegalArgumentException if capacity is less than 1 */ public PriorityQueue(int capacity, Comparator<E> comp) { if (capacity < 1) throw new IllegalArgumentException(); data = new ArrayList<>(); comparator = comp; } /** * Insert an item into the priority queue. * pre: The ArrayList theData is in heap order. * post: The item is in the priority queue and * theData is in heap order. * * @param item The item to be inserted * @throws NullPointerException if the item to be inserted is null. */ @Override public boolean offer(E item) { // Add the item to the heap. data.add(item); // child is newly inserted item. int child = data.size()-1; int parent = (child - 1) /2; // Find child's parent. // Reheap while (parent >= 0 && compare(data.get(parent), data.get(child)) > 0) { swap(parent, child); child = parent; parent = (child - 1) /2; } return true; } /** * Remove an item from the priority queue * pre: The ArrayList theData is in heap order. * post: Removed smallest item, theData is in heap order. * * @return The item with the smallest priority value or null if empty. */ @Override public E poll() { if (isEmpty()) { return null; } // Save the top of the heap. E result = data.get(0); // If only one item then remove it. if (data.size() == 1) { data.remove(0); return result; } /* Remove the last item from the ArrayList and place it into the first position. */ data.set(0, data.remove(data.size() - 1)); // The parent starts at the top. int parent = 0; while (true) { int leftChild = 2 * parent + 1; if (leftChild >= data.size()) { break; // Out of heap. } int rightChild = leftChild + 1; int minChild = leftChild; // Assume leftChild is smaller. // See whether rightChild is smaller. if (rightChild < data.size() && compare(data.get(leftChild), data.get(rightChild)) > 0) { minChild = rightChild; } // assert: minChild is the index of the smaller child. // Move smaller child up heap if necessary. if (compare(data.get(parent), data.get(minChild)) > 0) { swap(parent, minChild); parent = minChild; } else { // Heap property is restored. break; } } return result; } @Override public E peek() { return data.get(0); } /** Compare two items using either a Comparator object's compare method or their natural ordering using method compareTo. @pre: If comparator is null, left and right implement Comparable<E>. @param left One item @param right The other item @return Negative int if left less than right, 0 if left equals right, positive int if left > right @throws ClassCastException if items are not Comparable */ @SuppressWarnings(\"unchecked\") private int compare(E left, E right) { if (comparator != null) { // A Comparator is defined. return comparator.compare(left, right); } else { // Use left's compareTo method. return ((Comparable<E>) left).compareTo(right); } } @Override public Iterator<E> iterator() { return null; } @Override public int size() { return data.size(); } private void swap(int index1, int index2) { E temp = data.get(index1); data.set(index1, data.get(index2)); data.set(index2, temp); } }","title":"Class PriorityQueue&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#interface-comparablee-and-comparatore","text":"How do we compare elements in a PriorityQueue?","title":"Interface Comparable&lt;E&gt; and Comparator&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#interface-comparablee","text":"In many cases, we will insert objects that implement Comparable<E> and use their natural ordering as specified by method compareTo . Comparable<E> is used to define the natural ordering of an object type.","title":"Interface Comparable&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#interface-comparatore","text":"However, we may need to insert objects that do not implement Comparable<E> , or we may want to specify a different ordering from that defined by the object\u2019s compareTo method. For example, files to be printed may be ordered by their name using the compareTo method, but we may want to assign priority based on their length. The Java API contains the Comparator<E> interface, which allows us to specify alternative ways to compare objects. An implementer of the Comparator<E> interface must define a compare method that is similar to compareTo except that it has two parameters. public interface Comparator<T> { public int compare(T first, T second); } Example public class RectangleAreaComparator implements Comparator<Rectangle> { // compare in ascending order by area (WxH) public int compare(Rectangle r1, Rectangle r2) { return r1.getArea() - r2.getArea(); } }","title":"Interface Comparator&lt;E&gt;"},{"location":"data-structures/chp4-heaps-and-priority-queues/chp4-heaps-and-priority-queues.html#using-comparators","text":"TreeSet, TreeMap , PriorityQueue can use Comparator: java Comparator<Rectangle> comp = new RectangleAreaComparator(); Set<Rectangle> set = new TreeSet<Rectangle>(comp); Queue<Rectangle> pq = new PriorityQueue<Rectangle>(10,comp); Searching and sorting methods can accept Comparators. java Arrays.binarySearch(array, value, comparator) Arrays.sort(array, comparator) Collections.binarySearch(list, comparator) Collections.max(collection, comparator) Collections.min(collection, comparator) Collections.sort(list, comparator) Methods are provided to reverse a Comparator's ordering: java public static Comparator Collections.reverseOrder() public static Comparator Collections.reverseOrder(comparator) Example: Using Comparator for ordering a Priority Queue public class LengthComparator implements Comparator<String> { public int compare(String s1, String s2) { if (s1.length() != s2.length()) { // if lengths are unequal, compare by length return s1.length() - s2.length(); } else { // break ties by ABC order return s1.compareTo(s2); } } } Queue<String> pq = new PriorityQueue<String>(100, new LengthComparator()); Observe that, in the example, we are still making use of the fact that the class String is implementing Comparable<E> interface to define its own natural ordering by implementing compareTo method.","title":"Using Comparators"},{"location":"data-structures/chp5-sets-and-maps/5-1-sets.html","text":"1. Sets The Set Hierarchy Figure above shows the part of the Collections Framework that relates to sets. It includes interfaces Set , Sortedset , and Navigableset ; abstract class AbstractSet ; and actual classes HashSet , TreeSet , and ConcurrentSkipListSet . The HashSet is a set that is implemented using a hash table (discussed later). The TreeSet is implemented using a special kind of binary search tree, called the Red\u2013Black tree (discussed in future chapters). The ConcurrentSkipListSet is implemented using a skip list (discussed in future chapters). Interface java.util.Set Modifier and Type Method Description boolean add(E e) Adds the specified element to this set if it is not already present (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this set if they're not already present (optional operation). void clear() Removes all of the elements from this set (optional operation). boolean contains(Object o) Returns true if this set contains the specified element. boolean containsAll(Collection<?> c) Returns true if this set contains all of the elements of the specified collection. boolean equals(Object o) Compares the specified object with this set for equality. int hashCode() Returns the hash code value for this set. boolean isEmpty() Returns true if this set contains no elements. Iterator<E> iterator() Returns an iterator over the elements in this set. boolean remove(Object o) Removes the specified element from this set if it is present (optional operation). boolean removeAll(Collection<?> c) Removes from this set all of its elements that are contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this set that are contained in the specified collection (optional operation). int size() Returns the number of elements in this set (its cardinality). Object[] toArray() Returns an array containing all of the elements in this set. Comparison of List and Set Collections implementing the Set interface must contain unique elements. Unlike the List.add method, the Set.add method will return false if you attempt to insert a duplicate item. Unlike a List, a Set does not have a get method. Therefore, elements cannot be accessed by index. So if setA is a Set object, the method call setA.get(0) would cause the syntax error method get(int) not found. Although you can\u2019t reference a specific element of a Set, you can iterate through all its elements using an Iterator object. The loop below accesses each element of Set object setA. However, the elements will be accessed in arbitrary order. This means that they will not necessarily be accessed in the order in which they were inserted. HashSet vs TreeSet vs LinkedHashSet Features HashSet TreeSet LinkedHashSet Internal Working HashSet internally uses HashMap for storing objects TreeSet uses TreeMap internally to store objects LinkedHashSet uses LinkedHashMap internally to store objects When To Use If you don\u2019t want to maintain insertion order but want to store unique objects If you want to sort the elements according to some Comparator then use TreeSet If you want to maintain the insertion order of elements then you can use LinkedHashSet Order HashSet does not maintain insertion order While TreeSet orders the elements according to supplied Comparator. By default, objects will be placed according to their natural ascending order. LinkedHashSet maintains the insertion order of objects Complexity of Operations HashSet gives O(1) complexity for insertion, removing, and retrieving objects While TreeSet gives the performance of order O(log(n)) for insertion, removing, and retrieving operations. LinkedHashSet gives insertion, removing, and retrieving operations performance in order O(1). Performance The performance of HashSet is better when compared to LinkedHashSet and TreeSet. TreeSet performance is better than LinkedHashSet except for insertion and removal operations because it has to sort the elements after each insertion and removal operation. The performance of LinkedHashSet is slower than TreeSet. It is almost similar to HashSet but slower because LinkedHashSet internally maintains LinkedList to maintain the insertion order of elements Compare HashSet uses equals() and hashCode() methods to compare the objects TreeSet uses compare() and compareTo() methods to compare the objects LinkedHashSet uses equals() and hashCode() methods to compare it\u2019s objects Null Elements HashSet allows only one null value. TreeSet does not permit null value. If you insert null value into TreeSet, it will throw NullPointerException. LinkedHashSet allows only one null value. Syntax HashSet obj = new HashSet(); TreeSet obj = new TreeSet(); LinkedHashSet obj = new LinkedHashSet();","title":"Sets"},{"location":"data-structures/chp5-sets-and-maps/5-1-sets.html#1-sets","text":"","title":"1. Sets"},{"location":"data-structures/chp5-sets-and-maps/5-1-sets.html#the-set-hierarchy","text":"Figure above shows the part of the Collections Framework that relates to sets. It includes interfaces Set , Sortedset , and Navigableset ; abstract class AbstractSet ; and actual classes HashSet , TreeSet , and ConcurrentSkipListSet . The HashSet is a set that is implemented using a hash table (discussed later). The TreeSet is implemented using a special kind of binary search tree, called the Red\u2013Black tree (discussed in future chapters). The ConcurrentSkipListSet is implemented using a skip list (discussed in future chapters).","title":"The Set Hierarchy"},{"location":"data-structures/chp5-sets-and-maps/5-1-sets.html#interface-javautilset","text":"Modifier and Type Method Description boolean add(E e) Adds the specified element to this set if it is not already present (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this set if they're not already present (optional operation). void clear() Removes all of the elements from this set (optional operation). boolean contains(Object o) Returns true if this set contains the specified element. boolean containsAll(Collection<?> c) Returns true if this set contains all of the elements of the specified collection. boolean equals(Object o) Compares the specified object with this set for equality. int hashCode() Returns the hash code value for this set. boolean isEmpty() Returns true if this set contains no elements. Iterator<E> iterator() Returns an iterator over the elements in this set. boolean remove(Object o) Removes the specified element from this set if it is present (optional operation). boolean removeAll(Collection<?> c) Removes from this set all of its elements that are contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this set that are contained in the specified collection (optional operation). int size() Returns the number of elements in this set (its cardinality). Object[] toArray() Returns an array containing all of the elements in this set.","title":"Interface java.util.Set"},{"location":"data-structures/chp5-sets-and-maps/5-1-sets.html#comparison-of-list-and-set","text":"Collections implementing the Set interface must contain unique elements. Unlike the List.add method, the Set.add method will return false if you attempt to insert a duplicate item. Unlike a List, a Set does not have a get method. Therefore, elements cannot be accessed by index. So if setA is a Set object, the method call setA.get(0) would cause the syntax error method get(int) not found. Although you can\u2019t reference a specific element of a Set, you can iterate through all its elements using an Iterator object. The loop below accesses each element of Set object setA. However, the elements will be accessed in arbitrary order. This means that they will not necessarily be accessed in the order in which they were inserted.","title":"Comparison of List and Set"},{"location":"data-structures/chp5-sets-and-maps/5-1-sets.html#hashset-vs-treeset-vs-linkedhashset","text":"Features HashSet TreeSet LinkedHashSet Internal Working HashSet internally uses HashMap for storing objects TreeSet uses TreeMap internally to store objects LinkedHashSet uses LinkedHashMap internally to store objects When To Use If you don\u2019t want to maintain insertion order but want to store unique objects If you want to sort the elements according to some Comparator then use TreeSet If you want to maintain the insertion order of elements then you can use LinkedHashSet Order HashSet does not maintain insertion order While TreeSet orders the elements according to supplied Comparator. By default, objects will be placed according to their natural ascending order. LinkedHashSet maintains the insertion order of objects Complexity of Operations HashSet gives O(1) complexity for insertion, removing, and retrieving objects While TreeSet gives the performance of order O(log(n)) for insertion, removing, and retrieving operations. LinkedHashSet gives insertion, removing, and retrieving operations performance in order O(1). Performance The performance of HashSet is better when compared to LinkedHashSet and TreeSet. TreeSet performance is better than LinkedHashSet except for insertion and removal operations because it has to sort the elements after each insertion and removal operation. The performance of LinkedHashSet is slower than TreeSet. It is almost similar to HashSet but slower because LinkedHashSet internally maintains LinkedList to maintain the insertion order of elements Compare HashSet uses equals() and hashCode() methods to compare the objects TreeSet uses compare() and compareTo() methods to compare the objects LinkedHashSet uses equals() and hashCode() methods to compare it\u2019s objects Null Elements HashSet allows only one null value. TreeSet does not permit null value. If you insert null value into TreeSet, it will throw NullPointerException. LinkedHashSet allows only one null value. Syntax HashSet obj = new HashSet(); TreeSet obj = new TreeSet(); LinkedHashSet obj = new LinkedHashSet();","title":"HashSet vs TreeSet vs LinkedHashSet"},{"location":"data-structures/chp5-sets-and-maps/5-2-maps.html","text":"2. Maps The Map Hierarchy Figure below shows part of the Map hierarchy in the Java API . Although not strictly part of the Collection hierarchy, the Map interface defines a structure that relates elements in one set to elements in another set. The first set, called the keys, must implement the Set interface; that is, the keys are unique. The second set is not strictly a Set but an arbitrary Collection known as the values. These are not required to be unique. The Map is a more useful structure than the Set . In fact, the Java API implements the Set using a Map . The TreeMap uses a Red\u2013Black binary search tree (discussed in future chapters) as its underlying data structure, and the ConcurrentSkipListMap uses a skip list (discussed in future chapters) as its underlying data structure. We will focus on the HashMap and show how to implement it later in the chapter. Interface java.util.Map Modifier and Type Method Description void clear() Removes all of the mappings from this map (optional operation). boolean containsKey(Object key) Returns true if this map contains a mapping for the specified key. boolean containsValue(Object value) Returns true if this map maps one or more keys to the specified value. Set<Map.Entry<K, V>> entrySet() Returns a Set view of the mappings contained in this map. boolean equals(Object o) Compares the specified object with this map for equality. default void forEach(BiConsumer<? super K, ? super V> action) Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. V get(Object key) Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. default V getOrDefault(Object key, V defaultValue) Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key. int hashCode() Returns the hash code value for this map. boolean isEmpty() Returns true if this map contains no key-value mappings. Set<K> keySet() Returns a Set view of the keys contained in this map. default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. V put(K key, V value) Associates the specified value with the specified key in this map (optional operation). void putAll(Map<? extends K, ? extends V> m) Copies all of the mappings from the specified map to this map (optional operation). default V putIfAbsent(K key, V value) If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value. V remove(Object key) Removes the mapping for a key from this map if it is present (optional operation). default boolean remove(Object key, Object value) Removes the entry for the specified key only if it is currently mapped to the specified value. default V replace(K key, V value) Replaces the entry for the specified key only if it is currently mapped to some value. default boolean replace(K key, V oldValue, V newValue) Replaces the entry for the specified key only if currently mapped to the specified value. default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. int size() Returns the number of key-value mappings in this map. Collection<V> values() Returns a Collection view of the values contained in this map.","title":"Maps"},{"location":"data-structures/chp5-sets-and-maps/5-2-maps.html#2-maps","text":"","title":"2. Maps"},{"location":"data-structures/chp5-sets-and-maps/5-2-maps.html#the-map-hierarchy","text":"Figure below shows part of the Map hierarchy in the Java API . Although not strictly part of the Collection hierarchy, the Map interface defines a structure that relates elements in one set to elements in another set. The first set, called the keys, must implement the Set interface; that is, the keys are unique. The second set is not strictly a Set but an arbitrary Collection known as the values. These are not required to be unique. The Map is a more useful structure than the Set . In fact, the Java API implements the Set using a Map . The TreeMap uses a Red\u2013Black binary search tree (discussed in future chapters) as its underlying data structure, and the ConcurrentSkipListMap uses a skip list (discussed in future chapters) as its underlying data structure. We will focus on the HashMap and show how to implement it later in the chapter.","title":"The Map Hierarchy"},{"location":"data-structures/chp5-sets-and-maps/5-2-maps.html#interface-javautilmap","text":"Modifier and Type Method Description void clear() Removes all of the mappings from this map (optional operation). boolean containsKey(Object key) Returns true if this map contains a mapping for the specified key. boolean containsValue(Object value) Returns true if this map maps one or more keys to the specified value. Set<Map.Entry<K, V>> entrySet() Returns a Set view of the mappings contained in this map. boolean equals(Object o) Compares the specified object with this map for equality. default void forEach(BiConsumer<? super K, ? super V> action) Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. V get(Object key) Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. default V getOrDefault(Object key, V defaultValue) Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key. int hashCode() Returns the hash code value for this map. boolean isEmpty() Returns true if this map contains no key-value mappings. Set<K> keySet() Returns a Set view of the keys contained in this map. default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. V put(K key, V value) Associates the specified value with the specified key in this map (optional operation). void putAll(Map<? extends K, ? extends V> m) Copies all of the mappings from the specified map to this map (optional operation). default V putIfAbsent(K key, V value) If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value. V remove(Object key) Removes the mapping for a key from this map if it is present (optional operation). default boolean remove(Object key, Object value) Removes the entry for the specified key only if it is currently mapped to the specified value. default V replace(K key, V value) Replaces the entry for the specified key only if it is currently mapped to some value. default boolean replace(K key, V oldValue, V newValue) Replaces the entry for the specified key only if currently mapped to the specified value. default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. int size() Returns the number of key-value mappings in this map. Collection<V> values() Returns a Collection view of the values contained in this map.","title":"Interface java.util.Map"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html","text":"3. Hash Tables Before we discuss the details of implementing the required methods of the Set and Map interfaces, we will describe a data structure, the hash table, that can be used as the basis for such an implementation. Using a hash table enables us to retrieve an item in constant time (expected O(1)). We say expected O(1) rather than just O(1) because there will be some cases where the performance will be much worse than O(1) and may even be O(n), but on the average, we expect that it will be O(1). Properties of Hash Functions Simple and efficient to compute Provides a large set of possible values to map domain Should provide an (almost) equal distribution (mapping) of values The probability of two distinct items to generate the same hash value should be as low as possible Open Addressing Two ways to organize a hash tables: open addressing chaining Procedure: Open Addressing Each hash table element (type Object) references a single key\u2013value pair. We can use the following simple approach (called linear probing ) to access an item in a hash table. If the index calculated for an item\u2019s key is occupied by an item with that key, we have found the item. If that element contains an item with a different key, we increment the index by 1. We keep incrementing the index (modulo the table length) until either we find the key we are seeking or we reach a null entry. A null entry indicates that the key is not in the table. Algorithm For Accessing an Item in a Hash Table Compute the index by taking the item\u2019s hashCode() % table.length. if table[index] is null The item is not in the table. else if table[index] is equal to the item The item is in the table. else Continue to search the table by incrementing the index until either the item is found or a null entry is found. Table Wraparound and Search Termination Note that as you increment the table index, your table should wrap around (as in a circular array) so that the element with subscript 0 \u201cfollows\u201d the element with subscript table.length \u2010 1. This enables you to use the entire table, not just the part with subscripts larger than the hash code value, but it leads to the potential for an infinite loop in Step 6 of the algorithm. If the table is full and the objects examined so far do not match the one you are seeking, how do you know when to stop? One approach would be to stop when the index value for the next probe is the same as the hash code value for the object. This means that you have come full circle to the starting value for the index. A second approach would be to ensure that the table is never full by increasing its size after an insertion if its occupancy rate exceeds a specifieif its occupancy rate exceeds a specified thresholdd threshold . This is the approach that we take in our implementation. Traversing a Hash Table One thing that you cannot do is traverse a hash table in a meaningful way. Deleting an Item Using Open Addressing When an item is deleted, we cannot just set its table entry to null . If we do, then when we search for an item that may have collided with the deleted item, we may incorrectly conclude that the item is not in the table. (Because the item that collided was inserted after the deleted item, we will have stopped our search prematurely.) By storing a dummy value when an item is deleted, we force the search algorithm to keep looking until either the desired item is found or a null value, representing a free cell, is located. Although the use of a dummy value solves the problem, keep in mind that it can lead to search inefficiency, particularly when there are many deletions. Removing items from the table does not reduce the search time because the dummy value is still in the table and is part of a search chain. In fact, you cannot even replace a deleted value with a new item because you still need to go to the end of the search chain to ensure that the new item is not already present in the table. So deleted items waste storage space and reduce search efficiency. In the worst case, if the table is almost full and then most of the items are deleted, you will have O(n) performance when searching for the few items remaining in the table. Reducing Collisions by Expanding the Table Size The first step in reducing these collisions is to use a prime number for the size of the table. In addition, the probability of a collision is proportional to how full the table is. Therefore, when the hash table becomes sufficiently full, a larger table should be allocated and the entries reinserted. You expand a hash table using an algorithm called rehashing . Algorithm For Rehashing 1. Allocate a new hash table with twice the capacity of the original. 2. Reinsert each old table entry that has not been deleted into the new hash table. 3. Reference the new table instead of the original. Reducing Collisions Using Quadratic Probing The problem with linear probing is that it tends to form clusters of keys in the table, causing longer search chains. One approach to reduce the effect of clustering is to use quadratic probing instead of linear probing . In quadratic probing, the increments form a quadratic series (1 + 2^2 + 3^2 + \u00b7 \u00b7 \u00b7) . probeNum++; index = (startIndex + probeNum * probeNum) % table.length Problems with Quadratic Probing One disadvantage of quadratic probing is that the next index calculation is a bit time\u2010consuming as it involves a multiplication, an addition, and a modulo division. A more efficient way to calculate the next index follows: java k += 2; index = (index + k) % table.length; A more serious problem with quadratic probing is that not all table elements are examined when looking for an insertion index, so it is possible that an item can\u2019t be inserted even when the table is not full. It is also possible that your program can get stuck in an infinite loop while searching for an empty slot. It can be proved that if the table size is a prime number and the table is never more than half full, this can\u2019t happen. However, requiring that the table be half empty at all times wastes quite a bit of memory. For these reasons, we will use linear probing in our implementation. Chaining An alternative to open addressing is a technique called chaining , in which each table element references a linked list that contains all the items that hash to the same table index. This linked list is often called a bucket , and this approach is sometimes called bucket hashing . Instead of incrementing the table index to access the next item with a particular hash code value, you traverse the linked list referenced by the table element with index hashCode() % table.length . One advantage of chaining is that only items that have the same value for hashCode() % table. length will be examined when looking for an object. In open addressing, search chains can overlap, so a search chain may include items in the table that have different starting index values. A second advantage is that you can store more elements in the table than the number of table slots (indexes), which is not the case for open addressing. To delete an item, simply remove it from the list. In contrast to open addressing, removing an item actually deletes it, so it will not be part of future search chains. Performance of Hash Tables load factor : The number of filled cells divided by table size. The load factor has the greatest effect on hash table performance. Lower the load factor the better the performance because there is less chance of collision. If there are no collisions, the performance for search and retrieval is O(1) . Performance of Open Addressing versus Chaining Expected number of comparisons, c, for open addressing with linear probing and a load factor L: c = \\dfrac{1}{2}(1 + \\dfrac{1}{1 - L}) L = number of filled cells/table size Expected number of comparisons, c, for chaining and a load factor L (L is average number of items in a list here = # of items divided by table size: c = 1 + \\dfrac{L}{2} For values of L between 0.0 and 0.75, the results for chaining are similar to those of linear probing. But chaining gives better performance than linear probing for higher load factors. Quadratic probing gives performance that is between those of linear probing and chaining. Performance of Hash Tables versus Sorted Arrays and Binary Trees The performance of hashing is certainly preferable to that of binary search of an array (or a binary search tree), particularly if L is less than 0.75. However, the trade-off is that the lower the load factor, the more unfilled storage cells there are in a hash table, whereas there are no empty cells in a sorted array. Because a binary search tree requires three references per node (the item, the left subtree, and the right subtrees), more storage would be required for a binary search tree than for a hash table with a load factor of 0.75. Storage Requirements for Open Addressing and Chaining Next, we consider the effect of chaining on storage requirements. For a table with a load factor of L, the number of table elements required is n (the size of the table). For open addressing, the number of references to an item (a key\u2013value pair) is n. For chaining, the average number of nodes in a list is L . If we use the Java API LinkedList , there will be three references in each node (the item, the next list element, and the previous element). However, we could use our own single\u2010linked list and eliminate the previous\u2010element reference (at some time cost for deletions). Therefore, we will require storage for n + n*2L references. Implementing the Hash Table Interface IHashMap package datastructures.setmap; public interface IHashMap<K, V> { V get(Object key); boolean isEmpty(); V put(K key, V value); V remove(Object key); int size(); } Class HashTableOpen package datastructures.setmap; /** Hash table implementation using open addressing. */ public class HashTableOpen<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } // Data Fields private Entry<K, V>[] table; private static final int START_CAPACITY = 101; private double LOAD_THRESHOLD = 0.75; private int numKeys; private int numDeletes; private final Entry<K, V> DELETED = new Entry<>(null, null); // Constructor public HashTableOpen() { table = new Entry[START_CAPACITY]; } /** Finds either the target key or the first empty slot in the search chain using linear probing. @pre The table is not full. @param key The key of the target object @return The position of the target or the first empty slot if the target is not in the table. */ private int find(Object key) { // Calculate the starting index. int index = key.hashCode() % table.length; if (index < 0) index += table.length; // Make it positive. // Increment index until an empty slot is reached or the key is found. while ((table[index] != null) && (!key.equals(table[index].getKey()))) { index++; // Check for wraparound. if (index >= table.length) index = 0; // Wrap around. } return index; } /** Method get for class HashtableOpen. @param key The key being sought @return the value associated with this key if found; otherwise, null */ @Override public V get(Object key) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If the search is successful, return the value. if (table[index] != null) return table[index].getValue(); else return null; // key not found. } /** Method put for class HashtableOpen. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. If the LOAD_THRESHOLD is exceeded, the table is expanded. @param key The key of item being inserted @param value The value for this key @return Old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If an empty element was found, insert new entry. if (table[index] == null) { table[index] = new Entry<>(key, value); numKeys++; // Check whether rehash is needed. double loadFactor = (double) (numKeys + numDeletes) / table.length; if (loadFactor > LOAD_THRESHOLD) rehash(); return null; } // assert: table element that contains the key was found. // Replace value for this key. V oldVal = table[index].getValue(); table[index].setValue(value); return oldVal; } @Override public V remove(Object key) { // Find the first table element that is empty or the table element that contains the key. int index = find(key); // if an empty element was found return null if(table[index] == null || table[index] == this.DELETED){ return null; } // Key was found. Remove this table element by setting it to reference DELETED, increment // numDeletes, and decrement numKeys. V oldVal = table[index].getValue(); table[index] = this.DELETED; this.numDeletes++; this.numKeys--; // Return the value associated with this key. return oldVal; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } /** Expands table size when loadFactor exceeds LOAD_THRESHOLD @post The size of the table is doubled and is an odd integer. Each nondeleted entry from the original table is reinserted into the expanded table. The value of numKeys is reset to the number of items actually inserted; numDeletes is reset to 0. */ private void rehash() { // Save a reference to oldTable. Entry<K, V>[] oldTable = table; // Double capacity of this table. table = new Entry[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. numKeys = 0; numDeletes = 0; for (int i = 0; i < oldTable.length; i++) { if ((oldTable[i] != null) && (oldTable[i] != DELETED)) { // Insert entry in expanded table put(oldTable[i].getKey(), oldTable[i].getValue()); } } } } Class HashTableChain package datastructures.setmap; import java.util.*; /** Hash table implementation using chaining. */ public class HashTableChain<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } /** The table */ private LinkedList<Entry<K, V>>[] table; /** The number of keys */ private int numKeys; /** The capacity */ private static final int CAPACITY = 101; /** The maximum load factor */ private static final double LOAD_THRESHOLD = 3.0; // Constructor public HashTableChain() { table = new LinkedList[CAPACITY]; } /** Method get for class HashtableChain. @param key The key being sought @return The value associated with this key if found; otherwise, null */ @Override public V get(Object key) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) return null; // key is not in the table. // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { if (nextItem.getKey().equals(key)) return nextItem.getValue(); } // assert: key is not in the table. return null; } /** Method put for class HashtableChain. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. @param key The key of item being inserted @param value The value for this key @return The old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { // If the search is successful, replace the old value. if (nextItem.getKey().equals(key)) { // Replace value for this key. V oldVal = nextItem.getValue(); nextItem.setValue(value); return oldVal; } } // assert: key is not in the table, add new item. table[index].addFirst(new Entry<>(key, value)); numKeys++; if (numKeys > (LOAD_THRESHOLD * table.length)) rehash(); return null; } @Override public V remove(Object key) { // Set index to key.hashCode() % table.length. // if index is negative, add table.length. int index = key.hashCode() % table.length; if(index < 0){ index += table.length; } // if table[index] is null // key is not in the table; return null. if(table[index] == null){ return null; } for(int i = 0 ; i < table[index].size(); i++){ //Search the list at table[index] to find the key. if(table[index].get(i).getKey() == key){ V oldVal = table[index].get(i).getValue(); // if the search is successful // Remove the entry with this key and decrement numKeys. table[index].remove(i); this.numKeys--; //if the list at table[index] is empty //Set table[index] to null. if(table[index].isEmpty()){ table[index] = null; } //Return the value associated with this key. return oldVal; } } //The key is not in the table; return null. return null; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } private void rehash() { // Save a reference to oldTable. LinkedList<Entry<K, V>>[] oldTable = table; // Double capacity of this table. table = new LinkedList[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. this.numKeys = 0; for (LinkedList<Entry<K, V>> entries : oldTable) { for (Entry<K, V> entry : entries) { int index = entry.getKey().hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } table[index].add(entry); this.numKeys++; } } } }","title":"Hash Tables"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#3-hash-tables","text":"Before we discuss the details of implementing the required methods of the Set and Map interfaces, we will describe a data structure, the hash table, that can be used as the basis for such an implementation. Using a hash table enables us to retrieve an item in constant time (expected O(1)). We say expected O(1) rather than just O(1) because there will be some cases where the performance will be much worse than O(1) and may even be O(n), but on the average, we expect that it will be O(1). Properties of Hash Functions Simple and efficient to compute Provides a large set of possible values to map domain Should provide an (almost) equal distribution (mapping) of values The probability of two distinct items to generate the same hash value should be as low as possible","title":"3. Hash Tables"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#open-addressing","text":"Two ways to organize a hash tables: open addressing chaining Procedure: Open Addressing Each hash table element (type Object) references a single key\u2013value pair. We can use the following simple approach (called linear probing ) to access an item in a hash table. If the index calculated for an item\u2019s key is occupied by an item with that key, we have found the item. If that element contains an item with a different key, we increment the index by 1. We keep incrementing the index (modulo the table length) until either we find the key we are seeking or we reach a null entry. A null entry indicates that the key is not in the table. Algorithm For Accessing an Item in a Hash Table Compute the index by taking the item\u2019s hashCode() % table.length. if table[index] is null The item is not in the table. else if table[index] is equal to the item The item is in the table. else Continue to search the table by incrementing the index until either the item is found or a null entry is found.","title":"Open Addressing"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#table-wraparound-and-search-termination","text":"Note that as you increment the table index, your table should wrap around (as in a circular array) so that the element with subscript 0 \u201cfollows\u201d the element with subscript table.length \u2010 1. This enables you to use the entire table, not just the part with subscripts larger than the hash code value, but it leads to the potential for an infinite loop in Step 6 of the algorithm. If the table is full and the objects examined so far do not match the one you are seeking, how do you know when to stop? One approach would be to stop when the index value for the next probe is the same as the hash code value for the object. This means that you have come full circle to the starting value for the index. A second approach would be to ensure that the table is never full by increasing its size after an insertion if its occupancy rate exceeds a specifieif its occupancy rate exceeds a specified thresholdd threshold . This is the approach that we take in our implementation.","title":"Table Wraparound and Search Termination"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#traversing-a-hash-table","text":"One thing that you cannot do is traverse a hash table in a meaningful way.","title":"Traversing a Hash Table"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#deleting-an-item-using-open-addressing","text":"When an item is deleted, we cannot just set its table entry to null . If we do, then when we search for an item that may have collided with the deleted item, we may incorrectly conclude that the item is not in the table. (Because the item that collided was inserted after the deleted item, we will have stopped our search prematurely.) By storing a dummy value when an item is deleted, we force the search algorithm to keep looking until either the desired item is found or a null value, representing a free cell, is located. Although the use of a dummy value solves the problem, keep in mind that it can lead to search inefficiency, particularly when there are many deletions. Removing items from the table does not reduce the search time because the dummy value is still in the table and is part of a search chain. In fact, you cannot even replace a deleted value with a new item because you still need to go to the end of the search chain to ensure that the new item is not already present in the table. So deleted items waste storage space and reduce search efficiency. In the worst case, if the table is almost full and then most of the items are deleted, you will have O(n) performance when searching for the few items remaining in the table.","title":"Deleting an Item Using Open Addressing"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#reducing-collisions-by-expanding-the-table-size","text":"The first step in reducing these collisions is to use a prime number for the size of the table. In addition, the probability of a collision is proportional to how full the table is. Therefore, when the hash table becomes sufficiently full, a larger table should be allocated and the entries reinserted. You expand a hash table using an algorithm called rehashing . Algorithm For Rehashing 1. Allocate a new hash table with twice the capacity of the original. 2. Reinsert each old table entry that has not been deleted into the new hash table. 3. Reference the new table instead of the original.","title":"Reducing Collisions by Expanding the Table Size"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#reducing-collisions-using-quadratic-probing","text":"The problem with linear probing is that it tends to form clusters of keys in the table, causing longer search chains. One approach to reduce the effect of clustering is to use quadratic probing instead of linear probing . In quadratic probing, the increments form a quadratic series (1 + 2^2 + 3^2 + \u00b7 \u00b7 \u00b7) . probeNum++; index = (startIndex + probeNum * probeNum) % table.length Problems with Quadratic Probing One disadvantage of quadratic probing is that the next index calculation is a bit time\u2010consuming as it involves a multiplication, an addition, and a modulo division. A more efficient way to calculate the next index follows: java k += 2; index = (index + k) % table.length; A more serious problem with quadratic probing is that not all table elements are examined when looking for an insertion index, so it is possible that an item can\u2019t be inserted even when the table is not full. It is also possible that your program can get stuck in an infinite loop while searching for an empty slot. It can be proved that if the table size is a prime number and the table is never more than half full, this can\u2019t happen. However, requiring that the table be half empty at all times wastes quite a bit of memory. For these reasons, we will use linear probing in our implementation.","title":"Reducing Collisions Using Quadratic Probing"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#chaining","text":"An alternative to open addressing is a technique called chaining , in which each table element references a linked list that contains all the items that hash to the same table index. This linked list is often called a bucket , and this approach is sometimes called bucket hashing . Instead of incrementing the table index to access the next item with a particular hash code value, you traverse the linked list referenced by the table element with index hashCode() % table.length . One advantage of chaining is that only items that have the same value for hashCode() % table. length will be examined when looking for an object. In open addressing, search chains can overlap, so a search chain may include items in the table that have different starting index values. A second advantage is that you can store more elements in the table than the number of table slots (indexes), which is not the case for open addressing. To delete an item, simply remove it from the list. In contrast to open addressing, removing an item actually deletes it, so it will not be part of future search chains.","title":"Chaining"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#performance-of-hash-tables","text":"load factor : The number of filled cells divided by table size. The load factor has the greatest effect on hash table performance. Lower the load factor the better the performance because there is less chance of collision. If there are no collisions, the performance for search and retrieval is O(1) . Performance of Open Addressing versus Chaining Expected number of comparisons, c, for open addressing with linear probing and a load factor L: c = \\dfrac{1}{2}(1 + \\dfrac{1}{1 - L}) L = number of filled cells/table size Expected number of comparisons, c, for chaining and a load factor L (L is average number of items in a list here = # of items divided by table size: c = 1 + \\dfrac{L}{2} For values of L between 0.0 and 0.75, the results for chaining are similar to those of linear probing. But chaining gives better performance than linear probing for higher load factors. Quadratic probing gives performance that is between those of linear probing and chaining. Performance of Hash Tables versus Sorted Arrays and Binary Trees The performance of hashing is certainly preferable to that of binary search of an array (or a binary search tree), particularly if L is less than 0.75. However, the trade-off is that the lower the load factor, the more unfilled storage cells there are in a hash table, whereas there are no empty cells in a sorted array. Because a binary search tree requires three references per node (the item, the left subtree, and the right subtrees), more storage would be required for a binary search tree than for a hash table with a load factor of 0.75. Storage Requirements for Open Addressing and Chaining Next, we consider the effect of chaining on storage requirements. For a table with a load factor of L, the number of table elements required is n (the size of the table). For open addressing, the number of references to an item (a key\u2013value pair) is n. For chaining, the average number of nodes in a list is L . If we use the Java API LinkedList , there will be three references in each node (the item, the next list element, and the previous element). However, we could use our own single\u2010linked list and eliminate the previous\u2010element reference (at some time cost for deletions). Therefore, we will require storage for n + n*2L references.","title":"Performance of Hash Tables"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#implementing-the-hash-table","text":"","title":"Implementing the Hash Table"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#interface-ihashmap","text":"package datastructures.setmap; public interface IHashMap<K, V> { V get(Object key); boolean isEmpty(); V put(K key, V value); V remove(Object key); int size(); }","title":"Interface IHashMap"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#class-hashtableopen","text":"package datastructures.setmap; /** Hash table implementation using open addressing. */ public class HashTableOpen<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } // Data Fields private Entry<K, V>[] table; private static final int START_CAPACITY = 101; private double LOAD_THRESHOLD = 0.75; private int numKeys; private int numDeletes; private final Entry<K, V> DELETED = new Entry<>(null, null); // Constructor public HashTableOpen() { table = new Entry[START_CAPACITY]; } /** Finds either the target key or the first empty slot in the search chain using linear probing. @pre The table is not full. @param key The key of the target object @return The position of the target or the first empty slot if the target is not in the table. */ private int find(Object key) { // Calculate the starting index. int index = key.hashCode() % table.length; if (index < 0) index += table.length; // Make it positive. // Increment index until an empty slot is reached or the key is found. while ((table[index] != null) && (!key.equals(table[index].getKey()))) { index++; // Check for wraparound. if (index >= table.length) index = 0; // Wrap around. } return index; } /** Method get for class HashtableOpen. @param key The key being sought @return the value associated with this key if found; otherwise, null */ @Override public V get(Object key) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If the search is successful, return the value. if (table[index] != null) return table[index].getValue(); else return null; // key not found. } /** Method put for class HashtableOpen. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. If the LOAD_THRESHOLD is exceeded, the table is expanded. @param key The key of item being inserted @param value The value for this key @return Old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If an empty element was found, insert new entry. if (table[index] == null) { table[index] = new Entry<>(key, value); numKeys++; // Check whether rehash is needed. double loadFactor = (double) (numKeys + numDeletes) / table.length; if (loadFactor > LOAD_THRESHOLD) rehash(); return null; } // assert: table element that contains the key was found. // Replace value for this key. V oldVal = table[index].getValue(); table[index].setValue(value); return oldVal; } @Override public V remove(Object key) { // Find the first table element that is empty or the table element that contains the key. int index = find(key); // if an empty element was found return null if(table[index] == null || table[index] == this.DELETED){ return null; } // Key was found. Remove this table element by setting it to reference DELETED, increment // numDeletes, and decrement numKeys. V oldVal = table[index].getValue(); table[index] = this.DELETED; this.numDeletes++; this.numKeys--; // Return the value associated with this key. return oldVal; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } /** Expands table size when loadFactor exceeds LOAD_THRESHOLD @post The size of the table is doubled and is an odd integer. Each nondeleted entry from the original table is reinserted into the expanded table. The value of numKeys is reset to the number of items actually inserted; numDeletes is reset to 0. */ private void rehash() { // Save a reference to oldTable. Entry<K, V>[] oldTable = table; // Double capacity of this table. table = new Entry[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. numKeys = 0; numDeletes = 0; for (int i = 0; i < oldTable.length; i++) { if ((oldTable[i] != null) && (oldTable[i] != DELETED)) { // Insert entry in expanded table put(oldTable[i].getKey(), oldTable[i].getValue()); } } } }","title":"Class HashTableOpen"},{"location":"data-structures/chp5-sets-and-maps/5-3-hash-tables.html#class-hashtablechain","text":"package datastructures.setmap; import java.util.*; /** Hash table implementation using chaining. */ public class HashTableChain<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } /** The table */ private LinkedList<Entry<K, V>>[] table; /** The number of keys */ private int numKeys; /** The capacity */ private static final int CAPACITY = 101; /** The maximum load factor */ private static final double LOAD_THRESHOLD = 3.0; // Constructor public HashTableChain() { table = new LinkedList[CAPACITY]; } /** Method get for class HashtableChain. @param key The key being sought @return The value associated with this key if found; otherwise, null */ @Override public V get(Object key) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) return null; // key is not in the table. // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { if (nextItem.getKey().equals(key)) return nextItem.getValue(); } // assert: key is not in the table. return null; } /** Method put for class HashtableChain. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. @param key The key of item being inserted @param value The value for this key @return The old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { // If the search is successful, replace the old value. if (nextItem.getKey().equals(key)) { // Replace value for this key. V oldVal = nextItem.getValue(); nextItem.setValue(value); return oldVal; } } // assert: key is not in the table, add new item. table[index].addFirst(new Entry<>(key, value)); numKeys++; if (numKeys > (LOAD_THRESHOLD * table.length)) rehash(); return null; } @Override public V remove(Object key) { // Set index to key.hashCode() % table.length. // if index is negative, add table.length. int index = key.hashCode() % table.length; if(index < 0){ index += table.length; } // if table[index] is null // key is not in the table; return null. if(table[index] == null){ return null; } for(int i = 0 ; i < table[index].size(); i++){ //Search the list at table[index] to find the key. if(table[index].get(i).getKey() == key){ V oldVal = table[index].get(i).getValue(); // if the search is successful // Remove the entry with this key and decrement numKeys. table[index].remove(i); this.numKeys--; //if the list at table[index] is empty //Set table[index] to null. if(table[index].isEmpty()){ table[index] = null; } //Return the value associated with this key. return oldVal; } } //The key is not in the table; return null. return null; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } private void rehash() { // Save a reference to oldTable. LinkedList<Entry<K, V>>[] oldTable = table; // Double capacity of this table. table = new LinkedList[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. this.numKeys = 0; for (LinkedList<Entry<K, V>> entries : oldTable) { for (Entry<K, V> entry : entries) { int index = entry.getKey().hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } table[index].add(entry); this.numKeys++; } } } }","title":"Class HashTableChain"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html","text":"4. Implementation Considerations for Maps and Sets Methods hashCode and equals Method Object.equals compares two objects based on their addresses, not their contents. Similarly, method Object.hashCode calculates an object\u2019s hash code based on its address, not its contents. Most predefined classes (e.g., String and Integer) override method equals and method hashCode . If you override the equals method, Java recommends you also override the hashCode method. Otherwise, your class will violate the Java contract for hashCode , which states: java if obj1.equals(obj2) is true, then obj1.hashCode() == obj2.hashCode(). Implementing HashSetOpen We can modify the hash table methods to implement a hash set. Table below compares corresponding Map and Set methods. Map Method Set Method V get(Object key) boolean contains(Object key) V put(K key, V value) boolean add(K key) V remove(Object key) boolean remove(Object key) Writing HashSetOpen as an Adapter Class Instead of writing new methods from scratch, we can implement HashSetOpen as an adapter class with the data field. private final IHashMap<K, V> setMap = new HashtableOpen<>(); We can write methods contains, add, and remove as follows. Because the map stores key\u2013value pairs, we will have each set element reference an Entry object with the same key and value. Implementing the Java Map and Set Interfaces Java API uses a hash table to implement both the Map and Set interfaces (class HashMap and class HashSet ). The task of implementing these interfaces is simplified by the inclusion of abstract classes AbstractMap and AbstractSet in the Collections framework. These classes provide implementations of several methods for the Map and Set interfaces. So if class HashTableOpen extends class AbstractMap , we can reduce the amount of additional work we need to do. We should also replace IHashMap with Map . Thus, the declaration for HashTableOpen would be class HashTableOpen<K, V> extends AbstractMap<K, V> implements Map<K, V> . The AbstractMap provides relatively inefficient O(n) implementations of the get and put methods. Because we overrode these methods in both our implementations ( HashTableOpen and HashTableChain ), we will get O(1) expected performance. There are other, less critical methods that we don\u2019t need to provide because they are implemented in AbstractMap or its superclasses, such as clear , isEmpty , putAll , equals , hashCode , and toString . Interface Map.Entry and Class AbstractMap.SimpleEntry One requirement on the key\u2013value pairs for a Map object is that they implement the interface Map.Entry<K, V> , which is an inner interface of interface Map . This may sound a bit confusing, but what it means is that an implementer of the Map interface must contain an inner class Entry . The AbstractMap includes the inner class SimpleEntry that implements the Map.Entry interface. We can remove the inner class Entry<K, V> and replace new Entry with new SimpleEntry . Creating a Set View of a Map Method entrySet creates a set view of the entries in a Map. This means that method entrySet returns an object that implements the Set interface\u2014that is, a set. Classes TreeMap and TreeSet Besides HashMap and HashSet , the Java Collections Framework provides classes TreeMap and TreeSet that implement the Map and Set interfaces. These classes use a Red\u2013Black tree , which is a balanced binary search tree. We discussed earlier that the performances for search, retrieval, insertion, and removal operations are better for a hash table than for a binary search tree (expected O(1) versus O(log n)). However, the primary advantage of a binary search tree is that it can be traversed in sorted order. Hash tables, however, can\u2019t be traversed in any meaningful way. Also, subsets based on a range of key values can be selected using a TreeMap but not by using a HashMap","title":"Implementation Considerations"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#4-implementation-considerations-for-maps-and-sets","text":"","title":"4. Implementation Considerations for Maps and Sets"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#methods-hashcode-and-equals","text":"Method Object.equals compares two objects based on their addresses, not their contents. Similarly, method Object.hashCode calculates an object\u2019s hash code based on its address, not its contents. Most predefined classes (e.g., String and Integer) override method equals and method hashCode . If you override the equals method, Java recommends you also override the hashCode method. Otherwise, your class will violate the Java contract for hashCode , which states: java if obj1.equals(obj2) is true, then obj1.hashCode() == obj2.hashCode().","title":"Methods hashCode and equals"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#implementing-hashsetopen","text":"We can modify the hash table methods to implement a hash set. Table below compares corresponding Map and Set methods. Map Method Set Method V get(Object key) boolean contains(Object key) V put(K key, V value) boolean add(K key) V remove(Object key) boolean remove(Object key)","title":"Implementing HashSetOpen"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#writing-hashsetopen-as-an-adapter-class","text":"Instead of writing new methods from scratch, we can implement HashSetOpen as an adapter class with the data field. private final IHashMap<K, V> setMap = new HashtableOpen<>(); We can write methods contains, add, and remove as follows. Because the map stores key\u2013value pairs, we will have each set element reference an Entry object with the same key and value.","title":"Writing HashSetOpen as an Adapter Class"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#implementing-the-java-map-and-set-interfaces","text":"Java API uses a hash table to implement both the Map and Set interfaces (class HashMap and class HashSet ). The task of implementing these interfaces is simplified by the inclusion of abstract classes AbstractMap and AbstractSet in the Collections framework. These classes provide implementations of several methods for the Map and Set interfaces. So if class HashTableOpen extends class AbstractMap , we can reduce the amount of additional work we need to do. We should also replace IHashMap with Map . Thus, the declaration for HashTableOpen would be class HashTableOpen<K, V> extends AbstractMap<K, V> implements Map<K, V> . The AbstractMap provides relatively inefficient O(n) implementations of the get and put methods. Because we overrode these methods in both our implementations ( HashTableOpen and HashTableChain ), we will get O(1) expected performance. There are other, less critical methods that we don\u2019t need to provide because they are implemented in AbstractMap or its superclasses, such as clear , isEmpty , putAll , equals , hashCode , and toString .","title":"Implementing the Java Map and Set Interfaces"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#interface-mapentry-and-class-abstractmapsimpleentry","text":"One requirement on the key\u2013value pairs for a Map object is that they implement the interface Map.Entry<K, V> , which is an inner interface of interface Map . This may sound a bit confusing, but what it means is that an implementer of the Map interface must contain an inner class Entry . The AbstractMap includes the inner class SimpleEntry that implements the Map.Entry interface. We can remove the inner class Entry<K, V> and replace new Entry with new SimpleEntry .","title":"Interface Map.Entry and Class AbstractMap.SimpleEntry"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#creating-a-set-view-of-a-map","text":"Method entrySet creates a set view of the entries in a Map. This means that method entrySet returns an object that implements the Set interface\u2014that is, a set.","title":"Creating a Set View of a Map"},{"location":"data-structures/chp5-sets-and-maps/5-4-considerations.html#classes-treemap-and-treeset","text":"Besides HashMap and HashSet , the Java Collections Framework provides classes TreeMap and TreeSet that implement the Map and Set interfaces. These classes use a Red\u2013Black tree , which is a balanced binary search tree. We discussed earlier that the performances for search, retrieval, insertion, and removal operations are better for a hash table than for a binary search tree (expected O(1) versus O(log n)). However, the primary advantage of a binary search tree is that it can be traversed in sorted order. Hash tables, however, can\u2019t be traversed in any meaningful way. Also, subsets based on a range of key values can be selected using a TreeMap but not by using a HashMap","title":"Classes TreeMap and TreeSet"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html","text":"1. Sets The Set Hierarchy Figure above shows the part of the Collections Framework that relates to sets. It includes interfaces Set , Sortedset , and Navigableset ; abstract class AbstractSet ; and actual classes HashSet , TreeSet , and ConcurrentSkipListSet . The HashSet is a set that is implemented using a hash table (discussed later). The TreeSet is implemented using a special kind of binary search tree, called the Red\u2013Black tree (discussed in future chapters). The ConcurrentSkipListSet is implemented using a skip list (discussed in future chapters). Interface java.util.Set Modifier and Type Method Description boolean add(E e) Adds the specified element to this set if it is not already present (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this set if they're not already present (optional operation). void clear() Removes all of the elements from this set (optional operation). boolean contains(Object o) Returns true if this set contains the specified element. boolean containsAll(Collection<?> c) Returns true if this set contains all of the elements of the specified collection. boolean equals(Object o) Compares the specified object with this set for equality. int hashCode() Returns the hash code value for this set. boolean isEmpty() Returns true if this set contains no elements. Iterator<E> iterator() Returns an iterator over the elements in this set. boolean remove(Object o) Removes the specified element from this set if it is present (optional operation). boolean removeAll(Collection<?> c) Removes from this set all of its elements that are contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this set that are contained in the specified collection (optional operation). int size() Returns the number of elements in this set (its cardinality). Object[] toArray() Returns an array containing all of the elements in this set. Comparison of List and Set Collections implementing the Set interface must contain unique elements. Unlike the List.add method, the Set.add method will return false if you attempt to insert a duplicate item. Unlike a List, a Set does not have a get method. Therefore, elements cannot be accessed by index. So if setA is a Set object, the method call setA.get(0) would cause the syntax error method get(int) not found. Although you can\u2019t reference a specific element of a Set, you can iterate through all its elements using an Iterator object. The loop below accesses each element of Set object setA. However, the elements will be accessed in arbitrary order. This means that they will not necessarily be accessed in the order in which they were inserted. 2. Maps The Map Hierarchy Figure below shows part of the Map hierarchy in the Java API . Although not strictly part of the Collection hierarchy, the Map interface defines a structure that relates elements in one set to elements in another set. The first set, called the keys, must implement the Set interface; that is, the keys are unique. The second set is not strictly a Set but an arbitrary Collection known as the values. These are not required to be unique. The Map is a more useful structure than the Set . In fact, the Java API implements the Set using a Map . The TreeMap uses a Red\u2013Black binary search tree (discussed in future chapters) as its underlying data structure, and the ConcurrentSkipListMap uses a skip list (discussed in future chapters) as its underlying data structure. We will focus on the HashMap and show how to implement it later in the chapter. Interface java.util.Map Modifier and Type Method Description void clear() Removes all of the mappings from this map (optional operation). boolean containsKey(Object key) Returns true if this map contains a mapping for the specified key. boolean containsValue(Object value) Returns true if this map maps one or more keys to the specified value. Set<Map.Entry<K, V>> entrySet() Returns a Set view of the mappings contained in this map. boolean equals(Object o) Compares the specified object with this map for equality. default void forEach(BiConsumer<? super K, ? super V> action) Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. V get(Object key) Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. default V getOrDefault(Object key, V defaultValue) Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key. int hashCode() Returns the hash code value for this map. boolean isEmpty() Returns true if this map contains no key-value mappings. Set<K> keySet() Returns a Set view of the keys contained in this map. default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. V put(K key, V value) Associates the specified value with the specified key in this map (optional operation). void putAll(Map<? extends K, ? extends V> m) Copies all of the mappings from the specified map to this map (optional operation). default V putIfAbsent(K key, V value) If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value. V remove(Object key) Removes the mapping for a key from this map if it is present (optional operation). default boolean remove(Object key, Object value) Removes the entry for the specified key only if it is currently mapped to the specified value. default V replace(K key, V value) Replaces the entry for the specified key only if it is currently mapped to some value. default boolean replace(K key, V oldValue, V newValue) Replaces the entry for the specified key only if currently mapped to the specified value. default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. int size() Returns the number of key-value mappings in this map. Collection<V> values() Returns a Collection view of the values contained in this map. 3. Hash Tables Before we discuss the details of implementing the required methods of the Set and Map interfaces, we will describe a data structure, the hash table, that can be used as the basis for such an implementation. Using a hash table enables us to retrieve an item in constant time (expected O(1)). We say expected O(1) rather than just O(1) because there will be some cases where the performance will be much worse than O(1) and may even be O(n), but on the average, we expect that it will be O(1). Properties of Hash Functions Simple and efficient to compute Provides a large set of possible values to map domain Should provide an (almost) equal distribution (mapping) of values The probability of two distinct items to generate the same hash value should be as low as possible Open Addressing Two ways to organize a hash tables: open addressing chaining Procedure: Open Addressing Each hash table element (type Object) references a single key\u2013value pair. We can use the following simple approach (called linear probing ) to access an item in a hash table. If the index calculated for an item\u2019s key is occupied by an item with that key, we have found the item. If that element contains an item with a different key, we increment the index by 1. We keep incrementing the index (modulo the table length) until either we find the key we are seeking or we reach a null entry. A null entry indicates that the key is not in the table. Algorithm For Accessing an Item in a Hash Table Compute the index by taking the item\u2019s hashCode() % table.length. if table[index] is null The item is not in the table. else if table[index] is equal to the item The item is in the table. else Continue to search the table by incrementing the index until either the item is found or a null entry is found. Table Wraparound and Search Termination Note that as you increment the table index, your table should wrap around (as in a circular array) so that the element with subscript 0 \u201cfollows\u201d the element with subscript table.length \u2010 1. This enables you to use the entire table, not just the part with subscripts larger than the hash code value, but it leads to the potential for an infinite loop in Step 6 of the algorithm. If the table is full and the objects examined so far do not match the one you are seeking, how do you know when to stop? One approach would be to stop when the index value for the next probe is the same as the hash code value for the object. This means that you have come full circle to the starting value for the index. A second approach would be to ensure that the table is never full by increasing its size after an insertion if its occupancy rate exceeds a specifieif its occupancy rate exceeds a specified thresholdd threshold . This is the approach that we take in our implementation. Traversing a Hash Table One thing that you cannot do is traverse a hash table in a meaningful way. Deleting an Item Using Open Addressing When an item is deleted, we cannot just set its table entry to null . If we do, then when we search for an item that may have collided with the deleted item, we may incorrectly conclude that the item is not in the table. (Because the item that collided was inserted after the deleted item, we will have stopped our search prematurely.) By storing a dummy value when an item is deleted, we force the search algorithm to keep looking until either the desired item is found or a null value, representing a free cell, is located. Although the use of a dummy value solves the problem, keep in mind that it can lead to search inefficiency, particularly when there are many deletions. Removing items from the table does not reduce the search time because the dummy value is still in the table and is part of a search chain. In fact, you cannot even replace a deleted value with a new item because you still need to go to the end of the search chain to ensure that the new item is not already present in the table. So deleted items waste storage space and reduce search efficiency. In the worst case, if the table is almost full and then most of the items are deleted, you will have O(n) performance when searching for the few items remaining in the table. Reducing Collisions by Expanding the Table Size The first step in reducing these collisions is to use a prime number for the size of the table. In addition, the probability of a collision is proportional to how full the table is. Therefore, when the hash table becomes sufficiently full, a larger table should be allocated and the entries reinserted. You expand a hash table using an algorithm called rehashing . Algorithm For Rehashing 1. Allocate a new hash table with twice the capacity of the original. 2. Reinsert each old table entry that has not been deleted into the new hash table. 3. Reference the new table instead of the original. Reducing Collisions Using Quadratic Probing The problem with linear probing is that it tends to form clusters of keys in the table, causing longer search chains. One approach to reduce the effect of clustering is to use quadratic probing instead of linear probing . In quadratic probing, the increments form a quadratic series (1 + 2^2 + 3^2 + \u00b7 \u00b7 \u00b7) . probeNum++; index = (startIndex + probeNum * probeNum) % table.length Problems with Quadratic Probing One disadvantage of quadratic probing is that the next index calculation is a bit time\u2010consuming as it involves a multiplication, an addition, and a modulo division. A more efficient way to calculate the next index follows: java k += 2; index = (index + k) % table.length; A more serious problem with quadratic probing is that not all table elements are examined when looking for an insertion index, so it is possible that an item can\u2019t be inserted even when the table is not full. It is also possible that your program can get stuck in an infinite loop while searching for an empty slot. It can be proved that if the table size is a prime number and the table is never more than half full, this can\u2019t happen. However, requiring that the table be half empty at all times wastes quite a bit of memory. For these reasons, we will use linear probing in our implementation. Chaining An alternative to open addressing is a technique called chaining , in which each table element references a linked list that contains all the items that hash to the same table index. This linked list is often called a bucket , and this approach is sometimes called bucket hashing . Instead of incrementing the table index to access the next item with a particular hash code value, you traverse the linked list referenced by the table element with index hashCode() % table.length . One advantage of chaining is that only items that have the same value for hashCode() % table. length will be examined when looking for an object. In open addressing, search chains can overlap, so a search chain may include items in the table that have different starting index values. A second advantage is that you can store more elements in the table than the number of table slots (indexes), which is not the case for open addressing. To delete an item, simply remove it from the list. In contrast to open addressing, removing an item actually deletes it, so it will not be part of future search chains. Performance of Hash Tables load factor : The number of filled cells divided by table size. The load factor has the greatest effect on hash table performance. Lower the load factor the better the performance because there is less chance of collision. If there are no collisions, the performance for search and retrieval is O(1) . Performance of Open Addressing versus Chaining Expected number of comparisons, c, for open addressing with linear probing and a load factor L: c = \\dfrac{1}{2}(1 + \\dfrac{1}{1 - L}) L = number of filled cells/table size Expected number of comparisons, c, for chaining and a load factor L (L is average number of items in a list here = # of items divided by table size: c = 1 + \\dfrac{L}{2} For values of L between 0.0 and 0.75, the results for chaining are similar to those of linear probing. But chaining gives better performance than linear probing for higher load factors. Quadratic probing gives performance that is between those of linear probing and chaining. Performance of Hash Tables versus Sorted Arrays and Binary Trees The performance of hashing is certainly preferable to that of binary search of an array (or a binary search tree), particularly if L is less than 0.75. However, the trade-off is that the lower the load factor, the more unfilled storage cells there are in a hash table, whereas there are no empty cells in a sorted array. Because a binary search tree requires three references per node (the item, the left subtree, and the right subtrees), more storage would be required for a binary search tree than for a hash table with a load factor of 0.75. Storage Requirements for Open Addressing and Chaining Next, we consider the effect of chaining on storage requirements. For a table with a load factor of L, the number of table elements required is n (the size of the table). For open addressing, the number of references to an item (a key\u2013value pair) is n. For chaining, the average number of nodes in a list is L . If we use the Java API LinkedList , there will be three references in each node (the item, the next list element, and the previous element). However, we could use our own single\u2010linked list and eliminate the previous\u2010element reference (at some time cost for deletions). Therefore, we will require storage for n + n*2L references. Implementing the Hash Table Interface IHashMap package datastructures.setmap; public interface IHashMap<K, V> { V get(Object key); boolean isEmpty(); V put(K key, V value); V remove(Object key); int size(); } Class HashTableOpen package datastructures.setmap; /** Hash table implementation using open addressing. */ public class HashTableOpen<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } // Data Fields private Entry<K, V>[] table; private static final int START_CAPACITY = 101; private double LOAD_THRESHOLD = 0.75; private int numKeys; private int numDeletes; private final Entry<K, V> DELETED = new Entry<>(null, null); // Constructor public HashTableOpen() { table = new Entry[START_CAPACITY]; } /** Finds either the target key or the first empty slot in the search chain using linear probing. @pre The table is not full. @param key The key of the target object @return The position of the target or the first empty slot if the target is not in the table. */ private int find(Object key) { // Calculate the starting index. int index = key.hashCode() % table.length; if (index < 0) index += table.length; // Make it positive. // Increment index until an empty slot is reached or the key is found. while ((table[index] != null) && (!key.equals(table[index].getKey()))) { index++; // Check for wraparound. if (index >= table.length) index = 0; // Wrap around. } return index; } /** Method get for class HashtableOpen. @param key The key being sought @return the value associated with this key if found; otherwise, null */ @Override public V get(Object key) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If the search is successful, return the value. if (table[index] != null) return table[index].getValue(); else return null; // key not found. } /** Method put for class HashtableOpen. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. If the LOAD_THRESHOLD is exceeded, the table is expanded. @param key The key of item being inserted @param value The value for this key @return Old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If an empty element was found, insert new entry. if (table[index] == null) { table[index] = new Entry<>(key, value); numKeys++; // Check whether rehash is needed. double loadFactor = (double) (numKeys + numDeletes) / table.length; if (loadFactor > LOAD_THRESHOLD) rehash(); return null; } // assert: table element that contains the key was found. // Replace value for this key. V oldVal = table[index].getValue(); table[index].setValue(value); return oldVal; } @Override public V remove(Object key) { // Find the first table element that is empty or the table element that contains the key. int index = find(key); // if an empty element was found return null if(table[index] == null || table[index] == this.DELETED){ return null; } // Key was found. Remove this table element by setting it to reference DELETED, increment // numDeletes, and decrement numKeys. V oldVal = table[index].getValue(); table[index] = this.DELETED; this.numDeletes++; this.numKeys--; // Return the value associated with this key. return oldVal; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } /** Expands table size when loadFactor exceeds LOAD_THRESHOLD @post The size of the table is doubled and is an odd integer. Each nondeleted entry from the original table is reinserted into the expanded table. The value of numKeys is reset to the number of items actually inserted; numDeletes is reset to 0. */ private void rehash() { // Save a reference to oldTable. Entry<K, V>[] oldTable = table; // Double capacity of this table. table = new Entry[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. numKeys = 0; numDeletes = 0; for (int i = 0; i < oldTable.length; i++) { if ((oldTable[i] != null) && (oldTable[i] != DELETED)) { // Insert entry in expanded table put(oldTable[i].getKey(), oldTable[i].getValue()); } } } } Class HashTableChain package datastructures.setmap; import java.util.*; /** Hash table implementation using chaining. */ public class HashTableChain<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } /** The table */ private LinkedList<Entry<K, V>>[] table; /** The number of keys */ private int numKeys; /** The capacity */ private static final int CAPACITY = 101; /** The maximum load factor */ private static final double LOAD_THRESHOLD = 3.0; // Constructor public HashTableChain() { table = new LinkedList[CAPACITY]; } /** Method get for class HashtableChain. @param key The key being sought @return The value associated with this key if found; otherwise, null */ @Override public V get(Object key) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) return null; // key is not in the table. // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { if (nextItem.getKey().equals(key)) return nextItem.getValue(); } // assert: key is not in the table. return null; } /** Method put for class HashtableChain. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. @param key The key of item being inserted @param value The value for this key @return The old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { // If the search is successful, replace the old value. if (nextItem.getKey().equals(key)) { // Replace value for this key. V oldVal = nextItem.getValue(); nextItem.setValue(value); return oldVal; } } // assert: key is not in the table, add new item. table[index].addFirst(new Entry<>(key, value)); numKeys++; if (numKeys > (LOAD_THRESHOLD * table.length)) rehash(); return null; } @Override public V remove(Object key) { // Set index to key.hashCode() % table.length. // if index is negative, add table.length. int index = key.hashCode() % table.length; if(index < 0){ index += table.length; } // if table[index] is null // key is not in the table; return null. if(table[index] == null){ return null; } for(int i = 0 ; i < table[index].size(); i++){ //Search the list at table[index] to find the key. if(table[index].get(i).getKey() == key){ V oldVal = table[index].get(i).getValue(); // if the search is successful // Remove the entry with this key and decrement numKeys. table[index].remove(i); this.numKeys--; //if the list at table[index] is empty //Set table[index] to null. if(table[index].isEmpty()){ table[index] = null; } //Return the value associated with this key. return oldVal; } } //The key is not in the table; return null. return null; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } private void rehash() { // Save a reference to oldTable. LinkedList<Entry<K, V>>[] oldTable = table; // Double capacity of this table. table = new LinkedList[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. this.numKeys = 0; for (LinkedList<Entry<K, V>> entries : oldTable) { for (Entry<K, V> entry : entries) { int index = entry.getKey().hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } table[index].add(entry); this.numKeys++; } } } } 4. Implementation Considerations for Maps and Sets Methods hashCode and equals Method Object.equals compares two objects based on their addresses, not their contents. Similarly, method Object.hashCode calculates an object\u2019s hash code based on its address, not its contents. Most predefined classes (e.g., String and Integer) override method equals and method hashCode . If you override the equals method, Java recommends you also override the hashCode method. Otherwise, your class will violate the Java contract for hashCode , which states: java if obj1.equals(obj2) is true, then obj1.hashCode() == obj2.hashCode(). Implementing HashSetOpen We can modify the hash table methods to implement a hash set. Table below compares corresponding Map and Set methods. Map Method Set Method V get(Object key) boolean contains(Object key) V put(K key, V value) boolean add(K key) V remove(Object key) boolean remove(Object key) Writing HashSetOpen as an Adapter Class Instead of writing new methods from scratch, we can implement HashSetOpen as an adapter class with the data field. private final IHashMap<K, V> setMap = new HashtableOpen<>(); We can write methods contains, add, and remove as follows. Because the map stores key\u2013value pairs, we will have each set element reference an Entry object with the same key and value. Implementing the Java Map and Set Interfaces Java API uses a hash table to implement both the Map and Set interfaces (class HashMap and class HashSet ). The task of implementing these interfaces is simplified by the inclusion of abstract classes AbstractMap and AbstractSet in the Collections framework. These classes provide implementations of several methods for the Map and Set interfaces. So if class HashTableOpen extends class AbstractMap , we can reduce the amount of additional work we need to do. We should also replace IHashMap with Map . Thus, the declaration for HashTableOpen would be class HashTableOpen<K, V> extends AbstractMap<K, V> implements Map<K, V> . The AbstractMap provides relatively inefficient O(n) implementations of the get and put methods. Because we overrode these methods in both our implementations ( HashTableOpen and HashTableChain ), we will get O(1) expected performance. There are other, less critical methods that we don\u2019t need to provide because they are implemented in AbstractMap or its superclasses, such as clear , isEmpty , putAll , equals , hashCode , and toString . Interface Map.Entry and Class AbstractMap.SimpleEntry One requirement on the key\u2013value pairs for a Map object is that they implement the interface Map.Entry<K, V> , which is an inner interface of interface Map . This may sound a bit confusing, but what it means is that an implementer of the Map interface must contain an inner class Entry . The AbstractMap includes the inner class SimpleEntry that implements the Map.Entry interface. We can remove the inner class Entry<K, V> and replace new Entry with new SimpleEntry . Creating a Set View of a Map Method entrySet creates a set view of the entries in a Map. This means that method entrySet returns an object that implements the Set interface\u2014that is, a set. Classes TreeMap and TreeSet Besides HashMap and HashSet , the Java Collections Framework provides classes TreeMap and TreeSet that implement the Map and Set interfaces. These classes use a Red\u2013Black tree , which is a balanced binary search tree. We discussed earlier that the performances for search, retrieval, insertion, and removal operations are better for a hash table than for a binary search tree (expected O(1) versus O(log n)). However, the primary advantage of a binary search tree is that it can be traversed in sorted order. Hash tables, however, can\u2019t be traversed in any meaningful way. Also, subsets based on a range of key values can be selected using a TreeMap but not by using a HashMap","title":"1. Sets"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#1-sets","text":"","title":"1. Sets"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#the-set-hierarchy","text":"Figure above shows the part of the Collections Framework that relates to sets. It includes interfaces Set , Sortedset , and Navigableset ; abstract class AbstractSet ; and actual classes HashSet , TreeSet , and ConcurrentSkipListSet . The HashSet is a set that is implemented using a hash table (discussed later). The TreeSet is implemented using a special kind of binary search tree, called the Red\u2013Black tree (discussed in future chapters). The ConcurrentSkipListSet is implemented using a skip list (discussed in future chapters).","title":"The Set Hierarchy"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#interface-javautilset","text":"Modifier and Type Method Description boolean add(E e) Adds the specified element to this set if it is not already present (optional operation). boolean addAll(Collection<? extends E> c) Adds all of the elements in the specified collection to this set if they're not already present (optional operation). void clear() Removes all of the elements from this set (optional operation). boolean contains(Object o) Returns true if this set contains the specified element. boolean containsAll(Collection<?> c) Returns true if this set contains all of the elements of the specified collection. boolean equals(Object o) Compares the specified object with this set for equality. int hashCode() Returns the hash code value for this set. boolean isEmpty() Returns true if this set contains no elements. Iterator<E> iterator() Returns an iterator over the elements in this set. boolean remove(Object o) Removes the specified element from this set if it is present (optional operation). boolean removeAll(Collection<?> c) Removes from this set all of its elements that are contained in the specified collection (optional operation). boolean retainAll(Collection<?> c) Retains only the elements in this set that are contained in the specified collection (optional operation). int size() Returns the number of elements in this set (its cardinality). Object[] toArray() Returns an array containing all of the elements in this set.","title":"Interface java.util.Set"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#comparison-of-list-and-set","text":"Collections implementing the Set interface must contain unique elements. Unlike the List.add method, the Set.add method will return false if you attempt to insert a duplicate item. Unlike a List, a Set does not have a get method. Therefore, elements cannot be accessed by index. So if setA is a Set object, the method call setA.get(0) would cause the syntax error method get(int) not found. Although you can\u2019t reference a specific element of a Set, you can iterate through all its elements using an Iterator object. The loop below accesses each element of Set object setA. However, the elements will be accessed in arbitrary order. This means that they will not necessarily be accessed in the order in which they were inserted.","title":"Comparison of List and Set"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#2-maps","text":"","title":"2. Maps"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#the-map-hierarchy","text":"Figure below shows part of the Map hierarchy in the Java API . Although not strictly part of the Collection hierarchy, the Map interface defines a structure that relates elements in one set to elements in another set. The first set, called the keys, must implement the Set interface; that is, the keys are unique. The second set is not strictly a Set but an arbitrary Collection known as the values. These are not required to be unique. The Map is a more useful structure than the Set . In fact, the Java API implements the Set using a Map . The TreeMap uses a Red\u2013Black binary search tree (discussed in future chapters) as its underlying data structure, and the ConcurrentSkipListMap uses a skip list (discussed in future chapters) as its underlying data structure. We will focus on the HashMap and show how to implement it later in the chapter.","title":"The Map Hierarchy"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#interface-javautilmap","text":"Modifier and Type Method Description void clear() Removes all of the mappings from this map (optional operation). boolean containsKey(Object key) Returns true if this map contains a mapping for the specified key. boolean containsValue(Object value) Returns true if this map maps one or more keys to the specified value. Set<Map.Entry<K, V>> entrySet() Returns a Set view of the mappings contained in this map. boolean equals(Object o) Compares the specified object with this map for equality. default void forEach(BiConsumer<? super K, ? super V> action) Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. V get(Object key) Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. default V getOrDefault(Object key, V defaultValue) Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key. int hashCode() Returns the hash code value for this map. boolean isEmpty() Returns true if this map contains no key-value mappings. Set<K> keySet() Returns a Set view of the keys contained in this map. default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. V put(K key, V value) Associates the specified value with the specified key in this map (optional operation). void putAll(Map<? extends K, ? extends V> m) Copies all of the mappings from the specified map to this map (optional operation). default V putIfAbsent(K key, V value) If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value. V remove(Object key) Removes the mapping for a key from this map if it is present (optional operation). default boolean remove(Object key, Object value) Removes the entry for the specified key only if it is currently mapped to the specified value. default V replace(K key, V value) Replaces the entry for the specified key only if it is currently mapped to some value. default boolean replace(K key, V oldValue, V newValue) Replaces the entry for the specified key only if currently mapped to the specified value. default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. int size() Returns the number of key-value mappings in this map. Collection<V> values() Returns a Collection view of the values contained in this map.","title":"Interface java.util.Map"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#3-hash-tables","text":"Before we discuss the details of implementing the required methods of the Set and Map interfaces, we will describe a data structure, the hash table, that can be used as the basis for such an implementation. Using a hash table enables us to retrieve an item in constant time (expected O(1)). We say expected O(1) rather than just O(1) because there will be some cases where the performance will be much worse than O(1) and may even be O(n), but on the average, we expect that it will be O(1). Properties of Hash Functions Simple and efficient to compute Provides a large set of possible values to map domain Should provide an (almost) equal distribution (mapping) of values The probability of two distinct items to generate the same hash value should be as low as possible","title":"3. Hash Tables"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#open-addressing","text":"Two ways to organize a hash tables: open addressing chaining Procedure: Open Addressing Each hash table element (type Object) references a single key\u2013value pair. We can use the following simple approach (called linear probing ) to access an item in a hash table. If the index calculated for an item\u2019s key is occupied by an item with that key, we have found the item. If that element contains an item with a different key, we increment the index by 1. We keep incrementing the index (modulo the table length) until either we find the key we are seeking or we reach a null entry. A null entry indicates that the key is not in the table. Algorithm For Accessing an Item in a Hash Table Compute the index by taking the item\u2019s hashCode() % table.length. if table[index] is null The item is not in the table. else if table[index] is equal to the item The item is in the table. else Continue to search the table by incrementing the index until either the item is found or a null entry is found.","title":"Open Addressing"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#table-wraparound-and-search-termination","text":"Note that as you increment the table index, your table should wrap around (as in a circular array) so that the element with subscript 0 \u201cfollows\u201d the element with subscript table.length \u2010 1. This enables you to use the entire table, not just the part with subscripts larger than the hash code value, but it leads to the potential for an infinite loop in Step 6 of the algorithm. If the table is full and the objects examined so far do not match the one you are seeking, how do you know when to stop? One approach would be to stop when the index value for the next probe is the same as the hash code value for the object. This means that you have come full circle to the starting value for the index. A second approach would be to ensure that the table is never full by increasing its size after an insertion if its occupancy rate exceeds a specifieif its occupancy rate exceeds a specified thresholdd threshold . This is the approach that we take in our implementation.","title":"Table Wraparound and Search Termination"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#traversing-a-hash-table","text":"One thing that you cannot do is traverse a hash table in a meaningful way.","title":"Traversing a Hash Table"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#deleting-an-item-using-open-addressing","text":"When an item is deleted, we cannot just set its table entry to null . If we do, then when we search for an item that may have collided with the deleted item, we may incorrectly conclude that the item is not in the table. (Because the item that collided was inserted after the deleted item, we will have stopped our search prematurely.) By storing a dummy value when an item is deleted, we force the search algorithm to keep looking until either the desired item is found or a null value, representing a free cell, is located. Although the use of a dummy value solves the problem, keep in mind that it can lead to search inefficiency, particularly when there are many deletions. Removing items from the table does not reduce the search time because the dummy value is still in the table and is part of a search chain. In fact, you cannot even replace a deleted value with a new item because you still need to go to the end of the search chain to ensure that the new item is not already present in the table. So deleted items waste storage space and reduce search efficiency. In the worst case, if the table is almost full and then most of the items are deleted, you will have O(n) performance when searching for the few items remaining in the table.","title":"Deleting an Item Using Open Addressing"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#reducing-collisions-by-expanding-the-table-size","text":"The first step in reducing these collisions is to use a prime number for the size of the table. In addition, the probability of a collision is proportional to how full the table is. Therefore, when the hash table becomes sufficiently full, a larger table should be allocated and the entries reinserted. You expand a hash table using an algorithm called rehashing . Algorithm For Rehashing 1. Allocate a new hash table with twice the capacity of the original. 2. Reinsert each old table entry that has not been deleted into the new hash table. 3. Reference the new table instead of the original.","title":"Reducing Collisions by Expanding the Table Size"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#reducing-collisions-using-quadratic-probing","text":"The problem with linear probing is that it tends to form clusters of keys in the table, causing longer search chains. One approach to reduce the effect of clustering is to use quadratic probing instead of linear probing . In quadratic probing, the increments form a quadratic series (1 + 2^2 + 3^2 + \u00b7 \u00b7 \u00b7) . probeNum++; index = (startIndex + probeNum * probeNum) % table.length Problems with Quadratic Probing One disadvantage of quadratic probing is that the next index calculation is a bit time\u2010consuming as it involves a multiplication, an addition, and a modulo division. A more efficient way to calculate the next index follows: java k += 2; index = (index + k) % table.length; A more serious problem with quadratic probing is that not all table elements are examined when looking for an insertion index, so it is possible that an item can\u2019t be inserted even when the table is not full. It is also possible that your program can get stuck in an infinite loop while searching for an empty slot. It can be proved that if the table size is a prime number and the table is never more than half full, this can\u2019t happen. However, requiring that the table be half empty at all times wastes quite a bit of memory. For these reasons, we will use linear probing in our implementation.","title":"Reducing Collisions Using Quadratic Probing"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#chaining","text":"An alternative to open addressing is a technique called chaining , in which each table element references a linked list that contains all the items that hash to the same table index. This linked list is often called a bucket , and this approach is sometimes called bucket hashing . Instead of incrementing the table index to access the next item with a particular hash code value, you traverse the linked list referenced by the table element with index hashCode() % table.length . One advantage of chaining is that only items that have the same value for hashCode() % table. length will be examined when looking for an object. In open addressing, search chains can overlap, so a search chain may include items in the table that have different starting index values. A second advantage is that you can store more elements in the table than the number of table slots (indexes), which is not the case for open addressing. To delete an item, simply remove it from the list. In contrast to open addressing, removing an item actually deletes it, so it will not be part of future search chains.","title":"Chaining"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#performance-of-hash-tables","text":"load factor : The number of filled cells divided by table size. The load factor has the greatest effect on hash table performance. Lower the load factor the better the performance because there is less chance of collision. If there are no collisions, the performance for search and retrieval is O(1) . Performance of Open Addressing versus Chaining Expected number of comparisons, c, for open addressing with linear probing and a load factor L: c = \\dfrac{1}{2}(1 + \\dfrac{1}{1 - L}) L = number of filled cells/table size Expected number of comparisons, c, for chaining and a load factor L (L is average number of items in a list here = # of items divided by table size: c = 1 + \\dfrac{L}{2} For values of L between 0.0 and 0.75, the results for chaining are similar to those of linear probing. But chaining gives better performance than linear probing for higher load factors. Quadratic probing gives performance that is between those of linear probing and chaining. Performance of Hash Tables versus Sorted Arrays and Binary Trees The performance of hashing is certainly preferable to that of binary search of an array (or a binary search tree), particularly if L is less than 0.75. However, the trade-off is that the lower the load factor, the more unfilled storage cells there are in a hash table, whereas there are no empty cells in a sorted array. Because a binary search tree requires three references per node (the item, the left subtree, and the right subtrees), more storage would be required for a binary search tree than for a hash table with a load factor of 0.75. Storage Requirements for Open Addressing and Chaining Next, we consider the effect of chaining on storage requirements. For a table with a load factor of L, the number of table elements required is n (the size of the table). For open addressing, the number of references to an item (a key\u2013value pair) is n. For chaining, the average number of nodes in a list is L . If we use the Java API LinkedList , there will be three references in each node (the item, the next list element, and the previous element). However, we could use our own single\u2010linked list and eliminate the previous\u2010element reference (at some time cost for deletions). Therefore, we will require storage for n + n*2L references.","title":"Performance of Hash Tables"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#implementing-the-hash-table","text":"","title":"Implementing the Hash Table"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#interface-ihashmap","text":"package datastructures.setmap; public interface IHashMap<K, V> { V get(Object key); boolean isEmpty(); V put(K key, V value); V remove(Object key); int size(); }","title":"Interface IHashMap"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#class-hashtableopen","text":"package datastructures.setmap; /** Hash table implementation using open addressing. */ public class HashTableOpen<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } // Data Fields private Entry<K, V>[] table; private static final int START_CAPACITY = 101; private double LOAD_THRESHOLD = 0.75; private int numKeys; private int numDeletes; private final Entry<K, V> DELETED = new Entry<>(null, null); // Constructor public HashTableOpen() { table = new Entry[START_CAPACITY]; } /** Finds either the target key or the first empty slot in the search chain using linear probing. @pre The table is not full. @param key The key of the target object @return The position of the target or the first empty slot if the target is not in the table. */ private int find(Object key) { // Calculate the starting index. int index = key.hashCode() % table.length; if (index < 0) index += table.length; // Make it positive. // Increment index until an empty slot is reached or the key is found. while ((table[index] != null) && (!key.equals(table[index].getKey()))) { index++; // Check for wraparound. if (index >= table.length) index = 0; // Wrap around. } return index; } /** Method get for class HashtableOpen. @param key The key being sought @return the value associated with this key if found; otherwise, null */ @Override public V get(Object key) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If the search is successful, return the value. if (table[index] != null) return table[index].getValue(); else return null; // key not found. } /** Method put for class HashtableOpen. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. If the LOAD_THRESHOLD is exceeded, the table is expanded. @param key The key of item being inserted @param value The value for this key @return Old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { // Find the first table element that is empty // or the table element that contains the key. int index = find(key); // If an empty element was found, insert new entry. if (table[index] == null) { table[index] = new Entry<>(key, value); numKeys++; // Check whether rehash is needed. double loadFactor = (double) (numKeys + numDeletes) / table.length; if (loadFactor > LOAD_THRESHOLD) rehash(); return null; } // assert: table element that contains the key was found. // Replace value for this key. V oldVal = table[index].getValue(); table[index].setValue(value); return oldVal; } @Override public V remove(Object key) { // Find the first table element that is empty or the table element that contains the key. int index = find(key); // if an empty element was found return null if(table[index] == null || table[index] == this.DELETED){ return null; } // Key was found. Remove this table element by setting it to reference DELETED, increment // numDeletes, and decrement numKeys. V oldVal = table[index].getValue(); table[index] = this.DELETED; this.numDeletes++; this.numKeys--; // Return the value associated with this key. return oldVal; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } /** Expands table size when loadFactor exceeds LOAD_THRESHOLD @post The size of the table is doubled and is an odd integer. Each nondeleted entry from the original table is reinserted into the expanded table. The value of numKeys is reset to the number of items actually inserted; numDeletes is reset to 0. */ private void rehash() { // Save a reference to oldTable. Entry<K, V>[] oldTable = table; // Double capacity of this table. table = new Entry[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. numKeys = 0; numDeletes = 0; for (int i = 0; i < oldTable.length; i++) { if ((oldTable[i] != null) && (oldTable[i] != DELETED)) { // Insert entry in expanded table put(oldTable[i].getKey(), oldTable[i].getValue()); } } } }","title":"Class HashTableOpen"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#class-hashtablechain","text":"package datastructures.setmap; import java.util.*; /** Hash table implementation using chaining. */ public class HashTableChain<K, V> implements IHashMap<K, V> { // Insert inner class Entry<K, V> here. /** Contains key\u2010value pairs for a hash table. */ private static class Entry<K, V> { /** The key */ private final K key; /** The value */ private V value; /** Creates a new key\u2010value pair. @param key The key @param value The value */ public Entry(K key, V value) { this.key = key; this.value = value; } /** Retrieves the key. @return The key */ public K getKey() { return key; } /** Retrieves the value. @return The value */ public V getValue() { return value; } /** Sets the value. @param val The new value @return The old value */ public V setValue(V val) { V oldVal = value; value = val; return oldVal; } } /** The table */ private LinkedList<Entry<K, V>>[] table; /** The number of keys */ private int numKeys; /** The capacity */ private static final int CAPACITY = 101; /** The maximum load factor */ private static final double LOAD_THRESHOLD = 3.0; // Constructor public HashTableChain() { table = new LinkedList[CAPACITY]; } /** Method get for class HashtableChain. @param key The key being sought @return The value associated with this key if found; otherwise, null */ @Override public V get(Object key) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) return null; // key is not in the table. // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { if (nextItem.getKey().equals(key)) return nextItem.getValue(); } // assert: key is not in the table. return null; } /** Method put for class HashtableChain. @post This key\u2010value pair is inserted in the table and numKeys is incremented. If the key is already in the table, its value is changed to the argument value and numKeys is not changed. @param key The key of item being inserted @param value The value for this key @return The old value associated with this key if found; otherwise, null */ @Override public V put(K key, V value) { int index = key.hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } // Search the list at table[index] to find the key. for (Entry<K, V> nextItem : table[index]) { // If the search is successful, replace the old value. if (nextItem.getKey().equals(key)) { // Replace value for this key. V oldVal = nextItem.getValue(); nextItem.setValue(value); return oldVal; } } // assert: key is not in the table, add new item. table[index].addFirst(new Entry<>(key, value)); numKeys++; if (numKeys > (LOAD_THRESHOLD * table.length)) rehash(); return null; } @Override public V remove(Object key) { // Set index to key.hashCode() % table.length. // if index is negative, add table.length. int index = key.hashCode() % table.length; if(index < 0){ index += table.length; } // if table[index] is null // key is not in the table; return null. if(table[index] == null){ return null; } for(int i = 0 ; i < table[index].size(); i++){ //Search the list at table[index] to find the key. if(table[index].get(i).getKey() == key){ V oldVal = table[index].get(i).getValue(); // if the search is successful // Remove the entry with this key and decrement numKeys. table[index].remove(i); this.numKeys--; //if the list at table[index] is empty //Set table[index] to null. if(table[index].isEmpty()){ table[index] = null; } //Return the value associated with this key. return oldVal; } } //The key is not in the table; return null. return null; } @Override public int size() { return this.numKeys; } @Override public boolean isEmpty() { return (this.numKeys != 0); } private void rehash() { // Save a reference to oldTable. LinkedList<Entry<K, V>>[] oldTable = table; // Double capacity of this table. table = new LinkedList[2 * oldTable.length + 1]; // Reinsert all items in oldTable into expanded table. this.numKeys = 0; for (LinkedList<Entry<K, V>> entries : oldTable) { for (Entry<K, V> entry : entries) { int index = entry.getKey().hashCode() % table.length; if (index < 0) index += table.length; if (table[index] == null) { // Create a new linked list at table[index]. table[index] = new LinkedList<>(); } table[index].add(entry); this.numKeys++; } } } }","title":"Class HashTableChain"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#4-implementation-considerations-for-maps-and-sets","text":"","title":"4. Implementation Considerations for Maps and Sets"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#methods-hashcode-and-equals","text":"Method Object.equals compares two objects based on their addresses, not their contents. Similarly, method Object.hashCode calculates an object\u2019s hash code based on its address, not its contents. Most predefined classes (e.g., String and Integer) override method equals and method hashCode . If you override the equals method, Java recommends you also override the hashCode method. Otherwise, your class will violate the Java contract for hashCode , which states: java if obj1.equals(obj2) is true, then obj1.hashCode() == obj2.hashCode().","title":"Methods hashCode and equals"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#implementing-hashsetopen","text":"We can modify the hash table methods to implement a hash set. Table below compares corresponding Map and Set methods. Map Method Set Method V get(Object key) boolean contains(Object key) V put(K key, V value) boolean add(K key) V remove(Object key) boolean remove(Object key)","title":"Implementing HashSetOpen"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#writing-hashsetopen-as-an-adapter-class","text":"Instead of writing new methods from scratch, we can implement HashSetOpen as an adapter class with the data field. private final IHashMap<K, V> setMap = new HashtableOpen<>(); We can write methods contains, add, and remove as follows. Because the map stores key\u2013value pairs, we will have each set element reference an Entry object with the same key and value.","title":"Writing HashSetOpen as an Adapter Class"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#implementing-the-java-map-and-set-interfaces","text":"Java API uses a hash table to implement both the Map and Set interfaces (class HashMap and class HashSet ). The task of implementing these interfaces is simplified by the inclusion of abstract classes AbstractMap and AbstractSet in the Collections framework. These classes provide implementations of several methods for the Map and Set interfaces. So if class HashTableOpen extends class AbstractMap , we can reduce the amount of additional work we need to do. We should also replace IHashMap with Map . Thus, the declaration for HashTableOpen would be class HashTableOpen<K, V> extends AbstractMap<K, V> implements Map<K, V> . The AbstractMap provides relatively inefficient O(n) implementations of the get and put methods. Because we overrode these methods in both our implementations ( HashTableOpen and HashTableChain ), we will get O(1) expected performance. There are other, less critical methods that we don\u2019t need to provide because they are implemented in AbstractMap or its superclasses, such as clear , isEmpty , putAll , equals , hashCode , and toString .","title":"Implementing the Java Map and Set Interfaces"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#interface-mapentry-and-class-abstractmapsimpleentry","text":"One requirement on the key\u2013value pairs for a Map object is that they implement the interface Map.Entry<K, V> , which is an inner interface of interface Map . This may sound a bit confusing, but what it means is that an implementer of the Map interface must contain an inner class Entry . The AbstractMap includes the inner class SimpleEntry that implements the Map.Entry interface. We can remove the inner class Entry<K, V> and replace new Entry with new SimpleEntry .","title":"Interface Map.Entry and Class AbstractMap.SimpleEntry"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#creating-a-set-view-of-a-map","text":"Method entrySet creates a set view of the entries in a Map. This means that method entrySet returns an object that implements the Set interface\u2014that is, a set.","title":"Creating a Set View of a Map"},{"location":"data-structures/chp5-sets-and-maps/chp5-sets-and-maps.html#classes-treemap-and-treeset","text":"Besides HashMap and HashSet , the Java Collections Framework provides classes TreeMap and TreeSet that implement the Map and Set interfaces. These classes use a Red\u2013Black tree , which is a balanced binary search tree. We discussed earlier that the performances for search, retrieval, insertion, and removal operations are better for a hash table than for a binary search tree (expected O(1) versus O(log n)). However, the primary advantage of a binary search tree is that it can be traversed in sorted order. Hash tables, however, can\u2019t be traversed in any meaningful way. Also, subsets based on a range of key values can be selected using a TreeMap but not by using a HashMap","title":"Classes TreeMap and TreeSet"},{"location":"data-structures/chp6-graphs/6-1-graphs.html","text":"Graphs Graph Terminology A graph G(V, E) is a data structure that consists of a set of vertices (or nodes) and a set of edges (relations) between the pairs of vertices. Directed and Undirected Graphs Directed Edges : The edges of a graph are directed if the existence of an edge from A to B does not necessarily guarantee that there is a path in both directions. Directed Graph : A graph that contains directed edges is known as a directed graph or digraph . Undirected Graph : A graph that contains undirected edges is known as an undirected graph or simply a graph. Weighted Edges : The edges in a graph may have values associated with them known as their weights . Weighted Graph : A graph with weighted edges is known as weighted graph . Paths and Cycles Adjacent Vertex : A vertex is adjacent to another vertex if there is an edge to it from that other vertex. Note that in the case of directed graph , adjacency is not necessarily associative, i.e. if A is adjacent to B, it doesn't necessarily mean that B is adjacent to A (if there is no edge from B to A). Path : A sequence of vertices in which each successive vertex is adjacent to its predecessor. Simple Path : In a simple path, the vertices and edges are distinct, except that the first and last vertices may be the same. Cycle : A cycle is a simple path in which only the first and final vertices are the same. A cycle must contain at least three distinct vertices. Connected Graph : An undirected graph is called a connected graph if there is a path from every vertex to every other vertex. If a graph is not connected, it is considered unconnected , but it will still consist of connected components. The Graph ADT and Edge Class Java does not provide a Graph ADT . We can represent the vertices by integers from 0 up to, but not including, |V| . ( |V| means the cardinality of V, or the number of vertices in set V.) For edges we will define the class Edge that will contain the source vertex, the destination vertex, and the weight. For unweighted edges we will use the default value of 1.0. Observe that an Edge is directed. For undirected graphs, we will always have two Edge objects: one in each direction for each pair of vertices that has an edge between them. A vertex is represented by a type int variable. Data Field Attribute private int dest The destination vertex for an edge private int source The source vertex for an edge private double weight The weight Constructor Purpose public Edge(int source, int dest) Constructs an Edge from source to dest. Sets the weight to 1.0 public Edge(int source, int dest, double w) Constructs an Edge from source to dest. Sets the weight to w Method Behavior public boolean equals(Object o) Compares two edges for equality. Edges are equal if their source and destination vertices are the same. The weight is not considered public int getDest() Returns the destination vertex public int getSource() Returns the source vertex public double getWeight() Returns the weight public int hashCode() Returns the hash code for an edge. The hash code depends only on the source and destination public String toString() Returns a string representation of the edge package datastructures.graph; public class Edge { private int source; private int dest; private double weight; public Edge(int source, int dest) { this.source = source; this.dest = dest; this.weight = 1.0; } public Edge(int source, int dest, double weight) { this.source = source; this.dest = dest; this.weight = weight; } public int getSource() { return source; } public int getDest(){ return dest; } public double getWeight() { return weight; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || this.getClass() != o.getClass()) return false; Edge edge = (Edge) o; return source == edge.source && dest == edge.dest; } @Override public int hashCode() { int result = Integer.hashCode(source); result = 31 * result + Integer.hashCode(dest); return result; } @Override public String toString() { return \"Edge{\" + \"source=\" + source + \", dest=\" + dest + \", weight=\" + weight + '}'; } } Implementing the Graph ADT Two representations of graphs are most common: Adjacency List : Edges are represented by an array of lists called adjacency lists , where each list stores the vertices adjacent to a particular vertex. Adjacency Matrix : Edges are represented by a two\u2010dimensional array, called an adjacency matrix , with |V|rows and |V| columns. Adjacency List An adjacency list representation of a graph uses an array of lists. There is one list for each vertex. The vertices are in no particular order. The Edge must be stored (not just the destination) because weighted graphs can have different values for weights. For an undirected graph (or simply a \u201cgraph\u201d), symmetric entries are required. Adjacency Matrix The adjacency matrix uses a two\u2010dimensional array to represent the graph. For an unweighted graph, the entries in this matrix can be boolean values, where true represents the presence of an edge and false its absence. Another popular method is to use the value 1 for an edge and 0 for no edge. The integer coding has benefits over the boolean approach for some graph algorithms that use matrix multiplication. For a weighted graph, the matrix would contain the weights. Since 0 is a valid weight, we will use Double.POSITIVE_INFINITY (a special double value in Java that approximates the mathematical behavior of infinity) to indicate the absence of an edge, and in an unweighted graph we will use a weight of 1.0 to indicate the presence of an edge. If the graph is undirected, then the matrix is symmetric, and only the lower diagonal of the matrix needs be saved. Overview of the Hierarchy Class AbstractGraph Data Field Attribute private boolean directed True if this is a directed graph private int numV The number of vertices Constructor Purpose public AbstractGraph(int numV, boolean directed) Constructs an empty graph with the specified number of vertices and with the specified directed flag. If directed is true, this is a directed graph Method Behavior public int getNumV() Gets the number of vertices public boolean isDirected() Returns true if the graph is a directed graph public void loadEdgesFromFile(Scanner scan) Loads edges from a data file public static Graph createGraph(Scanner scan, boolean isDirected, String type) Factory method to create a graph and load the data from an input file Implementation package datastructures.graph; import java.util.*; import java.io.*; /** Abstract base class for graphs. A graph is a set of vertices and a set of edges. Vertices are represented by integers from 0 to n \u2010 1. Edges are ordered pairs of vertices. */ public abstract class AbstractGraph implements Graph { // Data Fields /** * The number of vertices */ private int numV; /** * Flag to indicate whether this is a directed graph */ private boolean directed; // Constructor /** * Construct a graph with the specified number of vertices and the directed * flag. If the directed flag is true, this is a directed graph. * * @param numV The number of vertices * @param directed The directed flag */ public AbstractGraph(int numV, boolean directed) { this.numV = numV; this.directed = directed; } // Accessor Methods /** * Return the number of vertices. * * @return The number of vertices */ public int getNumV() { return numV; } /** * Return whether this is a directed graph. * * @return true if this is a directed graph */ public boolean isDirected() { return directed; } // Other Methods /** * Load the edges of a graph from the data in an input file. The file * should contain a series of lines, each line with two or * three data values. The first is the source, the second is * the destination, and the optional third is the weight. * * @param scan The Scanner connected to the data file */ public void loadEdgesFromFile(Scanner scan) { while (scan.hasNextLine()) { String line = scan.nextLine().trim(); if (line.isEmpty()) continue; // Skip empty lines String[] tokens = line.split(\"\\\\s+\"); if (tokens.length < 2 || tokens.length > 3) { throw new IllegalArgumentException(\"Invalid edge format: \" + line); } try { int source = Integer.parseInt(tokens[0]); int dest = Integer.parseInt(tokens[1]); double weight = (tokens.length == 3) ? Double.parseDouble(tokens[2]) : 1.0; // Add edge to the graph insert(new Edge(source, dest, weight)); } catch (NumberFormatException e) { throw new IllegalArgumentException(\"Invalid number format in line: \" + line, e); } } } /** * Factory method to create a graph and load the data from an input * file. The first line of the input file should contain the number * of vertices. The remaining lines should contain the edge data as * described under loadEdgesFromFile. * * @param scan The Scanner connected to the data file * @param isDirected true if this is a directed graph, * false otherwise * @param type The string \"Matrix\" if an adjacency matrix is to be * created, and the string \"List\" if an adjacency list * is to be created * @throws IllegalArgumentException if type is neither \"Matrix\" * nor \"List\" */ public static Graph createGraph(Scanner scan, boolean isDirected, String type) { int numV = scan.nextInt(); AbstractGraph returnValue; type = type.toLowerCase(); switch (type) { case \"matrix\": returnValue = new MatrixGraph(numV, isDirected); break; case \"list\": returnValue = new ListGraph(numV, isDirected); break; default: throw new IllegalArgumentException(); } returnValue.loadEdgesFromFile(scan); return returnValue; } } The ListGraph Class Data Field Attribute private List<Edge>[] edges An array of Lists to contain the edges that originate with each vertex Constructor Purpose public ListGraph(int numV, boolean directed) Constructs a graph with the specified number of vertices and directionality Method Behavior public Iterator<Edge> edgeIterator(int source) Returns an iterator to the edges that originate from a given vertex public Edge getEdge(int source, int dest) Gets the edge between two vertices public void insert(Edge e) Inserts a new edge into the graph public boolean isEdge(int source, int dest) Determines if there is an edge between the given vertices Implementation package datastructures.graph; import java.util.*; /** A ListGraph is an extension of the AbstractGraph abstract class that uses an array of lists to represent the edges. */ public class ListGraph extends AbstractGraph { // Data Field /** * An array of Lists to contain the edges that * originate with each vertex. */ private List<Edge>[] edges; /** * Construct a graph with the specified number of vertices and directionality. * * @param numV The number of vertices * @param directed The directionality flag */ public ListGraph(int numV, boolean directed) { super(numV, directed); edges = new List[numV]; for (int i = 0; i < numV; i++) { edges[i] = new LinkedList<Edge>(); } } /** * Insert a new edge into the graph. * * @param edge The new edge */ public void insert(Edge edge) { edges[edge.getSource()].add(edge); if (!isDirected()) { edges[edge.getDest()].add(new Edge(edge.getDest(), edge.getSource(), edge.getWeight())); } } /** * Get the edge between two vertices. * * @param source The source * @param dest The destination * @return the edge between these two vertices * or null if an edge does not exist. */ public Edge getEdge(int source, int dest) { Edge target = new Edge(source, dest, Double.POSITIVE_INFINITY); for (Edge edge : edges[source]) { if (edge.equals(target)) return edge; // Desired edge found, return it. } // Assert: All edges for source checked. return null; // Desired edge not found. } /** * Determine whether an edge exists. * * @param source The source vertex * @param dest The destination vertex * @return true if there is an edge from source to dest */ public boolean isEdge(int source, int dest) { return edges[source].contains(new Edge(source, dest)); } public Iterator<Edge> edgeIterator(int source) { return edges[source].iterator(); } } The MatrixGraph Class package datastructures.graph; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedList; import java.util.List; public class MatrixGraph extends AbstractGraph{ private double[][] edges; public MatrixGraph(int numV, boolean isDirected) { super(numV, isDirected); edges = new double[numV][numV]; for (int i = 0; i < numV; i++) { for (int j = 0; j < numV; j++) { edges[i][j] = Double.POSITIVE_INFINITY; } } } @Override public void insert(Edge edge) { edges[edge.getSource()][edge.getDest()] = edge.getWeight(); if(!isDirected()){ edges[edge.getDest()][edge.getSource()] = edge.getWeight(); } } @Override public boolean isEdge(int source, int dest) { return edges[source][dest] != Double.POSITIVE_INFINITY; } @Override public Edge getEdge(int source, int dest) { return edges[source][dest] == Double.POSITIVE_INFINITY ? null : new Edge(source, dest); } @Override public Iterator<Edge> edgeIterator(int source) { List<Edge> edges = new LinkedList<>(); for(int i = 0; i < this.getNumV(); i++){ if(this.edges[source][i] != Double.POSITIVE_INFINITY){ edges.add(getEdge(source, i)); } } return edges.iterator(); } } Complexity Analysis The density of a graph is the ratio of |E| to |V|^2 . A dense graph is one in which |E| is close to but less than |V|^2 . Time Efficiency Many graph algorithms are of the form: java 1. for each vertex u in the graph 2. for each vertex v adjacent to u 3. Do something with edge (u, v). Adjacency List: O(|E|) . Adjacency Matrix: O(|V|^2) . Thus, for a sparse graph, the adjacency list gives better performance for this type of algorithm. Some graph are of the form: java 1. for each vertex u in some subset of the vertices 2. for each vertex v in some subset of the vertices 3. if (u, v) is an edge 4. Do something with edge (u, v). Adjacency List: O(|V||E|) . Adjacency Matrix: O(|V|^2) . Since the search step is O(1) . Thus, for a dense graph, the adjacency matrix gives better performance for this type of algorithm. Storage Efficiency Adjacency Matrix: O(|V|^2) If the graph is sparse, there will be a lot of wasted space in the adjacency matrix. On the other hand, in an adjacency list, each edge is represented by a reference to an Edge object containing data about the source, destination, and weight as well as a reference to the next edge in the list. Therefore, the adjacency list uses less storage when less than 25 percent of the adjacency matrix would be filled. The MapGraph Class We can achieve the performance benefits of both the ListGraph and MatrixGraph by making a slight modification to the ListGraph . Replacing the array of List<Edge> with an array of Map<Integer, Edge> allows us to query the existence of an edge in O(1) time, and using the LinkedHashMap allows iterating through the edges adjacent to a given vertex in O(|E_u|) . package datastructures.graph; import java.util.*; /** A MapGraph is an extension of the AbstractGraph abstract class that uses an array of maps to represent the edges. */ public class MapGraph extends AbstractGraph { // Data Field /** * An array of maps to contain the edges that * originate with each vertex. */ private Map<Integer, Edge>[] outgoingEdges; /** * Construct a graph with the specified number of vertices and directionality. * * @param numV The number of vertices * @param directed The directionality flag */ public MapGraph(int numV, boolean directed) { super(numV, directed); outgoingEdges = new Map[numV]; for (int i = 0; i < numV; i++) { outgoingEdges[i] = new LinkedHashMap<>(); } } /** * Insert a new edge into the graph. * * @param edge The new edge */ public void insert(Edge edge) { int source = edge.getSource(); int dest = edge.getDest(); double weight = edge.getWeight(); outgoingEdges[source].put(dest, edge); if (!isDirected()) { Edge reverseEdge = new Edge(dest, source, weight); outgoingEdges[dest].put(source, reverseEdge); } } /** * Get the edge between two vertices. * * @param source The source * @param dest The destination * @return the edge between these two vertices * or null if an edge does not exist. */ public Edge getEdge(int source, int dest) { return outgoingEdges[source].get(dest); } /** * Determine whether an edge exists. * * @param source The source vertex * @param dest The destination vertex * @return true if there is an edge from source to dest */ public boolean isEdge(int source, int dest) { return outgoingEdges[source].containsKey(dest); } public Iterator<Edge> edgeIterator(int source) { return outgoingEdges[source].values().iterator(); } } Graph Traversals The two most common traversal algorithms are breadth-first and depth-first search. Breadth-First Search 1. Take an arbitrary start vertex, mark it visited and place it in a queue. 2. while the queue is not empty 3. Take a vertex u. 4. for all vertices, v, adjacent to this vertex, u 5. if v has not been visited 6. Mark it visited . 7. Insert vertex v into the queue. NOTE: A path starting at the root to any vertex in the tree is the shortest path in the original graph from the start vertex to that vertex, where we consider all edges to have the same weight. Therefore, the shortest path is the one that goes through the smallest number of vertices. We can save the information we need to represent this tree by storing the parent of each vertex when we identify it (Step 7 of the breadth\u2010first algorithm). Refinement of Step 7 of Breadth\u2010First Search Algorithm 7.1 Insert vertex v into the queue. 7.2 Set the parent of v to u. Time Complexity: O(|E|) package algorithms.graph.search; import datastructures.graph.Edge; import datastructures.graph.Graph; import java.util.Iterator; import java.util.LinkedList; import java.util.Queue; /** Class to implement the breadth\u2010first search algorithm. */ public class BreadthFirstSearch { /** Perform a breadth\u2010first search of a graph. @post The array parent will contain the predecessor of each vertex in the breadth\u2010first search tree. @param graph The graph to be searched @param start The start vertex @return The array of parents */ public static int[] breadthFirstSearch(Graph graph, int start) { Queue<Integer> queue = new LinkedList<Integer>(); // Declare array parent and initialize its elements to \u20131. int[] parent = new int[graph.getNumV()]; for (int i = 0; i < graph.getNumV(); i++) { parent[i] = -1; } // Declare array visited and initialize its elements to false. boolean[] visited = new boolean[graph.getNumV()]; // Mark the start vertex as visited and insert it into the queue. visited[start] = true; queue.offer(start); // Perform breadth\u2010first search until done while (!queue.isEmpty()) { // Take a vertex, current, out of the queue. int current = queue.remove(); System.out.print(current + \"\\t\"); // Examine each vertex, neighbor, adjacent to current. Iterator<Edge> itr = graph.edgeIterator(current); while (itr.hasNext()) { Edge edge = itr.next(); int neighbor = edge.getDest(); if (!visited[neighbor]) { // Mark it visited. visited[neighbor] = true; // Place it into the queue. queue.offer(neighbor); // Insert the edge (current, neighbor) into the tree. parent[neighbor] = current; } } } return parent; } } Depth-First Search 1. Mark the current vertex, u, visited. 2. for each vertex, v, adjacent to the current vertex, u 3. if v has not been visited 4. Set parent of v to u. 5. Recursively apply this algorithm starting at v. package algorithms.graph.search; import datastructures.graph.Edge; import datastructures.graph.Graph; import java.util.Arrays; import java.util.Iterator; /** Class to implement the depth\u2010first search algorithm. */ public class DepthFirstSearch { /** Start depth\u2010first search the graph starting at vertex start. @param graph The graph object. @param start The start vertex */ public static void depthFirstSearch(Graph graph, int start){ int n = graph.getNumV(); boolean[] visited = new boolean[n]; int[] parent = new int[n]; Arrays.fill(parent, -1); depthFirstSearchRecurse(graph, start, visited, parent); } /** Recursively depth\u2010first search the graph starting at vertex current. @param graph The graph object. @param current The start vertex @param visited Boolean array of visited nodes @param parent Integer array of parent nodes for corresponding vertices. */ private static void depthFirstSearchRecurse(Graph graph, int current, boolean[] visited, int[] parent) { /* Mark the current vertex visited. */ visited[current] = true; // Print by discovery order. System.out.print(current + \"\\t\"); /* Examine each vertex adjacent to the current vertex */ Iterator<Edge> itr = graph.edgeIterator(current); while (itr.hasNext()) { int neighbor = itr.next().getDest(); /* Process a neighbor that has not been visited */ if (!visited[neighbor]) { /* Insert (current, neighbor) into the depth\u2010first search tree. */ parent[neighbor] = current; /* Recursively apply the algorithm starting at neighbor. */ depthFirstSearchRecurse(graph, neighbor, visited, parent); } } // Print by finish order. // System.out.print(current + \"\\t\"); } } Time Complexity: O(|E|) . Please note that there is an implicit step 0 of the algorithm to that marks all vertices as unvisited. This is O(|V|) , thus, the total running time of the algorithm is O(|V|+|E|) . Topological Sort A topological sort of the vertices of a DAG (Directed Acyclic Graph) is an ordering of the vertices such that if (u, v) is an edge, then u appears before v. This must be true for all edges. If there is an edge from u to v in a DAG, then if we perform depth-first search of this graph, the finish time of u must be after the finish time of v. Algorithm for Topological Sort 1. Perform a depth\u2010first search of the graph. 2. List the vertices in reverse of their finish order. package algorithms.graph.sort; import algorithms.graph.search.DepthFirstSearch; import datastructures.graph.AbstractGraph; import datastructures.graph.Graph; import java.io.File; import java.util.*; /** This program outputs the topological sort of a directed graph that contains no cycles. */ public class TopologicalSort { /** * The main method that performs the topological sort. * * @param args The command line arguments * @pre arg[0] contains the name of the file * that contains the graph. It has no cycles. */ public static void main(String[] args) { Graph theGraph = null; int numVertices = 0; try { // Connect Scanner to input file. Scanner scan = new Scanner(new File(args[0])); // Load the graph data from a file. theGraph = AbstractGraph.createGraph(scan, true, \"List\"); numVertices = theGraph.getNumV(); } catch (Exception ex) { ex.printStackTrace(); System.exit(1); // Error exit. } // Perform the depth\u2010first search. DepthFirstSearch.depthFirstSearch(theGraph, 0); // Topological Sort is the reverse of finish order in dfs. Please update the print statements in the dfs to view topological sort. } } NOTE: To keep DepthFirstSearch class simple, we don't add any data objects for storing discovery and finish orders. One can keep track of finish orders to output topological sort correctly. Algorithms Using Weighted Graphs Dijkstra's Algorithm Used for finding the shortest path from a vertex to all other vertices. Assumes that all of the edge values are positive. Time Complexity: O(|V|^2) Pseudocode 1 function Dijkstra(Graph, source): 2 3 for each vertex v in Graph.Vertices: 4 dist[v] \u2190 INFINITY 5 prev[v] \u2190 UNDEFINED 6 add v to Q 7 dist[source] \u2190 0 8 9 while Q is not empty: 10 u \u2190 vertex in Q with minimum dist[u] 11 remove u from Q 12 13 for each neighbor v of u still in Q: 14 alt \u2190 dist[u] + Graph.Edges(u, v) 15 if alt < dist[v]: 16 dist[v] \u2190 alt 17 prev[v] \u2190 u 18 19 return dist[], prev[] Using a Priority Queue 1 function Dijkstra(Graph, source): 2 create vertex priority queue Q 3 4 dist[source] \u2190 0 // Initialization 5 Q.add_with_priority(source, 0) // associated priority equals dist[\u00b7] 6 7 for each vertex v in Graph.Vertices: 8 if v \u2260 source 9 prev[v] \u2190 UNDEFINED // Predecessor of v 10 dist[v] \u2190 INFINITY // Unknown distance from source to v 11 Q.add_with_priority(v, INFINITY) 12 13 14 while Q is not empty: // The main loop 15 u \u2190 Q.extract_min() // Remove and return best vertex 16 for each neighbor v of u: // Go through all v neighbors of u 17 alt \u2190 dist[u] + Graph.Edges(u, v) 18 if alt < dist[v]: 19 prev[v] \u2190 u 20 dist[v] \u2190 alt 21 Q.decrease_priority(v, alt) 22 23 return dist, prev Implementation package algorithms.graph.shortestpath; import datastructures.graph.Graph; import java.util.HashSet; public class Dijkstra { public static final int UNDEFINED = Integer.MIN_VALUE; public static final double INFINITY = Double.POSITIVE_INFINITY; /** * Dijkstra's Shortest\u2010Path algorithm. * * @param graph The weighted graph to be searched * @param start The start vertex * @param pred Output array to contain the predecessors in the shortest path * @param dist Output array to contain the distance in the shortest path */ public static void dijkstrasAlgorithm(Graph graph, int start, int[] pred, double[] dist) { int numV = graph.getNumV(); System.out.println(numV); HashSet<Integer> vMinusS = new HashSet<>(numV); // Initialization. for (int v = 0; v < numV; v++) { dist[v] = INFINITY; pred[v] = UNDEFINED; vMinusS.add(v); } dist[start] = 0; // Main loop while (!vMinusS.isEmpty()) { // Find the value u in V\u2013S with the smallest dist[u]. double minDist = INFINITY; int u = UNDEFINED; for (int v : vMinusS) { if (dist[v] < minDist) { minDist = dist[v]; u = v; } } // Remove u from vMinusS vMinusS.remove(u); // Update the distances. for (int v : vMinusS) { if (graph.isEdge(u, v)) { double weight = graph.getEdge(u, v).getWeight(); if (dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; pred[v] = u; } } } } } } Minimum Spanning Trees A spanning tree is a subset of the edges of a graph such that there is only one edge between each vertex, and all of the vertices are connected. If we have a spanning tree for a graph, then we can access all the vertices of the graph from the start node. The cost of a spanning tree is the sum of the weights of the edges. We want to find the minimum spanning tree or the spanning tree with the smallest cost. Two algorithms for finding Minimum Spanning Trees: Prim's Algorithm Kruskal Algorithm Prim's Algorithm The algorithm may informally be described as performing the following steps: Initialize a tree with a single vertex, chosen arbitrarily from the graph. Grow the tree by one edge: Of the edges that connect the tree to vertices not yet in the tree, find the minimum-weight edge, and transfer it to the tree. Repeat step 2 (until all vertices are in the tree). Initialize S with the start vertex, s, and V\u2013S with the remaining vertices. for all v in V\u2013S Set p[v] to s. if there is an edge (s, v) Set d[v] to w(s, v). else Set d[v] to \u221e. while V\u2013S is not empty for all u in V\u2013S, find the smallest d[u]. Remove u from V\u2013S and add it to S. Insert the edge (u, p[u]) into the spanning tree. for all v in V\u2013S if w(u, v) < d[v] Set d[v] to w(u, v). Set p[v] to u. Time Complexity: O(|V|^2) Implementation package algorithms.graph.minspanningtree; import datastructures.graph.Edge; import datastructures.graph.Graph; import java.util.*; public class Prim { /** Prim's Minimum Spanning Tree algorithm. @param graph The weighted graph to be searched @param start The start vertex @return An ArrayList of edges that forms the MST */ public static ArrayList<Edge> primsAlgorithm(Graph graph, int start) { ArrayList<Edge> result = new ArrayList<>(); int numV = graph.getNumV(); // Use a HashSet to represent V\u2013S. Set<Integer> vMinusS = new HashSet<>(numV); // Declare the priority queue. Queue<Edge> pQ = new PriorityQueue<>(numV, (e1, e2) -> Double.compare(e1.getWeight(), e2.getWeight())); // Initialize V\u2013S. for (int i = 0; i < numV; i++) { if (i != start) { vMinusS.add(i); } } int current = start; // Main loop while (!vMinusS.isEmpty()) { // Update priority queue. Iterator<Edge> iter = graph.edgeIterator(current); while (iter.hasNext()) { Edge edge = iter.next(); int dest = edge.getDest(); if (vMinusS.contains(dest)) { pQ.add(edge); } } // Find the shortest edge whose source is in S and // destination is in V\u2013S. int dest = -1; Edge edge = null; do { edge = pQ.remove(); dest = edge.getDest(); } while(!vMinusS.contains(dest)); // Take dest out of vMinusS. vMinusS.remove(dest); // Add edge to result. result.add(edge); // Make this the current vertex. current = dest; } return result; } } Kruskal's Algorithm Algorithm Kruskal(G): Input: A simple connected weighted graph G with n vertices and m edges Output: A minimum spanning tree T for G for each vertex v in G do Define an elementary cluster C(v) = {v}. Initialize a priority queue Q to contain all edges in G, using the weights as keys. T =\u2205 {T will ultimately contain the edges of an MST} while T has fewer than n \u2212 1 edges do (u, v) = value returned by Q.removeMin( ) Let C(u) be the cluster containing u, and let C(v) be the cluster containing v. if C(u) not equal to C(v) then Add edge (u, v) to T . Merge C(u) and C(v) into one cluster. return tree T NOTE: Prim's algorithm is better for denser graphs since it iterates over vertices, however Kruskal's algorithm is better for sparser graphs since it iterates over edges.","title":"Graphs"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#graphs","text":"","title":"Graphs"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#graph-terminology","text":"A graph G(V, E) is a data structure that consists of a set of vertices (or nodes) and a set of edges (relations) between the pairs of vertices.","title":"Graph Terminology"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#directed-and-undirected-graphs","text":"Directed Edges : The edges of a graph are directed if the existence of an edge from A to B does not necessarily guarantee that there is a path in both directions. Directed Graph : A graph that contains directed edges is known as a directed graph or digraph . Undirected Graph : A graph that contains undirected edges is known as an undirected graph or simply a graph. Weighted Edges : The edges in a graph may have values associated with them known as their weights . Weighted Graph : A graph with weighted edges is known as weighted graph .","title":"Directed and Undirected Graphs"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#paths-and-cycles","text":"Adjacent Vertex : A vertex is adjacent to another vertex if there is an edge to it from that other vertex. Note that in the case of directed graph , adjacency is not necessarily associative, i.e. if A is adjacent to B, it doesn't necessarily mean that B is adjacent to A (if there is no edge from B to A). Path : A sequence of vertices in which each successive vertex is adjacent to its predecessor. Simple Path : In a simple path, the vertices and edges are distinct, except that the first and last vertices may be the same. Cycle : A cycle is a simple path in which only the first and final vertices are the same. A cycle must contain at least three distinct vertices. Connected Graph : An undirected graph is called a connected graph if there is a path from every vertex to every other vertex. If a graph is not connected, it is considered unconnected , but it will still consist of connected components.","title":"Paths and Cycles"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#the-graph-adt-and-edge-class","text":"Java does not provide a Graph ADT . We can represent the vertices by integers from 0 up to, but not including, |V| . ( |V| means the cardinality of V, or the number of vertices in set V.) For edges we will define the class Edge that will contain the source vertex, the destination vertex, and the weight. For unweighted edges we will use the default value of 1.0. Observe that an Edge is directed. For undirected graphs, we will always have two Edge objects: one in each direction for each pair of vertices that has an edge between them. A vertex is represented by a type int variable. Data Field Attribute private int dest The destination vertex for an edge private int source The source vertex for an edge private double weight The weight Constructor Purpose public Edge(int source, int dest) Constructs an Edge from source to dest. Sets the weight to 1.0 public Edge(int source, int dest, double w) Constructs an Edge from source to dest. Sets the weight to w Method Behavior public boolean equals(Object o) Compares two edges for equality. Edges are equal if their source and destination vertices are the same. The weight is not considered public int getDest() Returns the destination vertex public int getSource() Returns the source vertex public double getWeight() Returns the weight public int hashCode() Returns the hash code for an edge. The hash code depends only on the source and destination public String toString() Returns a string representation of the edge package datastructures.graph; public class Edge { private int source; private int dest; private double weight; public Edge(int source, int dest) { this.source = source; this.dest = dest; this.weight = 1.0; } public Edge(int source, int dest, double weight) { this.source = source; this.dest = dest; this.weight = weight; } public int getSource() { return source; } public int getDest(){ return dest; } public double getWeight() { return weight; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || this.getClass() != o.getClass()) return false; Edge edge = (Edge) o; return source == edge.source && dest == edge.dest; } @Override public int hashCode() { int result = Integer.hashCode(source); result = 31 * result + Integer.hashCode(dest); return result; } @Override public String toString() { return \"Edge{\" + \"source=\" + source + \", dest=\" + dest + \", weight=\" + weight + '}'; } }","title":"The Graph ADT and Edge Class"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#implementing-the-graph-adt","text":"Two representations of graphs are most common: Adjacency List : Edges are represented by an array of lists called adjacency lists , where each list stores the vertices adjacent to a particular vertex. Adjacency Matrix : Edges are represented by a two\u2010dimensional array, called an adjacency matrix , with |V|rows and |V| columns.","title":"Implementing the Graph ADT"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#adjacency-list","text":"An adjacency list representation of a graph uses an array of lists. There is one list for each vertex. The vertices are in no particular order. The Edge must be stored (not just the destination) because weighted graphs can have different values for weights. For an undirected graph (or simply a \u201cgraph\u201d), symmetric entries are required.","title":"Adjacency List"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#adjacency-matrix","text":"The adjacency matrix uses a two\u2010dimensional array to represent the graph. For an unweighted graph, the entries in this matrix can be boolean values, where true represents the presence of an edge and false its absence. Another popular method is to use the value 1 for an edge and 0 for no edge. The integer coding has benefits over the boolean approach for some graph algorithms that use matrix multiplication. For a weighted graph, the matrix would contain the weights. Since 0 is a valid weight, we will use Double.POSITIVE_INFINITY (a special double value in Java that approximates the mathematical behavior of infinity) to indicate the absence of an edge, and in an unweighted graph we will use a weight of 1.0 to indicate the presence of an edge. If the graph is undirected, then the matrix is symmetric, and only the lower diagonal of the matrix needs be saved.","title":"Adjacency Matrix"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#overview-of-the-hierarchy","text":"","title":"Overview of the Hierarchy"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#class-abstractgraph","text":"Data Field Attribute private boolean directed True if this is a directed graph private int numV The number of vertices Constructor Purpose public AbstractGraph(int numV, boolean directed) Constructs an empty graph with the specified number of vertices and with the specified directed flag. If directed is true, this is a directed graph Method Behavior public int getNumV() Gets the number of vertices public boolean isDirected() Returns true if the graph is a directed graph public void loadEdgesFromFile(Scanner scan) Loads edges from a data file public static Graph createGraph(Scanner scan, boolean isDirected, String type) Factory method to create a graph and load the data from an input file","title":"Class AbstractGraph"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#implementation","text":"package datastructures.graph; import java.util.*; import java.io.*; /** Abstract base class for graphs. A graph is a set of vertices and a set of edges. Vertices are represented by integers from 0 to n \u2010 1. Edges are ordered pairs of vertices. */ public abstract class AbstractGraph implements Graph { // Data Fields /** * The number of vertices */ private int numV; /** * Flag to indicate whether this is a directed graph */ private boolean directed; // Constructor /** * Construct a graph with the specified number of vertices and the directed * flag. If the directed flag is true, this is a directed graph. * * @param numV The number of vertices * @param directed The directed flag */ public AbstractGraph(int numV, boolean directed) { this.numV = numV; this.directed = directed; } // Accessor Methods /** * Return the number of vertices. * * @return The number of vertices */ public int getNumV() { return numV; } /** * Return whether this is a directed graph. * * @return true if this is a directed graph */ public boolean isDirected() { return directed; } // Other Methods /** * Load the edges of a graph from the data in an input file. The file * should contain a series of lines, each line with two or * three data values. The first is the source, the second is * the destination, and the optional third is the weight. * * @param scan The Scanner connected to the data file */ public void loadEdgesFromFile(Scanner scan) { while (scan.hasNextLine()) { String line = scan.nextLine().trim(); if (line.isEmpty()) continue; // Skip empty lines String[] tokens = line.split(\"\\\\s+\"); if (tokens.length < 2 || tokens.length > 3) { throw new IllegalArgumentException(\"Invalid edge format: \" + line); } try { int source = Integer.parseInt(tokens[0]); int dest = Integer.parseInt(tokens[1]); double weight = (tokens.length == 3) ? Double.parseDouble(tokens[2]) : 1.0; // Add edge to the graph insert(new Edge(source, dest, weight)); } catch (NumberFormatException e) { throw new IllegalArgumentException(\"Invalid number format in line: \" + line, e); } } } /** * Factory method to create a graph and load the data from an input * file. The first line of the input file should contain the number * of vertices. The remaining lines should contain the edge data as * described under loadEdgesFromFile. * * @param scan The Scanner connected to the data file * @param isDirected true if this is a directed graph, * false otherwise * @param type The string \"Matrix\" if an adjacency matrix is to be * created, and the string \"List\" if an adjacency list * is to be created * @throws IllegalArgumentException if type is neither \"Matrix\" * nor \"List\" */ public static Graph createGraph(Scanner scan, boolean isDirected, String type) { int numV = scan.nextInt(); AbstractGraph returnValue; type = type.toLowerCase(); switch (type) { case \"matrix\": returnValue = new MatrixGraph(numV, isDirected); break; case \"list\": returnValue = new ListGraph(numV, isDirected); break; default: throw new IllegalArgumentException(); } returnValue.loadEdgesFromFile(scan); return returnValue; } }","title":"Implementation"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#the-listgraph-class","text":"Data Field Attribute private List<Edge>[] edges An array of Lists to contain the edges that originate with each vertex Constructor Purpose public ListGraph(int numV, boolean directed) Constructs a graph with the specified number of vertices and directionality Method Behavior public Iterator<Edge> edgeIterator(int source) Returns an iterator to the edges that originate from a given vertex public Edge getEdge(int source, int dest) Gets the edge between two vertices public void insert(Edge e) Inserts a new edge into the graph public boolean isEdge(int source, int dest) Determines if there is an edge between the given vertices","title":"The ListGraph Class"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#implementation_1","text":"package datastructures.graph; import java.util.*; /** A ListGraph is an extension of the AbstractGraph abstract class that uses an array of lists to represent the edges. */ public class ListGraph extends AbstractGraph { // Data Field /** * An array of Lists to contain the edges that * originate with each vertex. */ private List<Edge>[] edges; /** * Construct a graph with the specified number of vertices and directionality. * * @param numV The number of vertices * @param directed The directionality flag */ public ListGraph(int numV, boolean directed) { super(numV, directed); edges = new List[numV]; for (int i = 0; i < numV; i++) { edges[i] = new LinkedList<Edge>(); } } /** * Insert a new edge into the graph. * * @param edge The new edge */ public void insert(Edge edge) { edges[edge.getSource()].add(edge); if (!isDirected()) { edges[edge.getDest()].add(new Edge(edge.getDest(), edge.getSource(), edge.getWeight())); } } /** * Get the edge between two vertices. * * @param source The source * @param dest The destination * @return the edge between these two vertices * or null if an edge does not exist. */ public Edge getEdge(int source, int dest) { Edge target = new Edge(source, dest, Double.POSITIVE_INFINITY); for (Edge edge : edges[source]) { if (edge.equals(target)) return edge; // Desired edge found, return it. } // Assert: All edges for source checked. return null; // Desired edge not found. } /** * Determine whether an edge exists. * * @param source The source vertex * @param dest The destination vertex * @return true if there is an edge from source to dest */ public boolean isEdge(int source, int dest) { return edges[source].contains(new Edge(source, dest)); } public Iterator<Edge> edgeIterator(int source) { return edges[source].iterator(); } }","title":"Implementation"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#the-matrixgraph-class","text":"package datastructures.graph; import java.util.ArrayList; import java.util.Iterator; import java.util.LinkedList; import java.util.List; public class MatrixGraph extends AbstractGraph{ private double[][] edges; public MatrixGraph(int numV, boolean isDirected) { super(numV, isDirected); edges = new double[numV][numV]; for (int i = 0; i < numV; i++) { for (int j = 0; j < numV; j++) { edges[i][j] = Double.POSITIVE_INFINITY; } } } @Override public void insert(Edge edge) { edges[edge.getSource()][edge.getDest()] = edge.getWeight(); if(!isDirected()){ edges[edge.getDest()][edge.getSource()] = edge.getWeight(); } } @Override public boolean isEdge(int source, int dest) { return edges[source][dest] != Double.POSITIVE_INFINITY; } @Override public Edge getEdge(int source, int dest) { return edges[source][dest] == Double.POSITIVE_INFINITY ? null : new Edge(source, dest); } @Override public Iterator<Edge> edgeIterator(int source) { List<Edge> edges = new LinkedList<>(); for(int i = 0; i < this.getNumV(); i++){ if(this.edges[source][i] != Double.POSITIVE_INFINITY){ edges.add(getEdge(source, i)); } } return edges.iterator(); } }","title":"The MatrixGraph Class"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#complexity-analysis","text":"The density of a graph is the ratio of |E| to |V|^2 . A dense graph is one in which |E| is close to but less than |V|^2 .","title":"Complexity Analysis"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#time-efficiency","text":"Many graph algorithms are of the form: java 1. for each vertex u in the graph 2. for each vertex v adjacent to u 3. Do something with edge (u, v). Adjacency List: O(|E|) . Adjacency Matrix: O(|V|^2) . Thus, for a sparse graph, the adjacency list gives better performance for this type of algorithm. Some graph are of the form: java 1. for each vertex u in some subset of the vertices 2. for each vertex v in some subset of the vertices 3. if (u, v) is an edge 4. Do something with edge (u, v). Adjacency List: O(|V||E|) . Adjacency Matrix: O(|V|^2) . Since the search step is O(1) . Thus, for a dense graph, the adjacency matrix gives better performance for this type of algorithm.","title":"Time Efficiency"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#storage-efficiency","text":"Adjacency Matrix: O(|V|^2) If the graph is sparse, there will be a lot of wasted space in the adjacency matrix. On the other hand, in an adjacency list, each edge is represented by a reference to an Edge object containing data about the source, destination, and weight as well as a reference to the next edge in the list. Therefore, the adjacency list uses less storage when less than 25 percent of the adjacency matrix would be filled.","title":"Storage Efficiency"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#the-mapgraph-class","text":"We can achieve the performance benefits of both the ListGraph and MatrixGraph by making a slight modification to the ListGraph . Replacing the array of List<Edge> with an array of Map<Integer, Edge> allows us to query the existence of an edge in O(1) time, and using the LinkedHashMap allows iterating through the edges adjacent to a given vertex in O(|E_u|) . package datastructures.graph; import java.util.*; /** A MapGraph is an extension of the AbstractGraph abstract class that uses an array of maps to represent the edges. */ public class MapGraph extends AbstractGraph { // Data Field /** * An array of maps to contain the edges that * originate with each vertex. */ private Map<Integer, Edge>[] outgoingEdges; /** * Construct a graph with the specified number of vertices and directionality. * * @param numV The number of vertices * @param directed The directionality flag */ public MapGraph(int numV, boolean directed) { super(numV, directed); outgoingEdges = new Map[numV]; for (int i = 0; i < numV; i++) { outgoingEdges[i] = new LinkedHashMap<>(); } } /** * Insert a new edge into the graph. * * @param edge The new edge */ public void insert(Edge edge) { int source = edge.getSource(); int dest = edge.getDest(); double weight = edge.getWeight(); outgoingEdges[source].put(dest, edge); if (!isDirected()) { Edge reverseEdge = new Edge(dest, source, weight); outgoingEdges[dest].put(source, reverseEdge); } } /** * Get the edge between two vertices. * * @param source The source * @param dest The destination * @return the edge between these two vertices * or null if an edge does not exist. */ public Edge getEdge(int source, int dest) { return outgoingEdges[source].get(dest); } /** * Determine whether an edge exists. * * @param source The source vertex * @param dest The destination vertex * @return true if there is an edge from source to dest */ public boolean isEdge(int source, int dest) { return outgoingEdges[source].containsKey(dest); } public Iterator<Edge> edgeIterator(int source) { return outgoingEdges[source].values().iterator(); } }","title":"The MapGraph Class"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#graph-traversals","text":"The two most common traversal algorithms are breadth-first and depth-first search.","title":"Graph Traversals"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#breadth-first-search","text":"1. Take an arbitrary start vertex, mark it visited and place it in a queue. 2. while the queue is not empty 3. Take a vertex u. 4. for all vertices, v, adjacent to this vertex, u 5. if v has not been visited 6. Mark it visited . 7. Insert vertex v into the queue. NOTE: A path starting at the root to any vertex in the tree is the shortest path in the original graph from the start vertex to that vertex, where we consider all edges to have the same weight. Therefore, the shortest path is the one that goes through the smallest number of vertices. We can save the information we need to represent this tree by storing the parent of each vertex when we identify it (Step 7 of the breadth\u2010first algorithm). Refinement of Step 7 of Breadth\u2010First Search Algorithm 7.1 Insert vertex v into the queue. 7.2 Set the parent of v to u. Time Complexity: O(|E|) package algorithms.graph.search; import datastructures.graph.Edge; import datastructures.graph.Graph; import java.util.Iterator; import java.util.LinkedList; import java.util.Queue; /** Class to implement the breadth\u2010first search algorithm. */ public class BreadthFirstSearch { /** Perform a breadth\u2010first search of a graph. @post The array parent will contain the predecessor of each vertex in the breadth\u2010first search tree. @param graph The graph to be searched @param start The start vertex @return The array of parents */ public static int[] breadthFirstSearch(Graph graph, int start) { Queue<Integer> queue = new LinkedList<Integer>(); // Declare array parent and initialize its elements to \u20131. int[] parent = new int[graph.getNumV()]; for (int i = 0; i < graph.getNumV(); i++) { parent[i] = -1; } // Declare array visited and initialize its elements to false. boolean[] visited = new boolean[graph.getNumV()]; // Mark the start vertex as visited and insert it into the queue. visited[start] = true; queue.offer(start); // Perform breadth\u2010first search until done while (!queue.isEmpty()) { // Take a vertex, current, out of the queue. int current = queue.remove(); System.out.print(current + \"\\t\"); // Examine each vertex, neighbor, adjacent to current. Iterator<Edge> itr = graph.edgeIterator(current); while (itr.hasNext()) { Edge edge = itr.next(); int neighbor = edge.getDest(); if (!visited[neighbor]) { // Mark it visited. visited[neighbor] = true; // Place it into the queue. queue.offer(neighbor); // Insert the edge (current, neighbor) into the tree. parent[neighbor] = current; } } } return parent; } }","title":"Breadth-First Search"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#depth-first-search","text":"1. Mark the current vertex, u, visited. 2. for each vertex, v, adjacent to the current vertex, u 3. if v has not been visited 4. Set parent of v to u. 5. Recursively apply this algorithm starting at v. package algorithms.graph.search; import datastructures.graph.Edge; import datastructures.graph.Graph; import java.util.Arrays; import java.util.Iterator; /** Class to implement the depth\u2010first search algorithm. */ public class DepthFirstSearch { /** Start depth\u2010first search the graph starting at vertex start. @param graph The graph object. @param start The start vertex */ public static void depthFirstSearch(Graph graph, int start){ int n = graph.getNumV(); boolean[] visited = new boolean[n]; int[] parent = new int[n]; Arrays.fill(parent, -1); depthFirstSearchRecurse(graph, start, visited, parent); } /** Recursively depth\u2010first search the graph starting at vertex current. @param graph The graph object. @param current The start vertex @param visited Boolean array of visited nodes @param parent Integer array of parent nodes for corresponding vertices. */ private static void depthFirstSearchRecurse(Graph graph, int current, boolean[] visited, int[] parent) { /* Mark the current vertex visited. */ visited[current] = true; // Print by discovery order. System.out.print(current + \"\\t\"); /* Examine each vertex adjacent to the current vertex */ Iterator<Edge> itr = graph.edgeIterator(current); while (itr.hasNext()) { int neighbor = itr.next().getDest(); /* Process a neighbor that has not been visited */ if (!visited[neighbor]) { /* Insert (current, neighbor) into the depth\u2010first search tree. */ parent[neighbor] = current; /* Recursively apply the algorithm starting at neighbor. */ depthFirstSearchRecurse(graph, neighbor, visited, parent); } } // Print by finish order. // System.out.print(current + \"\\t\"); } } Time Complexity: O(|E|) . Please note that there is an implicit step 0 of the algorithm to that marks all vertices as unvisited. This is O(|V|) , thus, the total running time of the algorithm is O(|V|+|E|) .","title":"Depth-First Search"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#topological-sort","text":"A topological sort of the vertices of a DAG (Directed Acyclic Graph) is an ordering of the vertices such that if (u, v) is an edge, then u appears before v. This must be true for all edges. If there is an edge from u to v in a DAG, then if we perform depth-first search of this graph, the finish time of u must be after the finish time of v. Algorithm for Topological Sort 1. Perform a depth\u2010first search of the graph. 2. List the vertices in reverse of their finish order. package algorithms.graph.sort; import algorithms.graph.search.DepthFirstSearch; import datastructures.graph.AbstractGraph; import datastructures.graph.Graph; import java.io.File; import java.util.*; /** This program outputs the topological sort of a directed graph that contains no cycles. */ public class TopologicalSort { /** * The main method that performs the topological sort. * * @param args The command line arguments * @pre arg[0] contains the name of the file * that contains the graph. It has no cycles. */ public static void main(String[] args) { Graph theGraph = null; int numVertices = 0; try { // Connect Scanner to input file. Scanner scan = new Scanner(new File(args[0])); // Load the graph data from a file. theGraph = AbstractGraph.createGraph(scan, true, \"List\"); numVertices = theGraph.getNumV(); } catch (Exception ex) { ex.printStackTrace(); System.exit(1); // Error exit. } // Perform the depth\u2010first search. DepthFirstSearch.depthFirstSearch(theGraph, 0); // Topological Sort is the reverse of finish order in dfs. Please update the print statements in the dfs to view topological sort. } } NOTE: To keep DepthFirstSearch class simple, we don't add any data objects for storing discovery and finish orders. One can keep track of finish orders to output topological sort correctly.","title":"Topological Sort"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#algorithms-using-weighted-graphs","text":"","title":"Algorithms Using Weighted Graphs"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#dijkstras-algorithm","text":"Used for finding the shortest path from a vertex to all other vertices. Assumes that all of the edge values are positive. Time Complexity: O(|V|^2)","title":"Dijkstra's Algorithm"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#pseudocode","text":"1 function Dijkstra(Graph, source): 2 3 for each vertex v in Graph.Vertices: 4 dist[v] \u2190 INFINITY 5 prev[v] \u2190 UNDEFINED 6 add v to Q 7 dist[source] \u2190 0 8 9 while Q is not empty: 10 u \u2190 vertex in Q with minimum dist[u] 11 remove u from Q 12 13 for each neighbor v of u still in Q: 14 alt \u2190 dist[u] + Graph.Edges(u, v) 15 if alt < dist[v]: 16 dist[v] \u2190 alt 17 prev[v] \u2190 u 18 19 return dist[], prev[]","title":"Pseudocode"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#using-a-priority-queue","text":"1 function Dijkstra(Graph, source): 2 create vertex priority queue Q 3 4 dist[source] \u2190 0 // Initialization 5 Q.add_with_priority(source, 0) // associated priority equals dist[\u00b7] 6 7 for each vertex v in Graph.Vertices: 8 if v \u2260 source 9 prev[v] \u2190 UNDEFINED // Predecessor of v 10 dist[v] \u2190 INFINITY // Unknown distance from source to v 11 Q.add_with_priority(v, INFINITY) 12 13 14 while Q is not empty: // The main loop 15 u \u2190 Q.extract_min() // Remove and return best vertex 16 for each neighbor v of u: // Go through all v neighbors of u 17 alt \u2190 dist[u] + Graph.Edges(u, v) 18 if alt < dist[v]: 19 prev[v] \u2190 u 20 dist[v] \u2190 alt 21 Q.decrease_priority(v, alt) 22 23 return dist, prev","title":"Using a Priority Queue"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#implementation_2","text":"package algorithms.graph.shortestpath; import datastructures.graph.Graph; import java.util.HashSet; public class Dijkstra { public static final int UNDEFINED = Integer.MIN_VALUE; public static final double INFINITY = Double.POSITIVE_INFINITY; /** * Dijkstra's Shortest\u2010Path algorithm. * * @param graph The weighted graph to be searched * @param start The start vertex * @param pred Output array to contain the predecessors in the shortest path * @param dist Output array to contain the distance in the shortest path */ public static void dijkstrasAlgorithm(Graph graph, int start, int[] pred, double[] dist) { int numV = graph.getNumV(); System.out.println(numV); HashSet<Integer> vMinusS = new HashSet<>(numV); // Initialization. for (int v = 0; v < numV; v++) { dist[v] = INFINITY; pred[v] = UNDEFINED; vMinusS.add(v); } dist[start] = 0; // Main loop while (!vMinusS.isEmpty()) { // Find the value u in V\u2013S with the smallest dist[u]. double minDist = INFINITY; int u = UNDEFINED; for (int v : vMinusS) { if (dist[v] < minDist) { minDist = dist[v]; u = v; } } // Remove u from vMinusS vMinusS.remove(u); // Update the distances. for (int v : vMinusS) { if (graph.isEdge(u, v)) { double weight = graph.getEdge(u, v).getWeight(); if (dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; pred[v] = u; } } } } } }","title":"Implementation"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#minimum-spanning-trees","text":"A spanning tree is a subset of the edges of a graph such that there is only one edge between each vertex, and all of the vertices are connected. If we have a spanning tree for a graph, then we can access all the vertices of the graph from the start node. The cost of a spanning tree is the sum of the weights of the edges. We want to find the minimum spanning tree or the spanning tree with the smallest cost. Two algorithms for finding Minimum Spanning Trees: Prim's Algorithm Kruskal Algorithm","title":"Minimum Spanning Trees"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#prims-algorithm","text":"The algorithm may informally be described as performing the following steps: Initialize a tree with a single vertex, chosen arbitrarily from the graph. Grow the tree by one edge: Of the edges that connect the tree to vertices not yet in the tree, find the minimum-weight edge, and transfer it to the tree. Repeat step 2 (until all vertices are in the tree). Initialize S with the start vertex, s, and V\u2013S with the remaining vertices. for all v in V\u2013S Set p[v] to s. if there is an edge (s, v) Set d[v] to w(s, v). else Set d[v] to \u221e. while V\u2013S is not empty for all u in V\u2013S, find the smallest d[u]. Remove u from V\u2013S and add it to S. Insert the edge (u, p[u]) into the spanning tree. for all v in V\u2013S if w(u, v) < d[v] Set d[v] to w(u, v). Set p[v] to u. Time Complexity: O(|V|^2)","title":"Prim's Algorithm"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#implementation_3","text":"package algorithms.graph.minspanningtree; import datastructures.graph.Edge; import datastructures.graph.Graph; import java.util.*; public class Prim { /** Prim's Minimum Spanning Tree algorithm. @param graph The weighted graph to be searched @param start The start vertex @return An ArrayList of edges that forms the MST */ public static ArrayList<Edge> primsAlgorithm(Graph graph, int start) { ArrayList<Edge> result = new ArrayList<>(); int numV = graph.getNumV(); // Use a HashSet to represent V\u2013S. Set<Integer> vMinusS = new HashSet<>(numV); // Declare the priority queue. Queue<Edge> pQ = new PriorityQueue<>(numV, (e1, e2) -> Double.compare(e1.getWeight(), e2.getWeight())); // Initialize V\u2013S. for (int i = 0; i < numV; i++) { if (i != start) { vMinusS.add(i); } } int current = start; // Main loop while (!vMinusS.isEmpty()) { // Update priority queue. Iterator<Edge> iter = graph.edgeIterator(current); while (iter.hasNext()) { Edge edge = iter.next(); int dest = edge.getDest(); if (vMinusS.contains(dest)) { pQ.add(edge); } } // Find the shortest edge whose source is in S and // destination is in V\u2013S. int dest = -1; Edge edge = null; do { edge = pQ.remove(); dest = edge.getDest(); } while(!vMinusS.contains(dest)); // Take dest out of vMinusS. vMinusS.remove(dest); // Add edge to result. result.add(edge); // Make this the current vertex. current = dest; } return result; } }","title":"Implementation"},{"location":"data-structures/chp6-graphs/6-1-graphs.html#kruskals-algorithm","text":"Algorithm Kruskal(G): Input: A simple connected weighted graph G with n vertices and m edges Output: A minimum spanning tree T for G for each vertex v in G do Define an elementary cluster C(v) = {v}. Initialize a priority queue Q to contain all edges in G, using the weights as keys. T =\u2205 {T will ultimately contain the edges of an MST} while T has fewer than n \u2212 1 edges do (u, v) = value returned by Q.removeMin( ) Let C(u) be the cluster containing u, and let C(v) be the cluster containing v. if C(u) not equal to C(v) then Add edge (u, v) to T . Merge C(u) and C(v) into one cluster. return tree T NOTE: Prim's algorithm is better for denser graphs since it iterates over vertices, however Kruskal's algorithm is better for sparser graphs since it iterates over edges.","title":"Kruskal's Algorithm"},{"location":"data-structures/chp7-advanced-trees/7-1-advanced-trees.html","text":"Advanced Trees \ud83d\udea8 Coming Soon!","title":"Advanced Trees"},{"location":"data-structures/chp7-advanced-trees/7-1-advanced-trees.html#advanced-trees","text":"","title":"Advanced Trees"},{"location":"data-structures/chp7-advanced-trees/7-1-advanced-trees.html#coming-soon","text":"","title":"\ud83d\udea8 Coming Soon!"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html","text":"1.1. Data Types There are eight primitive types in Java. Four of them are integer types Two are \ufb02oating-point number types One is the character type char , used for code units in the Unicode encoding scheme One is a boolean type for truth values. Since Java programs must run with the same results on all machines, the ranges for the various types are \ufb01xed. 1.1.1. Integer Types Type Storage Requirement Range (Inclusive) int 4 bytes -2,147,483,648 to 2,147,483,647 (just over 2 billion) short 2 bytes -32,768 to 32,767 long 8 bytes -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 byte 1 byte -128 to 127 1.1.2. Floating-Point Types Type Storage Requirement Range float 4 bytes Approximately \u00b13.40282347\u00d710\u00b3\u2078 (6\u20137 significant decimal digits) double 8 bytes Approximately \u00b11.79769313486231570\u00d710\u00b3\u2070\u2078 (15 significant decimal digits) NOTE: If you need precise numerical computations without roundoff errors, use the BigDecimal class 1.1.3. The char Type In Java, the char type describes a code unit in the UTF-16 encoding (2 bytes) . It is strongly recommended against using the char type in your programs unless you are actually manipulating UTF-16 code units. You are almost always better off treating strings as abstract data types. 1.1.4. The boolean Type The boolean type has two values, false and true . 1.2. Variables and Constants It is probably more common in Java to create a constant so it\u2019s available to multiple methods inside a single class. These are usually called class constants. Set up a class constant with the keywords static final . Note that the de\ufb01nition of the class constant appears outside the main method. Thus, the constant can also be used in other methods of the same class. Furthermore, if the constant is declared, as in this example, public , methods of other classes can also use it. 1.3. Operators 1.3.1. Mathematical Functions Useful mathematical functions: Math.floorMod Math.pow Static Imports You can avoid the Math pre\ufb01x for the mathematical methods and constants by adding the following line to the top of your source \ufb01le: java import static java.lang.Math.*; The Math class provides several methods to make integer arithmetic safer . The mathematical operators quietly return wrong results when a computation over\ufb02ows. If you call Math.multiplyExact(1000000000, 3) instead, an exception is generated. You can catch that exception or let the program terminate rather than quietly continue with a wrong result. There are also methods addExact , subtractExact , incrementExact , decrementExact , negateExact , and absExact , all with int and long parameters. 1.3.2 Conversion between Numeric Types The three dotted arrows denote conversions that may lose precision. 1.3.3. Increment and Decrement Operators There is also a pre\ufb01x form, ++n . Both change the value of the variable by 1. The difference between the two appears only when they are used inside expressions. The pre\ufb01x form does the addition \ufb01rst; the post\ufb01x form evaluates to the old value of the variable. 1.3.4. Relational and boolean Operators The && and || operators are evaluated in short circuit fashion: The second argument is not evaluated if the \ufb01rst argument already determines the value. This behavior can be exploited to avoid errors. 1.3.5. The Conditional Operator condition ? expression1 : expression2 1.3.6. Switch Expressions If you need to choose among more than two values, then you can use a switch expression (as of Java 14 ). The case labels can also be strings or constants of an enumerated type. String seasonName = switch (seasonCode) { case 0 -> \"Spring\"; case 1 -> \"Summer\"; case 2 -> \"Fall\"; case 3 -> \"Winter\"; default -> \"???\"; }; As of Java 14, there are four (!) forms of switch . 1.3.7. Bitwise Operators & (\u201cand\u201d) | (\u201cor\u201d) ^ (\u201cxor\u201d) ~ (\u201cnot\u201d) There are also >> and << operators which shift a bit pattern right or left. The right-hand argument of the shift operators is reduced modulo 32 (unless the left-hand argument is a long, in which case the right-hand argument is reduced modulo 64). Representing a binary number is as follows: 0b1000 or 0B100 1.4. Strings NOTE: We should include Integer , Double , and String classes. I had some notes for them at some interview prep place (maybe for AWS?).","title":"1.1. Data Types"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#11-data-types","text":"There are eight primitive types in Java. Four of them are integer types Two are \ufb02oating-point number types One is the character type char , used for code units in the Unicode encoding scheme One is a boolean type for truth values. Since Java programs must run with the same results on all machines, the ranges for the various types are \ufb01xed.","title":"1.1. Data Types"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#111-integer-types","text":"Type Storage Requirement Range (Inclusive) int 4 bytes -2,147,483,648 to 2,147,483,647 (just over 2 billion) short 2 bytes -32,768 to 32,767 long 8 bytes -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 byte 1 byte -128 to 127","title":"1.1.1. Integer Types"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#112-floating-point-types","text":"Type Storage Requirement Range float 4 bytes Approximately \u00b13.40282347\u00d710\u00b3\u2078 (6\u20137 significant decimal digits) double 8 bytes Approximately \u00b11.79769313486231570\u00d710\u00b3\u2070\u2078 (15 significant decimal digits) NOTE: If you need precise numerical computations without roundoff errors, use the BigDecimal class","title":"1.1.2. Floating-Point Types"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#113-the-char-type","text":"In Java, the char type describes a code unit in the UTF-16 encoding (2 bytes) . It is strongly recommended against using the char type in your programs unless you are actually manipulating UTF-16 code units. You are almost always better off treating strings as abstract data types.","title":"1.1.3. The char Type"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#114-the-boolean-type","text":"The boolean type has two values, false and true .","title":"1.1.4. The boolean Type"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#12-variables-and-constants","text":"It is probably more common in Java to create a constant so it\u2019s available to multiple methods inside a single class. These are usually called class constants. Set up a class constant with the keywords static final . Note that the de\ufb01nition of the class constant appears outside the main method. Thus, the constant can also be used in other methods of the same class. Furthermore, if the constant is declared, as in this example, public , methods of other classes can also use it.","title":"1.2. Variables and Constants"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#13-operators","text":"","title":"1.3. Operators"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#131-mathematical-functions","text":"Useful mathematical functions: Math.floorMod Math.pow Static Imports You can avoid the Math pre\ufb01x for the mathematical methods and constants by adding the following line to the top of your source \ufb01le: java import static java.lang.Math.*; The Math class provides several methods to make integer arithmetic safer . The mathematical operators quietly return wrong results when a computation over\ufb02ows. If you call Math.multiplyExact(1000000000, 3) instead, an exception is generated. You can catch that exception or let the program terminate rather than quietly continue with a wrong result. There are also methods addExact , subtractExact , incrementExact , decrementExact , negateExact , and absExact , all with int and long parameters.","title":"1.3.1. Mathematical Functions"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#132-conversion-between-numeric-types","text":"The three dotted arrows denote conversions that may lose precision.","title":"1.3.2 Conversion between Numeric Types"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#133-increment-and-decrement-operators","text":"There is also a pre\ufb01x form, ++n . Both change the value of the variable by 1. The difference between the two appears only when they are used inside expressions. The pre\ufb01x form does the addition \ufb01rst; the post\ufb01x form evaluates to the old value of the variable.","title":"1.3.3. Increment and Decrement Operators"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#134-relational-and-boolean-operators","text":"The && and || operators are evaluated in short circuit fashion: The second argument is not evaluated if the \ufb01rst argument already determines the value. This behavior can be exploited to avoid errors.","title":"1.3.4. Relational and boolean Operators"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#135-the-conditional-operator","text":"condition ? expression1 : expression2","title":"1.3.5. The Conditional Operator"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#136-switch-expressions","text":"If you need to choose among more than two values, then you can use a switch expression (as of Java 14 ). The case labels can also be strings or constants of an enumerated type. String seasonName = switch (seasonCode) { case 0 -> \"Spring\"; case 1 -> \"Summer\"; case 2 -> \"Fall\"; case 3 -> \"Winter\"; default -> \"???\"; }; As of Java 14, there are four (!) forms of switch .","title":"1.3.6. Switch Expressions"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#137-bitwise-operators","text":"& (\u201cand\u201d) | (\u201cor\u201d) ^ (\u201cxor\u201d) ~ (\u201cnot\u201d) There are also >> and << operators which shift a bit pattern right or left. The right-hand argument of the shift operators is reduced modulo 32 (unless the left-hand argument is a long, in which case the right-hand argument is reduced modulo 64). Representing a binary number is as follows: 0b1000 or 0B100","title":"1.3.7. Bitwise Operators"},{"location":"java/chp1-fundamental-programming-structures/chp1-fundamentals.html#14-strings","text":"NOTE: We should include Integer , Double , and String classes. I had some notes for them at some interview prep place (maybe for AWS?).","title":"1.4. Strings"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html","text":"Chapter 2: Objects and Classes 2.1. Introduction to Object-Oriented Programming 4 Pillars of OOP: 1. Abstraction: The process of hiding implementation details and exposing only the functionality to the user. In abstraction, we deal with ideas and not events. This means the user will only know \u201cwhat it does\u201d rather than \u201chow it does\u201d. 2. Encapsulation: In software systems, encapsulation refers to the bundling of data with the mechanisms or methods that operate on the data. It may also refer to the limiting of direct access to some of that data, such as an object's components. Essentially, encapsulation prevents external code from being concerned with the internal workings of an object. 3. Inheritance: The process of one class inheriting properties and methods from another class in Java. Inheritance is used when we have is-a relationship between objects. Inheritance in Java is implemented using extends keyword. 4. Polymorphism: Polymorphism in Java is a core concept of object-oriented programming (OOP) that allows objects to be treated as instances of their parent class . It facilitates flexibility and the ability to define methods in multiple forms. Polymorphism is primarily achieved through method overriding and method overloading. There are two types of polymorphism as listed below: Static or Compile-time Polymorphism (Overloading) Dynamic or Run-time Polymorphism (Overriding) Static or Compile-time Polymorphism occurs when the compiler is able to determine the actual function, it\u2019s called compile-time * polymorphism. Compile-time polymorphism can be achieved by method overloading in Java. When different functions in a class have the same name but different signatures, it\u2019s called method overloading . A method signature contains the name and method arguments. So, overloaded methods have different arguments. The arguments might differ in the numbers or the type of arguments. Dynamic or Run-time Polymorphism occurs when the compiler is not able to determine at compile-time which method (superclass or subclass) will be called. This decision is made at run-time. Run-time polymorphism is achieved through method overriding**, which happens when a method in a subclass has the same name, return type, and parameters as a method in its superclass. When the superclass method is overridden in the subclass, it is called method overriding. 2.1.1. Classes A class is a blueprint for objects. In Java, all classes extend the cosmic superclass called `Object. 2.1.2. Objects An object is an instance of the class, which has consists of a state and behavior . 2.1.3. Identifying Classes In a traditional procedural program, you start the process at the top, with the main function. When designing an OOP system, there is no top and newcomers to OOP often wonder where to begin. A simple rule of thumb in identifying classes is to look for nouns in the problem analysis. Methods, on the other hand, correspond to verbs . 2.1.4. Relationships Between Classes The most common relationships between classes are: - Dependence ( uses-a ) - Aggregation ( has-a ) - Inheritance ( is-a ) NOTE: UML notations are used for describing the relationships between classes. 2.2. Using Predefined Classes 2.2.1. Objects and Object Variables There is an important difference between objects and object variables. Date startTime; // startTime doesn't refer to any object The statement defines an object variable, startTime , that can refer to objects of type Date . It is important to realize that the variable startTime is not an object and, in fact, does not even refer to an object yet. You cannot use any Date methods on this variable at this time. The statement s = startTime.toString(); would cause a compile-time error. You must first initialize the startTime variable. It is important to realize that an object variable doesn't actually contain an object . It only refers to an object. In Java, the value of any object variable is a reference to an object that is stored elsewhere. The return value of the new operator is also a reference . You can explicitly set an object variable to null to indicate that it currently refers to no object. C++ NOTE Some people mistakenly believe that Java object variables behave like C++ references. But in C++ there are no null references and references cannot be assigned. You should think of Java object variables as analogous to object pointers in C++. Date rightNow; // Java is really the same as Date* rightNow; // C++ Of course, a Date* pointer isn't initialized until you initialize it with a call to new . The syntax is almost the same in C++ and Java. Date* rightNow = new Date(); // C++ If you copy one variable to another, then both variables refer to the same date-- they are pointers to the same object. The equivalent of the Java null reference is the C++ NULL pointer. All Java objects live on the heap . When an object contains another object variable, it contains just a pointer to yet another heap object. 2.2.2. The Date and LocalDate Class of the Java Library An instance of the Date class has a state-- namely, a particular point in time. The standard Java library contains two separate classes: the Date class, which represents a point in time, and the LocalDate class, which expresses days in the familiar calendar notation. LocalDate.now(); LocalDate.of(1999, 12, 31); LocalDate newYearsEve = LocalDate.of(1999, 12, 31); int year = newYearsEve.getYear(); int month = newYearsEve. getMonthValue(); int day = newYearsEve.getDayOfMonth(); LocalDate aThousandDaysLater = newYearsEve.plusDays(1000); Modifier and Type Method Description static LocalDate now() Constructs an object that represents the current date. static LocalDate of(int year, int month, int day) Constructs an object that represents the given date. int getYear() int getMonthValue() int getDayOfMonth() Gets the year, month, and day of this date. DayOfWeek getDayOfWeek() Gets the weekday of this date as an instance of the DayOfWeek class. Call getValue() on the DayOfWeek instance to get a weekday between 1 (Monday) and 7 (Sunday). LocalDate plusDays(int n) LocalDate minusDays(int n) Yields the date that is n days after or before this date. 2.3. Defining Your Own Classes C++ NOTE Constructors work the same way in Java as they do in C++. Keep in mind, however, that all Java objects are constructed on the heap and that a constructor must be combined with new. It is a common error of C++ programmers to forget the new operator: Employee number007(\"James Bond\", 100000, 1950, 1, 1); // C++, not Java! That works in C++ but not in Java. 2.3.1. Declaring Local Variables with var As of Java 10, you can declare local variables with the var keyword instead of specifying their type, provided their type can be inferred from the initial value. For example, instead of declaring Employee harry = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1); you simply write var harry = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1); This is nice since it avoids the repetition of the type name Employee. Note that the var keyword can only be used with local variables inside methods . You must always declare the types of parameters and fields. 2.3.2. Working with null References The Objects class has a convenience method for this purpose: public Employee(String n, double s, int year, int month, int day){ name = Objects.requireNonNullElse(n, \"unknown\"); . . . } The \u201ctough love\u201d approach is to reject a null argument: public Employee(String n, double s, int year, int month, int day){ name = Objects.requireNonNull(n, \"The name cannot be null\"); . . . } 2.3.3. Implicit and Explicit Parameters Any class method has two kinds of parameters. The first type of parameter, called the implicit parameter , is the callee object itself that appears before the method name. The second kind of parameter, inside the parentheses after the method name, is an explicit parameter . (Some people call the implicit parameter the target or receiver of the method call.) The implicit parameter does not appear in the method declaration. In every method, the keyword this refers to the implicit parameter . Some programmers prefer that style because it clearly distinguishes between instance fields and local variables. C++ NOTE: In C++, you generally define methods outside the class: void Employee::raiseSalary(double byPercent) // C++, not Java { . . . } If you define a method inside a class, then it is, automatically, an inline method. class Employee{ . . . int getName() { return name; } // inline in C++ } In Java, all methods are defined inside the class itself. This does not make them inline. Finding opportunities for inline replacement is the job of the Java virtual machine. The just-in-time compiler watches for calls to methods that are short, commonly called, and not overridden, and optimizes them away. 2.3.4. Benefits of Encapsulation Two kinds of class methods: - Accessor methods - Mutator methods CAUTION: Be careful not to write accessor methods that return references to mutable objects. In a previous edition of this book, I violated that rule in the Employee class in which the getHireDay method returned an object of class Date: class Employee{ private Date hireDay; . . . public Date getHireDay(){ return hireDay; // BAD } . . . } class Employee{ private Date hireDay; . . . public Date getHireDay(){ return (Date) hireDay.clone(); // OK } . . . } As a rule of thumb, always use clone whenever you need to return a copy of a mutable field. 2.3.5. Final Instance Fields You can define an instance field as final . Such a field must be initialized when the object is constructed. That is, you must guarantee that the field value has been set after the end of every constructor. Afterwards, the field may not be modified again. The final modifier is particularly useful for fields whose type is primitive or an immutable class. A class is immutable if none of its methods ever mutate its objects . For example, the String class is immutable. For mutable classes, the final modifier can be confusing. For example, consider a field: private final StringBuilder evaluations; that is initialized in the Employee constructor as evaluations = new StringBuilder(); The final keyword merely means that the object reference stored in the evaluations variable will never again refer to a different StringBuilder object . But the object can be mutated: public void giveGoldStar(){ evaluations.append(LocalDate.now() + \": Gold star!\\n\"); } 2.4. Static Fields and Methods 2.4.1. Static Fields If you define a field as static, then the field is not present in the objects of the class. There is only a single copy of each static field. You can think of static fields as belonging to the class, not to the individual objects. NOTE: In some object-oriented programming languages, static fields are called class fields. The term \u201cstatic\u201d is a meaningless holdover from C++. 2.4.2. Static Constants Static variables are quite rare. However, static constants are more common. public class Math { public static final double PI = 3.14159265358979323846; } You can access this constant in your programs as Math.PI. If the keyword static had been omitted, then PI would have been an instance field of the Math class. That is, you would need an object of this class to access PI, and every Math object would have its own copy of PI. Another static constant that you have used many times is System.out . It is declared in the System class as follows: public class System { public static final PrintStream out = . . .; } As mentioned several times, it is never a good idea to have public fields, because everyone can modify them. However, public constants (that is, final fields) are fine. Since out has been declared as final, you cannot reassign another print stream to it: System.out = new PrintStream(. . .); // ERROR--out is final 2.4.3. Static Methods Static methods are methods that do not operate on objects. You can think of static methods as methods that don\u2019t have a this parameter. (In a nonstatic method, the this parameter refers to the implicit parameter of the method.) A static method of the Employee class cannot access the id instance field because it does not operate on an object. However, a static method can access a static field. Use static methods in two situations: - When a method doesn\u2019t need to access the object state because all needed parameters are supplied as explicit parameters (example: Math.pow). - When a method only needs to access static fields of the class (example: Employee.advanceId). C++ NOTE Static fields and methods have the same functionality in Java and C++. However, the syntax is slightly different. In C++, you use the :: operator to access a static field or method outside its scope, such as Math::PI. 2.4.4. Factory Methods Here is another common use for static methods . Classes such as LocalDate and NumberFormat use static factory methods that construct objects . You have already seen the factory methods LocalDate.now and LocalDate.of . Why doesn\u2019t the NumberFormat class use a constructor instead? There are two reasons: - You can\u2019t give names to constructors. The constructor name is always the same as the class name. But we want two different names to get the currency instance and the percent instance. - When you use a constructor, you can\u2019t vary the type of the constructed object. But the factory methods actually return objects of the class DecimalFormat, a subclass that inherits from NumberFormat. 2.4.5. The main Method Every class can have a main method. That is a handy trick for adding demonstration code to a class. To see a demo of the Employee class, simply execute java Employee If the Employee class is a part of a larger application, you start the application with java Application and the main method of the Employee class is never executed. Modifier and Type Method Description static <T> void requireNonNull(T obj) static <T> void requireNonNull(T obj, String message) static <T> void requireNonNull(T obj, Supplier<String> messageSupplier) If obj is null , these methods throw a NullPointerException with no message or the given message. static <T> T requireNonNullElse(T obj, T defaultObj) static <T> T requireNonNullElseGet(T obj, Supplier<T> defaultSupplier) Returns obj if it is not null , or the default object if obj is null . 2.5. Method Parameters Let us review the computer science terms that describe how parameters can be passed to a method (or a function) in a programming language. The term call by value means that the method gets just the value that the caller provides. In contrast, call by reference means that the method gets the location of the variable that the caller provides. Thus, a method can modify the value stored in a variable passed by reference but not in one passed by value. These \u201ccall by . . .\u201d terms are standard computer science terminology describing the behavior of method parameters in various programming languages, not just Java. (There is also a call by name that is mainly of historical interest, being employed in the Algol programming language, one of the oldest high-level languages.) The Java programming language always uses call by value . That means that the method gets a copy of all parameter values . In particular, the method cannot modify the contents of any parameter variables passed to it. There are, however, two kinds of method parameters: - Primitive types (numbers, boolean values) - Object references You have seen that it is impossible for a method to change the value of a primitive type parameter. The situation is different for object parameters. As you have seen, it is easily possible\u2014and in fact very common\u2014to implement methods that change the state of an object parameter. The reason is simple. The method gets a copy of the object reference, and both the original and the copy refer to the same object. Many programming languages (in particular, C++ and Pascal) have two mechanisms for parameter passing: call by value and call by reference . Some programmers (and unfortunately even some book authors) claim that Java uses call by reference for objects. That is false. As this is such a common misunderstanding, it is worth examining a counterexample in detail. public static void swap(Employee x, Employee y) // doesn't work { Employee temp = x; x = y; y = temp; } If Java used call by reference for objects, this method would work: var a = new Employee(\"Alice\", . . .); var b = new Employee(\"Bob\", . . .); swap(a, b); // does a now refer to Bob, b to Alice? However, the method does not actually change the object references that are stored in the variables a and b. The x and y parameters of the swap method are initialized with copies of these references. The method then proceeds to swap these copies. public static void swap(Employee x, Employee y) // doesn't work { // x refers to Alice, y to Bob Employee temp = x; x = y; y = temp; // now x refers to Bob, y to Alice } But ultimately, this is a wasted effort. When the method ends, the parameter variables x and y are abandoned. The original variables a and b still refer to the same objects as they did before the method call This demonstrates that the Java programming language does not use call by reference for objects. Instead, object references are passed by value . Here is a summary of what you can and cannot do with method parameters in Java: - A method cannot modify a parameter of a primitive type (that is, numbers or boolean values). - A method can change the state of an object parameter. - A method cannot make an object parameter refer to a new object. C++ has both call by value and call by reference . You tag reference parameters with & . For example, you can easily implement methods void tripleValue(double& x) or void swap(Employee& x, Employee& y) that modify their reference parameters. 2.6. Object Construction Since object construction is so important, Java offers quite a variety of mechanisms for writing constructors. 2.6.1. Overloading Overloading occurs if several methods have the same name (in this case, the StringBuilder constructor method) but different parameters . The compiler must sort out which method to call. It picks the correct method by matching the parameter types in the headers of the various methods with the types of the values used in the specific method call. A compile-time error occurs if the compiler cannot match the parameters, either because there is no match at all or because there is not one that is better than all others. (The process of finding a match is called overloading resolution .) Classes can have more than one constructor. For example, you can construct an empty StringBuilder object as var messages = new StringBuilder(); Alternatively, you can specify an initial string: var todoList = new StringBuilder(\"To do:\\n\"); 2.6.2. Default Field Initialization If you don\u2019t set a field explicitly in a constructor, it is automatically set to a default value : numbers to 0 , boolean values to false , and object references to null . This is an important difference between fields and local variables . You must always explicitly initialize local variables in a method. But in a class, if you don\u2019t initialize a field, it is automatically initialized to a default (0, false, or null) . 2.6.3. The Constructor with No Arguments If you write a class with no constructors whatsoever, then a no-argument constructor is provided for you. This constructor sets all the instance fields to their default values. So, all numeric data contained in the instance fields would be 0, all boolean values would be false, and all object variables would be null. If a class supplies at least one constructor but does not supply a no-argument constructor, it is illegal to construct objects without supplying arguments. For example, our original Employee class in Listing 4.2 provided a single constructor: public Employee(String n, double s, int year, int month, int day) With that class, it was not legal to construct default employees. That is, the call e = new Employee(); would have been an error. CAUTION: Please keep in mind that you get a free no-argument constructor only when your class has no other constructors. If you write your class with even a single constructor of your own and you want the users of your class to have the ability to create an instance by a call to new ClassName(); then you must provide a no-argument constructor. Of course, if you are happy with the default values for all fields, you can simply supply public ClassName(){} // without any initializations 2.6.4. Explicit Field Initialization This assignment is carried out before the constructor executes. This syntax is particularly useful if all constructors of a class need to set a particular instance field to the same value. The initialization value doesn\u2019t have to be a constant value. It can also be done by a method call. 2.6.5. Shadowing Constructor Parameters A commonly used trick relies on the fact that parameter variables shadow instance fields with the same name. For example, if you call a parameter salary, then salary refers to the parameter, not the instance field. But you can still access the instance field as this.salary. Recall that this denotes the implicit parameter\u2014that is, the object being constructed. Here is an example: public Employee(String name, double salary){ this.name = name; this.salary = salary; } 2.6.6. Calling Another Constructor The keyword this refers to the current instance of the class. If the first statement of a constructor has the form this(. . .) , then the constructor calls another constructor of the same class. 2.6.7. Initialization Blocks You have already seen two ways to initialize a instance field: - By setting a value in a constructor - By assigning a value in the declaration There is a third mechanism in Java, called an initialization block . Class declarations can contain arbitrary blocks of code. These blocks are executed whenever an object of that class is constructed. class Employee{ private static int nextId; private int id; private String name; private double salary; // object initialization block { id = nextId; nextId++; } public Employee(String n, double s){ name = n; salary = s; } public Employee(){ name = \"\"; salary = 0; } . . . } In this example, the id field is initialized in the object initialization block, no matter which constructor is used to construct an object. The initialization block runs first, and then the body of the constructor is executed. This mechanism is never necessary and is not common . It is usually more straightforward to place the initialization code inside a constructor. Here is what happens in detail when a constructor is called: 1. If the first line of the constructor calls a second constructor, then the second constructor executes with the provided arguments. 2. Otherwise: - All instance fields are initialized to their default values (0, false, or null). - All field initializers and initialization blocks are executed, in the order in which they occur in the class declaration. 3. The body of the constructor is executed. If the static fields of your class require complex initialization code, use a static initialization block . Place the code inside a block and tag it with the keyword static . private static int nextId = 1; private static Random generator = new Random(); // static initialization block static { nextId = generator.nextInt(10000); } NOTE: Like field variables , static varibles are also initialized by default variables if they are not explicitly initialized. Static initialization occurs when the class is first loaded . Like instance fields, static fields are 0 , false , or null unless you explicitly set them to another value. All static field initializers and static initialization blocks are executed in the order in which they occur in the class declaration. 2.7. Records A record is a special form of a class whose state is immutable and readable by the public . Here is how you define Point as a record: record Point(double x, double y) { } The result is a class with instance fields: private final double x; private final double y; In the Java language specification, the instance fields of a record are called its components . The class has a constructor: Point(double x, double y) and accessor methods public double x() public double y() by default. Note that the accessors are called x and y, not getX and getY. (It is legal in Java to have an instance field and a method with the same name.) In addition to the field accessor methods, every record has three methods defined automatically: toString , equals , and hashCode . - A record is also an object , thus it also extends Object class. CAUTION: You can define your own versions of the automatically provided methods, as long as they have the same parameter and return types. For example, this definition is legal : record Point(double x, double y) { public double x() { return y; } // BAD } But it is surely not a good idea. You can add your own methods to a record: record Point(double x, double y) { public double distanceFromOrigin() { return Math.hypot(x, y); } } A record, like any class, can have static fields and methods : record Point(double x, double y) { public static Point ORIGIN = new Point(0, 0); public static double distance(Point p, Point q) { return Math.hypot(p.x - q.x, p.y - q.y); } ... } However, you cannot add instance fields to a record. (Because you declare class fields by constructor , and a record doesn't have a constructor in the same way as objects.) record Point(double x, double y) { private double r; // ERROR } Instance fields of a record are automatically final . However, they may be references to mutable objects. - As always, having an object defined as final means that the reference of the object cannot be changed once initialized. TIP: Use a record instead of a class for immutable data that is completely represented by a set of variables. Use a class if the data is mutable, or if the representation may evolve over time. Records are easier to read, more efficient, and safer in concurrent programs. 2.7.1. Constructors: Canonical, Custom, and Compact The automatically defined constructor that sets all instance fields is called the canonical constructor . You can define additional custom constructors . The first statement of such a constructor must call another constructor , so that ultimately the canonical constructor is invoked . record Point(double x, double y) { public Point() { this(0, 0); } } This record has two constructors: the canonical constructor and a no-argument custom constructor yielding the origin. If the canonical constructor needs to do additional work, you can provide your own implementation: record Range(int from, int to) { public Range(int from, int to) { if (from <= to){ this.from = from; this.to = to; } else{ this.from = to; this.to = from; } } } However, you are encouraged to use a compact form when implementing the canonical constructor. You don\u2019t specify the parameter list : record Range(int from, int to) { public Range{ // Compact form if (from > to){ // Swap the bounds int temp = from; from = to; to = temp; } } } The body of the compact form is the \u201cprelude\u201d to the canonical constructor. It merely modifies the parameter variables from and to before they are assigned to the instance fields this.from and this.to . You cannot read or modify the instance fields in the body of the compact constructor.","title":"Chapter 2: Objects and Classes"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#chapter-2-objects-and-classes","text":"","title":"Chapter 2: Objects and Classes"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#21-introduction-to-object-oriented-programming","text":"4 Pillars of OOP: 1. Abstraction: The process of hiding implementation details and exposing only the functionality to the user. In abstraction, we deal with ideas and not events. This means the user will only know \u201cwhat it does\u201d rather than \u201chow it does\u201d. 2. Encapsulation: In software systems, encapsulation refers to the bundling of data with the mechanisms or methods that operate on the data. It may also refer to the limiting of direct access to some of that data, such as an object's components. Essentially, encapsulation prevents external code from being concerned with the internal workings of an object. 3. Inheritance: The process of one class inheriting properties and methods from another class in Java. Inheritance is used when we have is-a relationship between objects. Inheritance in Java is implemented using extends keyword. 4. Polymorphism: Polymorphism in Java is a core concept of object-oriented programming (OOP) that allows objects to be treated as instances of their parent class . It facilitates flexibility and the ability to define methods in multiple forms. Polymorphism is primarily achieved through method overriding and method overloading. There are two types of polymorphism as listed below: Static or Compile-time Polymorphism (Overloading) Dynamic or Run-time Polymorphism (Overriding) Static or Compile-time Polymorphism occurs when the compiler is able to determine the actual function, it\u2019s called compile-time * polymorphism. Compile-time polymorphism can be achieved by method overloading in Java. When different functions in a class have the same name but different signatures, it\u2019s called method overloading . A method signature contains the name and method arguments. So, overloaded methods have different arguments. The arguments might differ in the numbers or the type of arguments. Dynamic or Run-time Polymorphism occurs when the compiler is not able to determine at compile-time which method (superclass or subclass) will be called. This decision is made at run-time. Run-time polymorphism is achieved through method overriding**, which happens when a method in a subclass has the same name, return type, and parameters as a method in its superclass. When the superclass method is overridden in the subclass, it is called method overriding.","title":"2.1. Introduction to Object-Oriented Programming"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#211-classes","text":"A class is a blueprint for objects. In Java, all classes extend the cosmic superclass called `Object.","title":"2.1.1. Classes"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#212-objects","text":"An object is an instance of the class, which has consists of a state and behavior .","title":"2.1.2. Objects"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#213-identifying-classes","text":"In a traditional procedural program, you start the process at the top, with the main function. When designing an OOP system, there is no top and newcomers to OOP often wonder where to begin. A simple rule of thumb in identifying classes is to look for nouns in the problem analysis. Methods, on the other hand, correspond to verbs .","title":"2.1.3. Identifying Classes"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#214-relationships-between-classes","text":"The most common relationships between classes are: - Dependence ( uses-a ) - Aggregation ( has-a ) - Inheritance ( is-a ) NOTE: UML notations are used for describing the relationships between classes.","title":"2.1.4. Relationships Between Classes"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#22-using-predefined-classes","text":"","title":"2.2. Using Predefined Classes"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#221-objects-and-object-variables","text":"There is an important difference between objects and object variables. Date startTime; // startTime doesn't refer to any object The statement defines an object variable, startTime , that can refer to objects of type Date . It is important to realize that the variable startTime is not an object and, in fact, does not even refer to an object yet. You cannot use any Date methods on this variable at this time. The statement s = startTime.toString(); would cause a compile-time error. You must first initialize the startTime variable. It is important to realize that an object variable doesn't actually contain an object . It only refers to an object. In Java, the value of any object variable is a reference to an object that is stored elsewhere. The return value of the new operator is also a reference . You can explicitly set an object variable to null to indicate that it currently refers to no object. C++ NOTE Some people mistakenly believe that Java object variables behave like C++ references. But in C++ there are no null references and references cannot be assigned. You should think of Java object variables as analogous to object pointers in C++. Date rightNow; // Java is really the same as Date* rightNow; // C++ Of course, a Date* pointer isn't initialized until you initialize it with a call to new . The syntax is almost the same in C++ and Java. Date* rightNow = new Date(); // C++ If you copy one variable to another, then both variables refer to the same date-- they are pointers to the same object. The equivalent of the Java null reference is the C++ NULL pointer. All Java objects live on the heap . When an object contains another object variable, it contains just a pointer to yet another heap object.","title":"2.2.1. Objects and Object Variables"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#222-the-date-and-localdate-class-of-the-java-library","text":"An instance of the Date class has a state-- namely, a particular point in time. The standard Java library contains two separate classes: the Date class, which represents a point in time, and the LocalDate class, which expresses days in the familiar calendar notation. LocalDate.now(); LocalDate.of(1999, 12, 31); LocalDate newYearsEve = LocalDate.of(1999, 12, 31); int year = newYearsEve.getYear(); int month = newYearsEve. getMonthValue(); int day = newYearsEve.getDayOfMonth(); LocalDate aThousandDaysLater = newYearsEve.plusDays(1000); Modifier and Type Method Description static LocalDate now() Constructs an object that represents the current date. static LocalDate of(int year, int month, int day) Constructs an object that represents the given date. int getYear() int getMonthValue() int getDayOfMonth() Gets the year, month, and day of this date. DayOfWeek getDayOfWeek() Gets the weekday of this date as an instance of the DayOfWeek class. Call getValue() on the DayOfWeek instance to get a weekday between 1 (Monday) and 7 (Sunday). LocalDate plusDays(int n) LocalDate minusDays(int n) Yields the date that is n days after or before this date.","title":"2.2.2. The Date and LocalDate Class of the Java Library"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#23-defining-your-own-classes","text":"C++ NOTE Constructors work the same way in Java as they do in C++. Keep in mind, however, that all Java objects are constructed on the heap and that a constructor must be combined with new. It is a common error of C++ programmers to forget the new operator: Employee number007(\"James Bond\", 100000, 1950, 1, 1); // C++, not Java! That works in C++ but not in Java.","title":"2.3. Defining Your Own Classes"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#231-declaring-local-variables-with-var","text":"As of Java 10, you can declare local variables with the var keyword instead of specifying their type, provided their type can be inferred from the initial value. For example, instead of declaring Employee harry = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1); you simply write var harry = new Employee(\"Harry Hacker\", 50000, 1989, 10, 1); This is nice since it avoids the repetition of the type name Employee. Note that the var keyword can only be used with local variables inside methods . You must always declare the types of parameters and fields.","title":"2.3.1. Declaring Local Variables with var"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#232-working-with-null-references","text":"The Objects class has a convenience method for this purpose: public Employee(String n, double s, int year, int month, int day){ name = Objects.requireNonNullElse(n, \"unknown\"); . . . } The \u201ctough love\u201d approach is to reject a null argument: public Employee(String n, double s, int year, int month, int day){ name = Objects.requireNonNull(n, \"The name cannot be null\"); . . . }","title":"2.3.2. Working with null References"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#233-implicit-and-explicit-parameters","text":"Any class method has two kinds of parameters. The first type of parameter, called the implicit parameter , is the callee object itself that appears before the method name. The second kind of parameter, inside the parentheses after the method name, is an explicit parameter . (Some people call the implicit parameter the target or receiver of the method call.) The implicit parameter does not appear in the method declaration. In every method, the keyword this refers to the implicit parameter . Some programmers prefer that style because it clearly distinguishes between instance fields and local variables. C++ NOTE: In C++, you generally define methods outside the class: void Employee::raiseSalary(double byPercent) // C++, not Java { . . . } If you define a method inside a class, then it is, automatically, an inline method. class Employee{ . . . int getName() { return name; } // inline in C++ } In Java, all methods are defined inside the class itself. This does not make them inline. Finding opportunities for inline replacement is the job of the Java virtual machine. The just-in-time compiler watches for calls to methods that are short, commonly called, and not overridden, and optimizes them away.","title":"2.3.3. Implicit and Explicit Parameters"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#234-benefits-of-encapsulation","text":"Two kinds of class methods: - Accessor methods - Mutator methods CAUTION: Be careful not to write accessor methods that return references to mutable objects. In a previous edition of this book, I violated that rule in the Employee class in which the getHireDay method returned an object of class Date: class Employee{ private Date hireDay; . . . public Date getHireDay(){ return hireDay; // BAD } . . . } class Employee{ private Date hireDay; . . . public Date getHireDay(){ return (Date) hireDay.clone(); // OK } . . . } As a rule of thumb, always use clone whenever you need to return a copy of a mutable field.","title":"2.3.4. Benefits of Encapsulation"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#235-final-instance-fields","text":"You can define an instance field as final . Such a field must be initialized when the object is constructed. That is, you must guarantee that the field value has been set after the end of every constructor. Afterwards, the field may not be modified again. The final modifier is particularly useful for fields whose type is primitive or an immutable class. A class is immutable if none of its methods ever mutate its objects . For example, the String class is immutable. For mutable classes, the final modifier can be confusing. For example, consider a field: private final StringBuilder evaluations; that is initialized in the Employee constructor as evaluations = new StringBuilder(); The final keyword merely means that the object reference stored in the evaluations variable will never again refer to a different StringBuilder object . But the object can be mutated: public void giveGoldStar(){ evaluations.append(LocalDate.now() + \": Gold star!\\n\"); }","title":"2.3.5. Final Instance Fields"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#24-static-fields-and-methods","text":"","title":"2.4. Static Fields and Methods"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#241-static-fields","text":"If you define a field as static, then the field is not present in the objects of the class. There is only a single copy of each static field. You can think of static fields as belonging to the class, not to the individual objects. NOTE: In some object-oriented programming languages, static fields are called class fields. The term \u201cstatic\u201d is a meaningless holdover from C++.","title":"2.4.1. Static Fields"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#242-static-constants","text":"Static variables are quite rare. However, static constants are more common. public class Math { public static final double PI = 3.14159265358979323846; } You can access this constant in your programs as Math.PI. If the keyword static had been omitted, then PI would have been an instance field of the Math class. That is, you would need an object of this class to access PI, and every Math object would have its own copy of PI. Another static constant that you have used many times is System.out . It is declared in the System class as follows: public class System { public static final PrintStream out = . . .; } As mentioned several times, it is never a good idea to have public fields, because everyone can modify them. However, public constants (that is, final fields) are fine. Since out has been declared as final, you cannot reassign another print stream to it: System.out = new PrintStream(. . .); // ERROR--out is final","title":"2.4.2. Static Constants"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#243-static-methods","text":"Static methods are methods that do not operate on objects. You can think of static methods as methods that don\u2019t have a this parameter. (In a nonstatic method, the this parameter refers to the implicit parameter of the method.) A static method of the Employee class cannot access the id instance field because it does not operate on an object. However, a static method can access a static field. Use static methods in two situations: - When a method doesn\u2019t need to access the object state because all needed parameters are supplied as explicit parameters (example: Math.pow). - When a method only needs to access static fields of the class (example: Employee.advanceId). C++ NOTE Static fields and methods have the same functionality in Java and C++. However, the syntax is slightly different. In C++, you use the :: operator to access a static field or method outside its scope, such as Math::PI.","title":"2.4.3. Static Methods"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#244-factory-methods","text":"Here is another common use for static methods . Classes such as LocalDate and NumberFormat use static factory methods that construct objects . You have already seen the factory methods LocalDate.now and LocalDate.of . Why doesn\u2019t the NumberFormat class use a constructor instead? There are two reasons: - You can\u2019t give names to constructors. The constructor name is always the same as the class name. But we want two different names to get the currency instance and the percent instance. - When you use a constructor, you can\u2019t vary the type of the constructed object. But the factory methods actually return objects of the class DecimalFormat, a subclass that inherits from NumberFormat.","title":"2.4.4. Factory Methods"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#245-the-main-method","text":"Every class can have a main method. That is a handy trick for adding demonstration code to a class. To see a demo of the Employee class, simply execute java Employee If the Employee class is a part of a larger application, you start the application with java Application and the main method of the Employee class is never executed. Modifier and Type Method Description static <T> void requireNonNull(T obj) static <T> void requireNonNull(T obj, String message) static <T> void requireNonNull(T obj, Supplier<String> messageSupplier) If obj is null , these methods throw a NullPointerException with no message or the given message. static <T> T requireNonNullElse(T obj, T defaultObj) static <T> T requireNonNullElseGet(T obj, Supplier<T> defaultSupplier) Returns obj if it is not null , or the default object if obj is null .","title":"2.4.5. The main Method"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#25-method-parameters","text":"Let us review the computer science terms that describe how parameters can be passed to a method (or a function) in a programming language. The term call by value means that the method gets just the value that the caller provides. In contrast, call by reference means that the method gets the location of the variable that the caller provides. Thus, a method can modify the value stored in a variable passed by reference but not in one passed by value. These \u201ccall by . . .\u201d terms are standard computer science terminology describing the behavior of method parameters in various programming languages, not just Java. (There is also a call by name that is mainly of historical interest, being employed in the Algol programming language, one of the oldest high-level languages.) The Java programming language always uses call by value . That means that the method gets a copy of all parameter values . In particular, the method cannot modify the contents of any parameter variables passed to it. There are, however, two kinds of method parameters: - Primitive types (numbers, boolean values) - Object references You have seen that it is impossible for a method to change the value of a primitive type parameter. The situation is different for object parameters. As you have seen, it is easily possible\u2014and in fact very common\u2014to implement methods that change the state of an object parameter. The reason is simple. The method gets a copy of the object reference, and both the original and the copy refer to the same object. Many programming languages (in particular, C++ and Pascal) have two mechanisms for parameter passing: call by value and call by reference . Some programmers (and unfortunately even some book authors) claim that Java uses call by reference for objects. That is false. As this is such a common misunderstanding, it is worth examining a counterexample in detail. public static void swap(Employee x, Employee y) // doesn't work { Employee temp = x; x = y; y = temp; } If Java used call by reference for objects, this method would work: var a = new Employee(\"Alice\", . . .); var b = new Employee(\"Bob\", . . .); swap(a, b); // does a now refer to Bob, b to Alice? However, the method does not actually change the object references that are stored in the variables a and b. The x and y parameters of the swap method are initialized with copies of these references. The method then proceeds to swap these copies. public static void swap(Employee x, Employee y) // doesn't work { // x refers to Alice, y to Bob Employee temp = x; x = y; y = temp; // now x refers to Bob, y to Alice } But ultimately, this is a wasted effort. When the method ends, the parameter variables x and y are abandoned. The original variables a and b still refer to the same objects as they did before the method call This demonstrates that the Java programming language does not use call by reference for objects. Instead, object references are passed by value . Here is a summary of what you can and cannot do with method parameters in Java: - A method cannot modify a parameter of a primitive type (that is, numbers or boolean values). - A method can change the state of an object parameter. - A method cannot make an object parameter refer to a new object. C++ has both call by value and call by reference . You tag reference parameters with & . For example, you can easily implement methods void tripleValue(double& x) or void swap(Employee& x, Employee& y) that modify their reference parameters.","title":"2.5. Method Parameters"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#26-object-construction","text":"Since object construction is so important, Java offers quite a variety of mechanisms for writing constructors.","title":"2.6. Object Construction"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#261-overloading","text":"Overloading occurs if several methods have the same name (in this case, the StringBuilder constructor method) but different parameters . The compiler must sort out which method to call. It picks the correct method by matching the parameter types in the headers of the various methods with the types of the values used in the specific method call. A compile-time error occurs if the compiler cannot match the parameters, either because there is no match at all or because there is not one that is better than all others. (The process of finding a match is called overloading resolution .) Classes can have more than one constructor. For example, you can construct an empty StringBuilder object as var messages = new StringBuilder(); Alternatively, you can specify an initial string: var todoList = new StringBuilder(\"To do:\\n\");","title":"2.6.1. Overloading"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#262-default-field-initialization","text":"If you don\u2019t set a field explicitly in a constructor, it is automatically set to a default value : numbers to 0 , boolean values to false , and object references to null . This is an important difference between fields and local variables . You must always explicitly initialize local variables in a method. But in a class, if you don\u2019t initialize a field, it is automatically initialized to a default (0, false, or null) .","title":"2.6.2. Default Field Initialization"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#263-the-constructor-with-no-arguments","text":"If you write a class with no constructors whatsoever, then a no-argument constructor is provided for you. This constructor sets all the instance fields to their default values. So, all numeric data contained in the instance fields would be 0, all boolean values would be false, and all object variables would be null. If a class supplies at least one constructor but does not supply a no-argument constructor, it is illegal to construct objects without supplying arguments. For example, our original Employee class in Listing 4.2 provided a single constructor: public Employee(String n, double s, int year, int month, int day) With that class, it was not legal to construct default employees. That is, the call e = new Employee(); would have been an error. CAUTION: Please keep in mind that you get a free no-argument constructor only when your class has no other constructors. If you write your class with even a single constructor of your own and you want the users of your class to have the ability to create an instance by a call to new ClassName(); then you must provide a no-argument constructor. Of course, if you are happy with the default values for all fields, you can simply supply public ClassName(){} // without any initializations","title":"2.6.3. The Constructor with No Arguments"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#264-explicit-field-initialization","text":"This assignment is carried out before the constructor executes. This syntax is particularly useful if all constructors of a class need to set a particular instance field to the same value. The initialization value doesn\u2019t have to be a constant value. It can also be done by a method call.","title":"2.6.4. Explicit Field Initialization"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#265-shadowing-constructor-parameters","text":"A commonly used trick relies on the fact that parameter variables shadow instance fields with the same name. For example, if you call a parameter salary, then salary refers to the parameter, not the instance field. But you can still access the instance field as this.salary. Recall that this denotes the implicit parameter\u2014that is, the object being constructed. Here is an example: public Employee(String name, double salary){ this.name = name; this.salary = salary; }","title":"2.6.5. Shadowing Constructor Parameters"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#266-calling-another-constructor","text":"The keyword this refers to the current instance of the class. If the first statement of a constructor has the form this(. . .) , then the constructor calls another constructor of the same class.","title":"2.6.6. Calling Another Constructor"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#267-initialization-blocks","text":"You have already seen two ways to initialize a instance field: - By setting a value in a constructor - By assigning a value in the declaration There is a third mechanism in Java, called an initialization block . Class declarations can contain arbitrary blocks of code. These blocks are executed whenever an object of that class is constructed. class Employee{ private static int nextId; private int id; private String name; private double salary; // object initialization block { id = nextId; nextId++; } public Employee(String n, double s){ name = n; salary = s; } public Employee(){ name = \"\"; salary = 0; } . . . } In this example, the id field is initialized in the object initialization block, no matter which constructor is used to construct an object. The initialization block runs first, and then the body of the constructor is executed. This mechanism is never necessary and is not common . It is usually more straightforward to place the initialization code inside a constructor. Here is what happens in detail when a constructor is called: 1. If the first line of the constructor calls a second constructor, then the second constructor executes with the provided arguments. 2. Otherwise: - All instance fields are initialized to their default values (0, false, or null). - All field initializers and initialization blocks are executed, in the order in which they occur in the class declaration. 3. The body of the constructor is executed. If the static fields of your class require complex initialization code, use a static initialization block . Place the code inside a block and tag it with the keyword static . private static int nextId = 1; private static Random generator = new Random(); // static initialization block static { nextId = generator.nextInt(10000); } NOTE: Like field variables , static varibles are also initialized by default variables if they are not explicitly initialized. Static initialization occurs when the class is first loaded . Like instance fields, static fields are 0 , false , or null unless you explicitly set them to another value. All static field initializers and static initialization blocks are executed in the order in which they occur in the class declaration.","title":"2.6.7. Initialization Blocks"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#27-records","text":"A record is a special form of a class whose state is immutable and readable by the public . Here is how you define Point as a record: record Point(double x, double y) { } The result is a class with instance fields: private final double x; private final double y; In the Java language specification, the instance fields of a record are called its components . The class has a constructor: Point(double x, double y) and accessor methods public double x() public double y() by default. Note that the accessors are called x and y, not getX and getY. (It is legal in Java to have an instance field and a method with the same name.) In addition to the field accessor methods, every record has three methods defined automatically: toString , equals , and hashCode . - A record is also an object , thus it also extends Object class. CAUTION: You can define your own versions of the automatically provided methods, as long as they have the same parameter and return types. For example, this definition is legal : record Point(double x, double y) { public double x() { return y; } // BAD } But it is surely not a good idea. You can add your own methods to a record: record Point(double x, double y) { public double distanceFromOrigin() { return Math.hypot(x, y); } } A record, like any class, can have static fields and methods : record Point(double x, double y) { public static Point ORIGIN = new Point(0, 0); public static double distance(Point p, Point q) { return Math.hypot(p.x - q.x, p.y - q.y); } ... } However, you cannot add instance fields to a record. (Because you declare class fields by constructor , and a record doesn't have a constructor in the same way as objects.) record Point(double x, double y) { private double r; // ERROR } Instance fields of a record are automatically final . However, they may be references to mutable objects. - As always, having an object defined as final means that the reference of the object cannot be changed once initialized. TIP: Use a record instead of a class for immutable data that is completely represented by a set of variables. Use a class if the data is mutable, or if the representation may evolve over time. Records are easier to read, more efficient, and safer in concurrent programs.","title":"2.7. Records"},{"location":"java/chp2-objects-and-classes/chp2-objects-and-classes.html#271-constructors-canonical-custom-and-compact","text":"The automatically defined constructor that sets all instance fields is called the canonical constructor . You can define additional custom constructors . The first statement of such a constructor must call another constructor , so that ultimately the canonical constructor is invoked . record Point(double x, double y) { public Point() { this(0, 0); } } This record has two constructors: the canonical constructor and a no-argument custom constructor yielding the origin. If the canonical constructor needs to do additional work, you can provide your own implementation: record Range(int from, int to) { public Range(int from, int to) { if (from <= to){ this.from = from; this.to = to; } else{ this.from = to; this.to = from; } } } However, you are encouraged to use a compact form when implementing the canonical constructor. You don\u2019t specify the parameter list : record Range(int from, int to) { public Range{ // Compact form if (from > to){ // Swap the bounds int temp = from; from = to; to = temp; } } } The body of the compact form is the \u201cprelude\u201d to the canonical constructor. It merely modifies the parameter variables from and to before they are assigned to the instance fields this.from and this.to . You cannot read or modify the instance fields in the body of the compact constructor.","title":"2.7.1. Constructors: Canonical, Custom, and Compact"},{"location":"java/chp3-inheritance/chp3-inheritance.html","text":"Chapter 3: Inheritance 3.1. Classes, Superclasses, and Subclasses Is-a relationship is the hallmark of inheritance. The existing class is called the superclass, base class, or parent class. The new class is called the subclass, derived class, or child class. Subclasses have more functionality than their superclasses. NOTE : Java Language Specification The Java language specification states: \u201cMembers of a class that are declared private are not inherited by subclasses of that class.\u201d This has confused the readers over the years. The specification uses the word \u201cinherits\u201d narrowly. It considers the private fields non-inherited because the Manager class cannot access them directly. Thus, every Manager object has three fields from the superclass, but the Manager class does not \u201cinherit\u201d them. You cannot extend a record, and a record cannot extend another class. If subclass methods want to access those private fields, they have to do what every other method does\u2014use the public interface. Use the special keyword super for this purpose. super is a special keyword that directs the compiler to invoke the superclass method. Some people think of super as being analogous to the this reference. However, that analogy is not quite accurate: super is not a reference to an object. A subclass can add fields, and it can add methods or override the methods of the superclass. However, inheritance can never take away any fields or methods. Since a subclass constructor cannot access the private fields of the parent class, it must initialize them through a constructor . The constructor is invoked with the special super syntax. The call using super must be the first statement in the constructor for the subclass. When a subclass object is constructed without explicit invocation of a super-class constructor, the superclass must have a no-argument constructor.That constructor is invoked prior to the subclass construction. The constructor calls can only occur as the first statement in another constructor. The constructor parameters are either passed to another constructor of the same class ( this ) or a constructor of the superclass ( super ). When e refers to an Employee object, the call e.getSalary() calls the getSalary method of the Employee class. However, when e refers to a Manager object, then the getSalary method of the Manager class is called instead. The virtual machine knows about the actual type of the object to which e refers, and therefore can invoke the correct method. The fact that an object variable (such as the variable e) can refer to multiple actual types is called polymorphism . Automatically selecting the appropriate method at runtime is called dynamic binding . In C++, you need to declare a member function as virtual if you want dynamic binding. In Java, dynamic binding is the default behavior ; if you do not want a method to be virtual, you tag it as final . Inheritance need not stop at deriving one layer of classes. The collection of all classes extending a common superclass is called an inheritance hierarchy . In C++, a class can have multiple superclasses. Java does not support multiple inheritance. A simple rule can help you decide whether or not inheritance is the right design for your data. The is\u2013a rule states that every object of the subclass is an object of the superclass. For example, every manager is an employee. Naturally, the opposite is not true\u2014not every employee is a manager. Another way of formulating the \u201cis\u2013a\u201d rule is the substitution principle. That principle states that you can use a subclass object whenever the program expects a superclass object. In the Java programming language, object variables are polymorphic : A variable of type Employee can refer to an object of type Employee or to an object of any subclass of the Employee class (such as Manager, Executive, Secretary, and so on). However, you cannot assign a superclass reference to a subclass variable. The reason is clear: Not all employees are managers. Understanding Method Calls It is important to understand exactly how a method call is applied to an object. Let\u2019s say we call x.f(args), and the implicit parameter x is declared to be an object of class C. Here is what happens: 1. The compiler looks at the declared type of the object and the method name. Note that there may be multiple methods, all with the same name, f, but with different parameter types. For example, there may be a method f(int) and a method f(String). The compiler enumerates all methods called f in the class C and all accessible methods called f in the superclasses of C. (Private methods of the superclass are not accessible.) Now the compiler knows all possible candidates for the method to be called. 2. Next, the compiler determines the types of the arguments supplied in the method call. If among all the methods called f there is a unique method whose parameter types are a best match for the supplied arguments, that method is chosen to be called. This process is called overloading resolution . For example, in a call x.f(\"Hello\"), the compiler picks f(String) and not f(int). The situation can get complex because of type conversions (int to double, Manager to Employee, and so on). If the compiler cannot find any method with matching parameter types or if multiple methods all match after applying conversions, the compiler reports an error. Now the compiler knows the name and parameter types of the method that needs to be called. 3. If the method is private , static , final , or a constructor , then the compiler knows exactly which method to call. This is called static binding . Otherwise, the method to be called depends on the actual type of the implicit parameter , and dynamic binding must be used at runtime. In our example, the compiler would generate an instruction to call f(String) with dynamic binding. - Subclasses do not have access to private methods, thus cannot be overridden . - Recall: The Java language specification states: \u201cMembers of a class that are declared private are not inherited by subclasses of that class.\u201d 4. When the program runs and uses dynamic binding to call a method, the virtual machine must call the version of the method that is appropriate for the actual type of the object to which x refers. Let\u2019s say the actual type is D, a subclass of C. If the class D defines a method f(String), that method is called. If not, D\u2019s superclass is searched for a method f(String), and so on. When you override a method, the subclass method must be at least as visible as the superclass method. In particular, if the superclass method is public, the subclass method must also be declared public. The final Keyword Classes that cannot be extended are called final classes. - You can also make a specific method in a class final. If you do this, then no subclass can override that method. - All methods in a final class are automatically final. - Fields can also be declared as final . A final field cannot be changed after the object has been constructed. However, if a class is declared final, only the methods, not the fields, are automatically final. - Enumerations and records are always final \u2014you cannot extend them. Casting The process of forcing a conversion from one type to another is called casting . - There is only one reason why you would want to make a cast\u2014to use an object in its full capacity after its actual type has been temporarily forgotten. - You can cast only within an inheritance hierarchy. - Use instanceof to check before casting from a superclass to a subclass. - This check returns a boolean value. - The getSalary method will work correctly on both objects of both classes. The dynamic binding that makes polymorphism work locates the correct method automatically. - The only reason to make the cast is to use a method that is unique to a subclass, therefore the compiler can know about the method definitions. - Pattern Matching for instanceof if (staff[i] instanceof Manager boss){ boss.setBonus(5000); } The variable-declaring instanceof form is called pattern-matching . It is similar to type patterns in switch . String description = switch (e){ case Executive exec -> \"An executive with a fancy title of \" + exec.getTitle(); case Manager m -> \"A manager with a bonus of \" + m.getBonus(); default -> \"A lowly employee with a salary of \" + e.getSalary(); } Protected Access - A subclass cannot access the private fields of its superclass. - A protected field is accessible by any class in the same package. - Now consider an Administrator subclass in a different package. The methods of the Administrator class can peek inside the hireDay field of Administrator objects only, not of other Employee objects. This restriction is made so that you can\u2019t abuse the protected mechanism by forming subclasses just to gain access to the protected fields. Here is a summary of the four access control modifiers in Java: private : Accessible in the class only. public : Accessible by the world. protected : Accessible in the package and all subclasses. default : Accessible in the package\u2014the (unfortunate) default. No modifiers are needed. 3.2. Object : The Cosmic Superclass The ultimate superclass Object is taken for granted if no superclass is explicitly mentioned. You can use a variable of type Object to refer to objects of any type: Object obj = new Employee(\"Harry\", 35000); A variable of type Object is only useful as a generic holder for arbitrary values. To do anything specific with the value, you need to have some knowledge about the original type and apply a cast: Employee e = (Employee) obj; The equals Method The equals method in the Object class tests whether one object is considered equal to another. When you define the equals method for a subclass, first call equals on the super-class . If that test doesn\u2019t pass, then the objects can\u2019t be equal. If the superclass fields are equal, you are ready to compare the instance fields of the subclass. Here is a recipe for writing the perfect equals method: 1. Name the explicit parameter otherObject \u2014later, you will need to cast it to another variable that you should call other. 2. Test whether this happens to be identical to otherObject (same address location): if (this == otherObject) return true; Test whether otherObject is null and return false if it is. This test is required. if (otherObject == null) return false; Compare the classes of this and otherObject . If the semantics of equals can change in subclasses, use the getClass test. if (getClass() != otherObject.getClass()) return false; ClassName other = (ClassName) otherObject; If the same semantics holds for all subclasses, you can use an instanceof test: if (!(otherObject instanceof ClassName other)) return false; Now compare the fields, as required by your notion of equality. Use == for primitive type fields, Objects.equals for object fields. Return true if all fields match, false otherwise. If you redefine equals in a subclass , include a call to super.equals(other) . return field1 == other.field1 && Objects.equals(field2, other.field2) && . . .; TIP : If you have fields of array type, you can use the static Arrays.equals method to check that the corresponding array elements are equal. Use the Arrays.deepEquals method for multidimensional arrays. TIP : @Override public class Employee { public boolean equals(Employee other) { return other != null && getClass() == other.getClass() && Objects.equals(name, other.name) && salary == other.salary && Objects.equals(hireDay, other.hireDay); } . . . } This method declares the explicit parameter type as Employee . As a result, it does not override the equals method of the Object class but defines a completely unrelated method. You can protect yourself against this type of error by tagging methods that are intended to override superclass methods with @Override: @Override public boolean equals(Object other) If you made a mistake and are defining a new method, the compiler reports an error. The hashCode Method A hash code is an integer that is derived from an object. Hash codes should be scrambled\u2014if x and y are two distinct objects, there should be a high probability that x.hashCode() and y.hashCode() are different. The hashCode method is defined in the Object class. Therefore, every object has a default hash code. That hash code is derived from the object\u2019s memory address. A record type automatically provides a hashCode method that derives a hash code from the hash codes of the field values. **The `toString Method Another important method in Object is the toString method that returns a string representing the value of this object. If x is any object and you call System.out.println(x); then the println method simply calls x.toString() and prints the resulting string. CAUTION Annoyingly, arrays inherit the toString method from Object, with the added twist that the array type is printed in an archaic format. For example, int[] luckyNumbers = { 2, 3, 5, 7, 11, 13 }; String s = \"\" + luckyNumbers; yields the string [I@1a46e30 . (The prefix [I denotes an array of integers.) The remedy is to call the static Arrays.toString method instead. The code String s = Arrays.toString(luckyNumbers); yields the string [2, 3, 5, 7, 11, 13] . To correctly print multidimensional arrays (that is, arrays of arrays), use Arrays.deepToString . java.lang.Object Modifier and Type Method Description Class getClass() Returns a class object that contains information about the object. Java has a runtime representation for classes that is encapsulated in the Class class. boolean equals(Object otherObject) Compares two objects for equality; returns true if the objects point to the same area of memory, and false otherwise. You should override this method in your own classes. String toString() Returns a string that represents the value of this object. You should override this method in your own classes. java.lang.Class Modifier and Type Method Description String getName() Returns the name of this class. Class getSuperclass() Returns the superclass of this class as a Class object. 3.3. Generic Array Lists ArrayList is a generic class with a type parameter. To specify the type of the element objects that the array list holds, you append a class name enclosed in angle brackets, such as ArrayList<Employee> . // ArrayList Initialization ArrayList<Employee> staff = new ArrayList<Employee>(); var staff = new ArrayList<Employee>(); ArrayList<Employee> staff = new ArrayList<>(); Before Java 5, there were no generic classes. Instead, there was a single ArrayList class, a one-size-fits-all collection holding elements of type Object. You can still use ArrayList without a <. . .> suffix. It is considered a \u201craw\u201d type, with the type parameter erased. When there were no generic classes, the get method of the raw ArrayList class had no choice but to return an Object. Consequently, callers of get had to cast the returned value to the desired type Employee e = (Employee) staff.get(i); 3.4. Object Wrappers and Autoboxing Occasionally, you need to convert a primitive type like int to an object. All primitive types have class counterparts. These kinds of classes are usually called wrappers . The wrapper classes have obvious names: Integer , Long , Float , Double , Short , Byte , Character , and Boolean . (The first six inherit from the common superclass Number .) The wrapper classes are immutable \u2014 you cannot change a wrapped value after the wrapper has been constructed. They are also final , so you cannot subclass them . Autoboxing list.add(3); is automatically translated to list.add(Integer.valueOf(3)); This conversion is called autoboxing . Conversely, when you assign an Integer object to an int value, it is automatically unboxed . That is, the compiler translates int n = list.get(i); into int n = list.get(i).intValue(); The == operator, applied to wrapper objects, only tests whether the objects have identical memory locations. The following comparison would therefore probably fail: Integer a = 1000; Integer b = 1000; if (a == b) . . . The remedy is to call the equals method when comparing wrapper objects. Don\u2019t use the wrapper class constructors. They are deprecated and scheduled for removal. For example, use Integer.valueOf(1000) , never new Integer(1000) . Or, simply rely on autoboxing : Integer a = 1000 . To convert a string to an integer, use the following statement: int x = Integer.parseInt(s); java.lang.Integer Modifier and Type Method Description int intValue() Returns the value of this Integer object as an int (overrides the intValue method in the Number class). static String toString(int i) Returns a new String object representing the number i in base 10. static String toString(int i, int radix) Returns a representation of the number i in the base specified by the radix parameter. static int parseInt(String s) static int parseInt(String s, int radix) Returns the integer whose digits are contained in the string s . The string must represent an integer in base 10 (for the first method) or in the base given by the radix parameter (for the second method). static Integer valueOf(String s) static Integer valueOf(String s, int radix) Returns a new Integer object initialized to the integer whose digits are contained in the string s . The string must represent an integer in base 10 (for the first method) or in the base given by the radix parameter (for the second method). 3.5. Methods with a Variable Number of Parameters It is possible to provide methods that can be called with a variable number of parameters. (These are sometimes called \u201cvarargs\u201d methods.) The printf method is defined like this: public class PrintStream { public PrintStream printf(String fmt, Object... args) { return format(fmt, args); } } Here, the ellipsis ... is part of the Java code. It denotes that the method can receive an arbitrary number of objects. The printf method actually receives two parameters: the format string and an Object[] array that holds all other parameters. In other words, for the implementor of printf, the Object... parameter type is exactly the same as Object[] . The compiler needs to transform each call to printf, bundling the parameters into an array and autoboxing as necessary: System.out.printf(\"%d %s\", new Object[] { Integer.valueOf(n), \"widgets\" } ); 3.6. Abstract Classes As you move up the inheritance hierarchy, classes become more general and probably more abstract. At some point, the ancestor class becomes so general that you think of it more as a basis for other classes than as a class with specific instances you want to use. If you use the abstract keyword, you do not need to implement the method at all. For added clarity, a class with one or more abstract methods must itself be declared abstract . public abstract class Person { . . . public abstract String getDescription(); } In addition to abstract methods, abstract classes can have fields and concrete methods. For example, the Person class stores the name of the person and has a concrete method that returns it. public abstract class Person { private String name; public Person(String name){ this.name = name; } public abstract String getDescription(); public String getName(){ return name; } } You should always move common fields and methods (whether abstract or not) to the superclass (whether abstract or not). Abstract methods act as placeholders for methods that are implemented in the subclasses. When you extend an abstract class, you have two choices. You can leave some or all of the abstract methods undefined ; then, you must tag the subclass as abstract as well . Or, you can define all methods, and the subclass is no longer abstract. An abstract class can extend another abstract class. A class can even be declared as abstract though it has no abstract methods. Abstract classes cannot be instantiated. Note that you can still create object variables of an abstract class, but such a variable must refer to an object of a non-abstract subclass. Same for interfaces! Person p = new Student(\"Vince Vu\", \"Economics\"); Isn\u2019t this a call to an undefined method? Keep in mind that the variable p never refers to a Person object because it is impossible to construct an object of the abstract Person class. The variable p always refers to an object of a concrete subclass such as Employee or Student. For these objects, the getDescription method is defined. var people = new Person[2]; people[0] = new Employee(. . .);people[1] = new Student(. . .); for (Person p : people) System.out.println(p.getName() + \", \" + p.getDescription()); Abstract methods are an important concept in the Java programming language. You will encounter them most commonly inside interfaces. 3.7. Enumeration Classes public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE } The type defined by this declaration is actually a class. The class has exactly four instances\u2014it is not possible to construct new objects. Therefore, you never need to use equals for values of enumerated types. Simply use == to compare them. You can, if you like, add constructors, methods, and fields to an enumerated type. The constructor of an enumeration is always private . You can omit the private modifier, as in the preceding example. It is a syntax error to declare an enum constructor as public or protected. All enumerated types are subclasses of the abstract class Enum. They inherit a number of methods from that class. The most useful one is toString , which returns the name of the enumerated constant. The converse of toString is the static valueOf method. Size s = Enum.valueOf(Size.class, \"SMALL\"); Each enumerated type has a static values method that returns an array of all values of the enumeration. Size[] values = Size.values(); The ordinal method yields the position of an enumerated constant in the enum declaration, counting from zero. For example, Size.MEDIUM.ordinal() returns 1. The Enum class has a type parameter that I have ignored for simplicity. For example, the enumerated type Size actually extends Enum<Size> . The type parameter is used in the compareTo method. java.lang.Enum< E > Modifier and Type Method Description static Enum valueOf(Class enumClass, String name) Returns the enumerated constant of the given class with the given name. String toString() Returns the name of this enumerated constant. int ordinal() Returns the zero-based position of this enumerated constant in the enum declaration. int compareTo(E other) Returns a negative integer if this enumerated constant comes before other , zero if this == other , and a positive integer otherwise. The ordering of the constants is given by the enum declaration. 3.8. Sealed Classes In Java, a sealed class controls which classes may inherit from it. Sealed classes were added as a preview feature in Java 15 and finalized in Java 17. public abstract sealed class JSONValue permits JSONArray, JSONNumber, JSONString, JSONBoolean, JSONObject, JSONNull { . . . } In this section, we learned about sealed classes. In the next chapter, we will learn about interfaces, a generalization of abstract classes. Java interfaces can also have subtypes. Sealed interfaces work exactly the same as sealed classes, controlling the direct subtypes.","title":"Chapter 3: Inheritance"},{"location":"java/chp3-inheritance/chp3-inheritance.html#chapter-3-inheritance","text":"","title":"Chapter 3: Inheritance"},{"location":"java/chp3-inheritance/chp3-inheritance.html#31-classes-superclasses-and-subclasses","text":"Is-a relationship is the hallmark of inheritance. The existing class is called the superclass, base class, or parent class. The new class is called the subclass, derived class, or child class. Subclasses have more functionality than their superclasses. NOTE : Java Language Specification The Java language specification states: \u201cMembers of a class that are declared private are not inherited by subclasses of that class.\u201d This has confused the readers over the years. The specification uses the word \u201cinherits\u201d narrowly. It considers the private fields non-inherited because the Manager class cannot access them directly. Thus, every Manager object has three fields from the superclass, but the Manager class does not \u201cinherit\u201d them. You cannot extend a record, and a record cannot extend another class. If subclass methods want to access those private fields, they have to do what every other method does\u2014use the public interface. Use the special keyword super for this purpose. super is a special keyword that directs the compiler to invoke the superclass method. Some people think of super as being analogous to the this reference. However, that analogy is not quite accurate: super is not a reference to an object. A subclass can add fields, and it can add methods or override the methods of the superclass. However, inheritance can never take away any fields or methods. Since a subclass constructor cannot access the private fields of the parent class, it must initialize them through a constructor . The constructor is invoked with the special super syntax. The call using super must be the first statement in the constructor for the subclass. When a subclass object is constructed without explicit invocation of a super-class constructor, the superclass must have a no-argument constructor.That constructor is invoked prior to the subclass construction. The constructor calls can only occur as the first statement in another constructor. The constructor parameters are either passed to another constructor of the same class ( this ) or a constructor of the superclass ( super ). When e refers to an Employee object, the call e.getSalary() calls the getSalary method of the Employee class. However, when e refers to a Manager object, then the getSalary method of the Manager class is called instead. The virtual machine knows about the actual type of the object to which e refers, and therefore can invoke the correct method. The fact that an object variable (such as the variable e) can refer to multiple actual types is called polymorphism . Automatically selecting the appropriate method at runtime is called dynamic binding . In C++, you need to declare a member function as virtual if you want dynamic binding. In Java, dynamic binding is the default behavior ; if you do not want a method to be virtual, you tag it as final . Inheritance need not stop at deriving one layer of classes. The collection of all classes extending a common superclass is called an inheritance hierarchy . In C++, a class can have multiple superclasses. Java does not support multiple inheritance. A simple rule can help you decide whether or not inheritance is the right design for your data. The is\u2013a rule states that every object of the subclass is an object of the superclass. For example, every manager is an employee. Naturally, the opposite is not true\u2014not every employee is a manager. Another way of formulating the \u201cis\u2013a\u201d rule is the substitution principle. That principle states that you can use a subclass object whenever the program expects a superclass object. In the Java programming language, object variables are polymorphic : A variable of type Employee can refer to an object of type Employee or to an object of any subclass of the Employee class (such as Manager, Executive, Secretary, and so on). However, you cannot assign a superclass reference to a subclass variable. The reason is clear: Not all employees are managers. Understanding Method Calls It is important to understand exactly how a method call is applied to an object. Let\u2019s say we call x.f(args), and the implicit parameter x is declared to be an object of class C. Here is what happens: 1. The compiler looks at the declared type of the object and the method name. Note that there may be multiple methods, all with the same name, f, but with different parameter types. For example, there may be a method f(int) and a method f(String). The compiler enumerates all methods called f in the class C and all accessible methods called f in the superclasses of C. (Private methods of the superclass are not accessible.) Now the compiler knows all possible candidates for the method to be called. 2. Next, the compiler determines the types of the arguments supplied in the method call. If among all the methods called f there is a unique method whose parameter types are a best match for the supplied arguments, that method is chosen to be called. This process is called overloading resolution . For example, in a call x.f(\"Hello\"), the compiler picks f(String) and not f(int). The situation can get complex because of type conversions (int to double, Manager to Employee, and so on). If the compiler cannot find any method with matching parameter types or if multiple methods all match after applying conversions, the compiler reports an error. Now the compiler knows the name and parameter types of the method that needs to be called. 3. If the method is private , static , final , or a constructor , then the compiler knows exactly which method to call. This is called static binding . Otherwise, the method to be called depends on the actual type of the implicit parameter , and dynamic binding must be used at runtime. In our example, the compiler would generate an instruction to call f(String) with dynamic binding. - Subclasses do not have access to private methods, thus cannot be overridden . - Recall: The Java language specification states: \u201cMembers of a class that are declared private are not inherited by subclasses of that class.\u201d 4. When the program runs and uses dynamic binding to call a method, the virtual machine must call the version of the method that is appropriate for the actual type of the object to which x refers. Let\u2019s say the actual type is D, a subclass of C. If the class D defines a method f(String), that method is called. If not, D\u2019s superclass is searched for a method f(String), and so on. When you override a method, the subclass method must be at least as visible as the superclass method. In particular, if the superclass method is public, the subclass method must also be declared public. The final Keyword Classes that cannot be extended are called final classes. - You can also make a specific method in a class final. If you do this, then no subclass can override that method. - All methods in a final class are automatically final. - Fields can also be declared as final . A final field cannot be changed after the object has been constructed. However, if a class is declared final, only the methods, not the fields, are automatically final. - Enumerations and records are always final \u2014you cannot extend them. Casting The process of forcing a conversion from one type to another is called casting . - There is only one reason why you would want to make a cast\u2014to use an object in its full capacity after its actual type has been temporarily forgotten. - You can cast only within an inheritance hierarchy. - Use instanceof to check before casting from a superclass to a subclass. - This check returns a boolean value. - The getSalary method will work correctly on both objects of both classes. The dynamic binding that makes polymorphism work locates the correct method automatically. - The only reason to make the cast is to use a method that is unique to a subclass, therefore the compiler can know about the method definitions. - Pattern Matching for instanceof if (staff[i] instanceof Manager boss){ boss.setBonus(5000); } The variable-declaring instanceof form is called pattern-matching . It is similar to type patterns in switch . String description = switch (e){ case Executive exec -> \"An executive with a fancy title of \" + exec.getTitle(); case Manager m -> \"A manager with a bonus of \" + m.getBonus(); default -> \"A lowly employee with a salary of \" + e.getSalary(); } Protected Access - A subclass cannot access the private fields of its superclass. - A protected field is accessible by any class in the same package. - Now consider an Administrator subclass in a different package. The methods of the Administrator class can peek inside the hireDay field of Administrator objects only, not of other Employee objects. This restriction is made so that you can\u2019t abuse the protected mechanism by forming subclasses just to gain access to the protected fields. Here is a summary of the four access control modifiers in Java: private : Accessible in the class only. public : Accessible by the world. protected : Accessible in the package and all subclasses. default : Accessible in the package\u2014the (unfortunate) default. No modifiers are needed.","title":"3.1. Classes, Superclasses, and Subclasses"},{"location":"java/chp3-inheritance/chp3-inheritance.html#32-object-the-cosmic-superclass","text":"The ultimate superclass Object is taken for granted if no superclass is explicitly mentioned. You can use a variable of type Object to refer to objects of any type: Object obj = new Employee(\"Harry\", 35000); A variable of type Object is only useful as a generic holder for arbitrary values. To do anything specific with the value, you need to have some knowledge about the original type and apply a cast: Employee e = (Employee) obj; The equals Method The equals method in the Object class tests whether one object is considered equal to another. When you define the equals method for a subclass, first call equals on the super-class . If that test doesn\u2019t pass, then the objects can\u2019t be equal. If the superclass fields are equal, you are ready to compare the instance fields of the subclass. Here is a recipe for writing the perfect equals method: 1. Name the explicit parameter otherObject \u2014later, you will need to cast it to another variable that you should call other. 2. Test whether this happens to be identical to otherObject (same address location): if (this == otherObject) return true; Test whether otherObject is null and return false if it is. This test is required. if (otherObject == null) return false; Compare the classes of this and otherObject . If the semantics of equals can change in subclasses, use the getClass test. if (getClass() != otherObject.getClass()) return false; ClassName other = (ClassName) otherObject; If the same semantics holds for all subclasses, you can use an instanceof test: if (!(otherObject instanceof ClassName other)) return false; Now compare the fields, as required by your notion of equality. Use == for primitive type fields, Objects.equals for object fields. Return true if all fields match, false otherwise. If you redefine equals in a subclass , include a call to super.equals(other) . return field1 == other.field1 && Objects.equals(field2, other.field2) && . . .; TIP : If you have fields of array type, you can use the static Arrays.equals method to check that the corresponding array elements are equal. Use the Arrays.deepEquals method for multidimensional arrays. TIP : @Override public class Employee { public boolean equals(Employee other) { return other != null && getClass() == other.getClass() && Objects.equals(name, other.name) && salary == other.salary && Objects.equals(hireDay, other.hireDay); } . . . } This method declares the explicit parameter type as Employee . As a result, it does not override the equals method of the Object class but defines a completely unrelated method. You can protect yourself against this type of error by tagging methods that are intended to override superclass methods with @Override: @Override public boolean equals(Object other) If you made a mistake and are defining a new method, the compiler reports an error. The hashCode Method A hash code is an integer that is derived from an object. Hash codes should be scrambled\u2014if x and y are two distinct objects, there should be a high probability that x.hashCode() and y.hashCode() are different. The hashCode method is defined in the Object class. Therefore, every object has a default hash code. That hash code is derived from the object\u2019s memory address. A record type automatically provides a hashCode method that derives a hash code from the hash codes of the field values. **The `toString Method Another important method in Object is the toString method that returns a string representing the value of this object. If x is any object and you call System.out.println(x); then the println method simply calls x.toString() and prints the resulting string. CAUTION Annoyingly, arrays inherit the toString method from Object, with the added twist that the array type is printed in an archaic format. For example, int[] luckyNumbers = { 2, 3, 5, 7, 11, 13 }; String s = \"\" + luckyNumbers; yields the string [I@1a46e30 . (The prefix [I denotes an array of integers.) The remedy is to call the static Arrays.toString method instead. The code String s = Arrays.toString(luckyNumbers); yields the string [2, 3, 5, 7, 11, 13] . To correctly print multidimensional arrays (that is, arrays of arrays), use Arrays.deepToString .","title":"3.2. Object: The Cosmic Superclass"},{"location":"java/chp3-inheritance/chp3-inheritance.html#javalangobject","text":"Modifier and Type Method Description Class getClass() Returns a class object that contains information about the object. Java has a runtime representation for classes that is encapsulated in the Class class. boolean equals(Object otherObject) Compares two objects for equality; returns true if the objects point to the same area of memory, and false otherwise. You should override this method in your own classes. String toString() Returns a string that represents the value of this object. You should override this method in your own classes.","title":"java.lang.Object"},{"location":"java/chp3-inheritance/chp3-inheritance.html#javalangclass","text":"Modifier and Type Method Description String getName() Returns the name of this class. Class getSuperclass() Returns the superclass of this class as a Class object.","title":"java.lang.Class"},{"location":"java/chp3-inheritance/chp3-inheritance.html#33-generic-array-lists","text":"ArrayList is a generic class with a type parameter. To specify the type of the element objects that the array list holds, you append a class name enclosed in angle brackets, such as ArrayList<Employee> . // ArrayList Initialization ArrayList<Employee> staff = new ArrayList<Employee>(); var staff = new ArrayList<Employee>(); ArrayList<Employee> staff = new ArrayList<>(); Before Java 5, there were no generic classes. Instead, there was a single ArrayList class, a one-size-fits-all collection holding elements of type Object. You can still use ArrayList without a <. . .> suffix. It is considered a \u201craw\u201d type, with the type parameter erased. When there were no generic classes, the get method of the raw ArrayList class had no choice but to return an Object. Consequently, callers of get had to cast the returned value to the desired type Employee e = (Employee) staff.get(i);","title":"3.3. Generic Array Lists"},{"location":"java/chp3-inheritance/chp3-inheritance.html#34-object-wrappers-and-autoboxing","text":"Occasionally, you need to convert a primitive type like int to an object. All primitive types have class counterparts. These kinds of classes are usually called wrappers . The wrapper classes have obvious names: Integer , Long , Float , Double , Short , Byte , Character , and Boolean . (The first six inherit from the common superclass Number .) The wrapper classes are immutable \u2014 you cannot change a wrapped value after the wrapper has been constructed. They are also final , so you cannot subclass them . Autoboxing list.add(3); is automatically translated to list.add(Integer.valueOf(3)); This conversion is called autoboxing . Conversely, when you assign an Integer object to an int value, it is automatically unboxed . That is, the compiler translates int n = list.get(i); into int n = list.get(i).intValue(); The == operator, applied to wrapper objects, only tests whether the objects have identical memory locations. The following comparison would therefore probably fail: Integer a = 1000; Integer b = 1000; if (a == b) . . . The remedy is to call the equals method when comparing wrapper objects. Don\u2019t use the wrapper class constructors. They are deprecated and scheduled for removal. For example, use Integer.valueOf(1000) , never new Integer(1000) . Or, simply rely on autoboxing : Integer a = 1000 . To convert a string to an integer, use the following statement: int x = Integer.parseInt(s);","title":"3.4. Object Wrappers and Autoboxing"},{"location":"java/chp3-inheritance/chp3-inheritance.html#javalanginteger","text":"Modifier and Type Method Description int intValue() Returns the value of this Integer object as an int (overrides the intValue method in the Number class). static String toString(int i) Returns a new String object representing the number i in base 10. static String toString(int i, int radix) Returns a representation of the number i in the base specified by the radix parameter. static int parseInt(String s) static int parseInt(String s, int radix) Returns the integer whose digits are contained in the string s . The string must represent an integer in base 10 (for the first method) or in the base given by the radix parameter (for the second method). static Integer valueOf(String s) static Integer valueOf(String s, int radix) Returns a new Integer object initialized to the integer whose digits are contained in the string s . The string must represent an integer in base 10 (for the first method) or in the base given by the radix parameter (for the second method).","title":"java.lang.Integer"},{"location":"java/chp3-inheritance/chp3-inheritance.html#35-methods-with-a-variable-number-of-parameters","text":"It is possible to provide methods that can be called with a variable number of parameters. (These are sometimes called \u201cvarargs\u201d methods.) The printf method is defined like this: public class PrintStream { public PrintStream printf(String fmt, Object... args) { return format(fmt, args); } } Here, the ellipsis ... is part of the Java code. It denotes that the method can receive an arbitrary number of objects. The printf method actually receives two parameters: the format string and an Object[] array that holds all other parameters. In other words, for the implementor of printf, the Object... parameter type is exactly the same as Object[] . The compiler needs to transform each call to printf, bundling the parameters into an array and autoboxing as necessary: System.out.printf(\"%d %s\", new Object[] { Integer.valueOf(n), \"widgets\" } );","title":"3.5. Methods with a Variable Number of Parameters"},{"location":"java/chp3-inheritance/chp3-inheritance.html#36-abstract-classes","text":"As you move up the inheritance hierarchy, classes become more general and probably more abstract. At some point, the ancestor class becomes so general that you think of it more as a basis for other classes than as a class with specific instances you want to use. If you use the abstract keyword, you do not need to implement the method at all. For added clarity, a class with one or more abstract methods must itself be declared abstract . public abstract class Person { . . . public abstract String getDescription(); } In addition to abstract methods, abstract classes can have fields and concrete methods. For example, the Person class stores the name of the person and has a concrete method that returns it. public abstract class Person { private String name; public Person(String name){ this.name = name; } public abstract String getDescription(); public String getName(){ return name; } } You should always move common fields and methods (whether abstract or not) to the superclass (whether abstract or not). Abstract methods act as placeholders for methods that are implemented in the subclasses. When you extend an abstract class, you have two choices. You can leave some or all of the abstract methods undefined ; then, you must tag the subclass as abstract as well . Or, you can define all methods, and the subclass is no longer abstract. An abstract class can extend another abstract class. A class can even be declared as abstract though it has no abstract methods. Abstract classes cannot be instantiated. Note that you can still create object variables of an abstract class, but such a variable must refer to an object of a non-abstract subclass. Same for interfaces! Person p = new Student(\"Vince Vu\", \"Economics\"); Isn\u2019t this a call to an undefined method? Keep in mind that the variable p never refers to a Person object because it is impossible to construct an object of the abstract Person class. The variable p always refers to an object of a concrete subclass such as Employee or Student. For these objects, the getDescription method is defined. var people = new Person[2]; people[0] = new Employee(. . .);people[1] = new Student(. . .); for (Person p : people) System.out.println(p.getName() + \", \" + p.getDescription()); Abstract methods are an important concept in the Java programming language. You will encounter them most commonly inside interfaces.","title":"3.6. Abstract Classes"},{"location":"java/chp3-inheritance/chp3-inheritance.html#37-enumeration-classes","text":"public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE } The type defined by this declaration is actually a class. The class has exactly four instances\u2014it is not possible to construct new objects. Therefore, you never need to use equals for values of enumerated types. Simply use == to compare them. You can, if you like, add constructors, methods, and fields to an enumerated type. The constructor of an enumeration is always private . You can omit the private modifier, as in the preceding example. It is a syntax error to declare an enum constructor as public or protected. All enumerated types are subclasses of the abstract class Enum. They inherit a number of methods from that class. The most useful one is toString , which returns the name of the enumerated constant. The converse of toString is the static valueOf method. Size s = Enum.valueOf(Size.class, \"SMALL\"); Each enumerated type has a static values method that returns an array of all values of the enumeration. Size[] values = Size.values(); The ordinal method yields the position of an enumerated constant in the enum declaration, counting from zero. For example, Size.MEDIUM.ordinal() returns 1. The Enum class has a type parameter that I have ignored for simplicity. For example, the enumerated type Size actually extends Enum<Size> . The type parameter is used in the compareTo method.","title":"3.7. Enumeration Classes"},{"location":"java/chp3-inheritance/chp3-inheritance.html#javalangenume","text":"Modifier and Type Method Description static Enum valueOf(Class enumClass, String name) Returns the enumerated constant of the given class with the given name. String toString() Returns the name of this enumerated constant. int ordinal() Returns the zero-based position of this enumerated constant in the enum declaration. int compareTo(E other) Returns a negative integer if this enumerated constant comes before other , zero if this == other , and a positive integer otherwise. The ordering of the constants is given by the enum declaration.","title":"java.lang.Enum&lt;E&gt;"},{"location":"java/chp3-inheritance/chp3-inheritance.html#38-sealed-classes","text":"In Java, a sealed class controls which classes may inherit from it. Sealed classes were added as a preview feature in Java 15 and finalized in Java 17. public abstract sealed class JSONValue permits JSONArray, JSONNumber, JSONString, JSONBoolean, JSONObject, JSONNull { . . . } In this section, we learned about sealed classes. In the next chapter, we will learn about interfaces, a generalization of abstract classes. Java interfaces can also have subtypes. Sealed interfaces work exactly the same as sealed classes, controlling the direct subtypes.","title":"3.8. Sealed Classes"},{"location":"java/chp4-interfaces/chp4-interfaces.html","text":"Chapter 4: Interfaces, Lambda Expressions, and Inner Classes 4.1. Interfaces An interface is not a class but a set of requirements for the classes that want to conform to the interface. All methods of an interface are automatically public . However, when implementing the interface, you must declare the method as public , as the default method definition makes it package accessible. If public keyword not provided, the compiler then complains that you're trying to supply a more restrictive access privilege. Interfaces can never have instance fields. Interfaces can define constants, e.g. static final variables. Fields that are defined in interfaces are always public static final . ```java public interface Powered extends Moveable { double milesPerGallon(); double SPEED_LIMIT = 95; } - It is possible to have `static` and `private` methods as well as `default` methods - Interfaces might be tedious when inheritance comes into play. - Since Manager extends Employee, it implements `Comparable<Employee>` and not `Comparable<Manager>`. If Manager chooses to override compareTo, it must be prepared to compare managers to employees. ```java class Manager extends Employee { public int compareTo(Employee other) { Manager otherManager = (Manager) other; // NO . . . } . . . } - This violates the `antisymmetry` rule: If x is an Employee and y is a Manager, then the call x.compareTo(y) doesn\u2019t throw an exception\u2014it simply compares x and y as employees. But the reverse, y.compareTo(x), throws a `ClassCastException`. - There are two possible remedies: - If subclasses have different notions of comparison, then you should outlaw comparison of objects that belong to different classes. ```java if (getClass() != other.getClass()) throw new ClassCastException(); - If there is a common algorithm for comparing subclass objects, simply provide a single `compareTo` method in the superclass and declare it as `final`. - Interfaces cannot be instantiated. - However, even though you can\u2019t construct interface objects, you can still declare interface variables (same as **abstract classes**). - An interface variable must refer to an object of a class that implements the interface. - Next, just as you use `instanceof` to check whether an object is of a specific class, you can use `instanceof` to check whether an object implements an interface. - Just as you can build hierarchies of classes, **you can extend interfaces.** - While each class can have **only one superclass**, classes **can implement multiple interfaces**. - **Records and enumeration classes cannot extend other classes (since they implicitly extend the Record and Enum class). However, they can implement interfaces.** - Interfaces can be `sealed`. - As with sealed classes, the direct subtypes (which can be classes or interfaces) must be declared in a permits clause or be located in the same source file. - **Interfaces vs Abstract Classes** - You may wonder why the designers of the Java programming language bothered with introducing the concept of interfaces. - There is, unfortunately, a major problem with using an abstract base class to express a generic property. A class can only extend a single class. - But each class can implement as many interfaces as it likes. - Other programming languages, in particular C++, allow a class to have more than one superclass. This feature is called **multiple inheritance**. - **Java does not support multiple inheritance.** - **Static and Private Methods** - As of Java 8, you are allowed to add static methods to interfaces. - Up to now, it has been common to place static methods in companion classes, e.g. `Paths` and `Collections` classes. However, when you implement your own interfaces, there is no longer a reason to provide a separate companion class for utility methods. - As of Java 9, methods in an interface can be `private`. A private method can be `static` or an `instance method`. **Since private methods can only be used in the methods of the interface itself, their use is limited to being helper methods for the other methods of the interface.** - **Default Methods** - You can supply a default implementation for any interface method. ```java public interface Comparable<T> { default int compareTo(T other) { return 0; } // by default, all elements are the same } - **Resolving Default Method Conflicts** - What happens if the exact same method is defined as a default method in one interface and then again as a method of a superclass or another interface? - Rules 1. Superclasses win. If a superclass provides a concrete method, default methods with the same name and parameter types are simply ignored. 2. Interfaces clash. If an interface provides a default method, and another interface contains a method with the same name and parameter types (default or not), then you must resolve the conflict by overriding that method. Interfaces and Callbacks A common pattern in programming is the callback pattern. In this pattern, you specify the action that should occur whenever a particular event happens. Interfaces allow implementing callbacks by enforcing what a class should do. In many programming languages, you supply the name of a function that the timer should call periodically. However, the classes in the Java standard library take an object- oriented approach. You pass an object of some class. The timer then calls one of the methods on that object. Passing an object is more flexible than passing a function because the object can carry additional information. Object Cloning and Cloneable Interface To understand what cloning means, recall what happens when you make a copy of a variable holding an object reference. The original and the copy are references to the same object. This means a change to either variable also affects the other. The clone method is a protected method of Object, which means that your code cannot simply call it. Only the Employee class can clone Employee objects. There is a reason for this restriction. Think about the way in which the Object class can implement clone. It knows nothing about the object at all, so it can make only a field-by-field copy. If all instance fields in the object are numbers or other basic types, copying the fields is just fine. But if the object contains references to subobjects, then copying the field gives you another reference to the same subobject, so the original and the cloned objects still share some information. As you can see, the default cloning operation is \u201cshallow\u201d\u2014it doesn\u2019t clone objects that are referenced inside other objects. Does it matter if the copy is shallow? It depends. If the subobject shared between the original and the shallow clone is immutable, then the sharing is safe. Quite frequently, however, subobjects are mutable, and you must redefine the clone method to make a deep copy that clones the subobjects as well. For every class, you need to decide whether: 1. The default clone method is good enough; 2. The default clone method can be patched up by calling clone on the mutable subobjects; or 3. clone should not be attempted. The third option is actually the default. To choose either the first or the second option, a class must 1. Implement the Cloneable interface; and 2. Redefine the clone method with the public access modifier. The clone method is declared protected in the Object class, so that your code can\u2019t simply call anObject.clone(). But aren\u2019t protected methods accessible from any subclass, and isn\u2019t every class a subclass of Object? Fortunately, the rules for protected access are more subtle. A subclass can call a protected clone method only to clone its own objects. You must redefine clone to be public to allow objects to be cloned by any method. A tagging interface has no methods; its only purpose is to allow the use of instanceof in a type inquiry. Even if the default (shallow copy) implementation of clone is adequate, you still need to implement the Cloneable interface, redefine clone to be public, and call super.clone(). The clone method that you just saw adds no functionality to the shallow copy provided by Object.clone. It merely makes the method public. class Employee implements Cloneable { // public access, change return type public Employee clone() throws CloneNotSupportedException { return (Employee) super.clone(); } . . . } Here is an example of a clone method that creates a deep copy: class Employee implements Cloneable { public Employee clone() throws CloneNotSupportedException { // call Object.clone() Employee cloned = (Employee) super.clone(); // clone mutable fields cloned.hireDay = (Date) hireDay.clone(); return cloned; } } The clone method of the Object class threatens to throw a CloneNotSupportedException \u2014it does that whenever clone is invoked on an object whose class does not implement the Cloneable interface. You have to be careful about cloning of subclasses. For example, once you have defined the clone method for the Employee class, anyone can use it to clone Manager objects. Can the Employee clone method do the job? It depends on the fields of the Manager class. In our case, there is no problem because the bonus field has primitive type. But Manager might have acquired fields that require a deep copy or are not cloneable. There is no guarantee that the implementor of the subclass has fixed clone to do the right thing. For that reason, the clone method is declared as protected in the Object class. But you don\u2019t have that luxury if you want the users of your classes to invoke clone. 4.2. Lambda Expressions A lambda expression is a block of code that you can pass around so it can be executed later, once or multiple times. 4.2.1. The Syntax of Lambda Expressions A simple form of lambda expressions in Java: parameters, the -> arrow, and an expression. If the code carries out a computation that doesn\u2019t fit in a single expression, write it exactly like you would have written a method: enclosed in {} and with explicit return statements. // FIRST (String first, String second) -> first.length() - second.length(); // SECOND (String first, String second) -> { if (first.length() < second.length()) return -1; else if (first.length() > second.length()) return 1; else return 0; } If a lambda expression has no parameters, you still supply empty parentheses () -> { for (int i = 100; i >= 0; i--) System.out.println(i); } If the parameter types of a lambda expression can be inferred, you can omit them. Comparator<String> comp = (first, second) // same as (String first, String second) -> first.length() - second.length(); If a method has a single parameter with inferred type, you can even omit the parentheses ActionListener listener = event -> System.out.println(\"The time is \" + Instant.ofEpochMilli(event.getWhen())); // instead of (event) -> . . . or (ActionEvent event) -> . . . You never specify the result type of a lambda expression. It is always inferred from context. The following can be used in a context where a result of type int is expected. (String first, String second) -> first.length() - second.length() 4.2.2. Functional Interfaces As we discussed, there are many existing interfaces in Java that encapsulate blocks of code, such as ActionListener or Comparator . Lambdas are compatible with these interfaces. You can supply a lambda expression whenever an object of an interface with a single abstract method is expected. Such an interface is called a functional interface. To demonstrate the conversion to a functional interface, consider the Arrays.sort method. Its second parameter requires an instance of Comparator , an interface with a single method. Simply supply a lambda. Behind the scenes, the Arrays.sort method receives an object of some class that implements Comparator<String> . Invoking the compare method on that object executes the body of the lambda expression. In fact, conversion to a functional interface is the only thing that you can do with a lambda expression in Java. Arrays.sort(words, (first, second) -> first.length() - second.length()); A particularly useful interface in the java.util.function package is Predicate : public interface Predicate<T> { boolean test(T t); // additional default and static methods } The ArrayList class has a removeIf method whose parameter is a Predicate . list.removeIf(e -> e == null); Another useful functional interface is Supplier<T> : public interface Supplier<T> { T get(); } A supplier has no arguments and yields a value of type T when it is called. Suppliers are used for lazy evaluation . For example, consider the call: LocalDate hireDay = Objects.requireNonNullElseGet(day, () -> new LocalDate.of(1970, 1, 1)); 4.2.3. Method References Sometimes, a lambda expression involves a single method. For example, suppose you simply want to print the event object whenever a timer event occurs. var timer = new Timer(1000, System.out::println); The expression System.out::println is a method reference. It directs the compiler to produce an instance of a functional interface, overriding the single abstract method of the interface to call the given method. In this example, an ActionListener is produced whose actionPerformed(ActionEvent e) method calls System.out.println(e) . Like a lambda expression, a method reference is not an object. It gives rise to an object when assigned to a variable whose type is a functional interface. The :: operator separates the method name from the name of an object or class. There are three variants: object::instanceMethod Class:instanceMethod Class:staticMethod Method Reference Equivalent Lambda Expression separator::equals x -> separator.equals(x) String::trim x -> x.strip() String::concat (x,y) -> x.concat(y) Integer::valueOf x -> Integer.valueOf(x) Integer::sum (x,y) -> Integer.sum(x,y) String::new x -> new String(x) String[]::new n -> new String[n] - NOTE: You can capture the this parameter in a method reference. For example, this::equals is the same as x -> this.equals(x) . It is also valid to use super . The method expression super::instanceMethod uses this as the target and invokes the superclass version of the given method. 4.2.4. Constructor References Constructor references are just like method references, except that the name of the method is new. For example, Person::new is a reference to a Person constructor. Which constructor? It depends on the context. ArrayList<String> names = . . .; Stream<Person> stream = names.stream().map(Person::new); List<Person> people = stream.toList(); 4.2.5. Variable Scope To understand what is happening, we need to refine our understanding of a lambda expression. A lambda expression has three ingredients: A block of code Parameters Values for the free variables\u2014that is, the variables that are not parameters and not defined inside the code The technical term for a block of code together with the values of the free variables is a closure . If someone gloats that their language has closures, rest assured that Java has them as well. In Java, lambda expressions are closures. As you have seen, a lambda expression can capture the value of a variable in the enclosing scope. Mutating variables in a lambda expression is not safe when multiple actions are executed concurrently. The rule is that any captured variable in a lambda expression must be effectively final . The body of a lambda expression has the same scope as a nested block. The same rules for name conflicts and shadowing apply. It is illegal to declare a parameter or a local variable in the lambda that has the same name as a local variable. 4.2.6. Processing Lambda Expressions Up to now, you have seen how to produce lambda expressions and pass them to a method that expects a functional interface. Now let us see how to write methods that can consume lambda expressions. The point of using lambdas is deferred execution . To accept the lambda, we need to pick (or, in rare cases, provide) a functional interface. Table below the most important functional interfaces that are provided in the Java API. NOTE: If you design your own interface with a single abstract method, you can tag it with the @FunctionalInterface annotation. This has two advantages. The compiler gives an error message if you accidentally add another abstract method. And the javadoc page includes a statement that your interface is a functional interface. It is not required to use the annotation. Any interface with a single abstract method is, by definition, a functional interface. But using the @FunctionalInterface annotation is a good idea. Functional Interface Parameter Types Return Type Abstract Method Name Description Other Methods Runnable none void run Runs an action without arguments or return value Supplier<T> none T get Supplies a value of type T Consumer<T> T void accept Consumes a value of type T andThen BiConsumer<T, U> T, U void accept Consumes values of types T and U andThen Function<T, R> T R apply A function with argument of type T compose , andThen , identity BiFunction<T, U, R> T, U R apply A function with arguments of types T and U andThen UnaryOperator<T> T T apply A unary operator on the type T compose , andThen , identity BinaryOperator<T> T, T T apply A binary operator on the type T andThen , maxBy , minBy Predicate<T> T boolean test A boolean-valued function and , or , negate , isEqual , not BiPredicate<T, U> T, U boolean test A boolean-valued function with two arguments and , or , negate 4.3. Inner Classes An inner class is a class that is defined inside another class. Why would you want to do that? There are two reasons: - Inner classes can be hidden from other classes in the same package. - Inner class methods can access the data from the scope in which they are defined\u2014including the data that would otherwise be private. An object that comes from an inner class has an implicit reference to the outer class object that instantiated it. Through this pointer, it gains access to the total state of the outer object. - For example, in Java, the Iterator class would not need an explicit pointer to the LinkedList into which it points. - An inner class object has a reference to an outer class object. - The syntax for the outer reference is the following OuterClass.this . - We could declare an inner class as private . Then only the outer class would be able to construct inner class objects. Only inner classes can be private. Regular classes always have either package or public access. - An inner class cannot have static methods. - Any static-fields declared in an inner class must be final and initialized with a compile-time constant. - The inner class can access the private data of the outer class, but the outer class cannot. Thus, inner classes are genuinely more powerful than regular classes because they have more access privileges. 4.3.1. Local Inner Classes You can define the class locally in a single method. public void start() { class TimePrinter implements ActionListener { public void actionPerformed(ActionEvent event) { System.out.println(\"At the tone, the time is \" + Instant.ofEpochMilli(event.getWhen())); if (beep) Toolkit.getDefaultToolkit().beep(); } } var listener = new TimePrinter(); var timer = new Timer(interval, listener); timer.start(); } Local classes are never declared with an access specifier (that is, public or private). Their scope is always restricted to the block in which they are declared. Local classes have one great advantage: They are completely hidden from the outside world. Local classes have another advantage over other inner classes. Not only can they access the fields of their outer classes; they can even access local variables ! However, those local variables must be effectively final. That means, they may never change once they have been assigned. 4.3.1.1. Anonymous Inner Classes If you want to make only a single object of this class, you don\u2019t even need to give the class a name. Such a class is called an anonymous inner class . public void start(int interval, boolean beep) { var listener = new ActionListener() { public void actionPerformed(ActionEvent event) { System.out.println(\"At the tone, the time is \" + Instant.ofEpochMilli(event.getWhen())); if (beep) Toolkit.getDefaultToolkit().beep(); } }; var timer = new Timer(interval, listener); timer.start(); } In general, the syntax is new SuperType(construction parameters) { inner class methods and data } Here, SuperType can be an interface , such as ActionListener; then, the inner class implements that interface . SuperType can also be a class ; then, the inner class extends that class. An anonymous inner class cannot have constructors because the name of a constructor must be the same as the name of a class, and the class has no name. Instead, the construction parameters are given to the superclass constructor. You have to look carefully to see the difference between the construction of a new object of a class and the construction of an object of an anonymous inner class extending that class. var queen = new Person(\"Mary\"); // a Person object var count = new Person(\"Dracula\") { . . . }; // an object of an inner class extending Person For many years, Java programmers routinely used anonymous inner classes for event listeners and other callbacks. Nowadays, you are better off using a lambda expression. public void start(int interval, boolean beep) { // Simply by using lambda var timer = new Timer(interval, event -> { System.out.println( \"At the tone, the time is \" + Instant.ofEpochMilli(event.getWhen())); if (beep) Toolkit.getDefaultToolkit().beep(); }); timer.start(); } NOTE: Double Brace Initialization The following trick, called double brace initialization, takes advantage of the inner class syntax. Suppose you want to construct an array list and pass it to a method: var friends = new ArrayList<String>(); friends.add(\"Harry\"); friends.add(\"Tony\"); invite(friends); If you don\u2019t need the array list again, it would be nice to make it anonymous. But then how can you add the elements? invite(new ArrayList<String>() {{ add(\"Harry\"); add(\"Ron\");}}); // double brace initialization var friends = new ArrayList<String>() { { add(\"Harry\"); add(\"Ron\"); } } Note the double braces. The outer braces make an anonymous subclass of ArrayList. The inner braces are an object initialization block (see previous chapter). 4.3.2. Static Inner Class Occasionally, you may want to use an inner class simply to hide one class inside another\u2014 but you don\u2019t need the inner class to have a reference to the outer class object. You can suppress the generation of that reference by declaring the inner class static . - Use a static inner class whenever the inner class does not need to access an outer class object. - Unlike regular inner classes, static inner classes can have static fields and methods. - Classes that are declared inside an interface are automatically static and public. - Interfaces, records, and enumerations that are declared inside a class are automatically static.","title":"Chapter 4: Interfaces, Lambda Expressions, and Inner Classes"},{"location":"java/chp4-interfaces/chp4-interfaces.html#chapter-4-interfaces-lambda-expressions-and-inner-classes","text":"","title":"Chapter 4: Interfaces, Lambda Expressions, and Inner Classes"},{"location":"java/chp4-interfaces/chp4-interfaces.html#41-interfaces","text":"An interface is not a class but a set of requirements for the classes that want to conform to the interface. All methods of an interface are automatically public . However, when implementing the interface, you must declare the method as public , as the default method definition makes it package accessible. If public keyword not provided, the compiler then complains that you're trying to supply a more restrictive access privilege. Interfaces can never have instance fields. Interfaces can define constants, e.g. static final variables. Fields that are defined in interfaces are always public static final . ```java public interface Powered extends Moveable { double milesPerGallon(); double SPEED_LIMIT = 95; } - It is possible to have `static` and `private` methods as well as `default` methods - Interfaces might be tedious when inheritance comes into play. - Since Manager extends Employee, it implements `Comparable<Employee>` and not `Comparable<Manager>`. If Manager chooses to override compareTo, it must be prepared to compare managers to employees. ```java class Manager extends Employee { public int compareTo(Employee other) { Manager otherManager = (Manager) other; // NO . . . } . . . } - This violates the `antisymmetry` rule: If x is an Employee and y is a Manager, then the call x.compareTo(y) doesn\u2019t throw an exception\u2014it simply compares x and y as employees. But the reverse, y.compareTo(x), throws a `ClassCastException`. - There are two possible remedies: - If subclasses have different notions of comparison, then you should outlaw comparison of objects that belong to different classes. ```java if (getClass() != other.getClass()) throw new ClassCastException(); - If there is a common algorithm for comparing subclass objects, simply provide a single `compareTo` method in the superclass and declare it as `final`. - Interfaces cannot be instantiated. - However, even though you can\u2019t construct interface objects, you can still declare interface variables (same as **abstract classes**). - An interface variable must refer to an object of a class that implements the interface. - Next, just as you use `instanceof` to check whether an object is of a specific class, you can use `instanceof` to check whether an object implements an interface. - Just as you can build hierarchies of classes, **you can extend interfaces.** - While each class can have **only one superclass**, classes **can implement multiple interfaces**. - **Records and enumeration classes cannot extend other classes (since they implicitly extend the Record and Enum class). However, they can implement interfaces.** - Interfaces can be `sealed`. - As with sealed classes, the direct subtypes (which can be classes or interfaces) must be declared in a permits clause or be located in the same source file. - **Interfaces vs Abstract Classes** - You may wonder why the designers of the Java programming language bothered with introducing the concept of interfaces. - There is, unfortunately, a major problem with using an abstract base class to express a generic property. A class can only extend a single class. - But each class can implement as many interfaces as it likes. - Other programming languages, in particular C++, allow a class to have more than one superclass. This feature is called **multiple inheritance**. - **Java does not support multiple inheritance.** - **Static and Private Methods** - As of Java 8, you are allowed to add static methods to interfaces. - Up to now, it has been common to place static methods in companion classes, e.g. `Paths` and `Collections` classes. However, when you implement your own interfaces, there is no longer a reason to provide a separate companion class for utility methods. - As of Java 9, methods in an interface can be `private`. A private method can be `static` or an `instance method`. **Since private methods can only be used in the methods of the interface itself, their use is limited to being helper methods for the other methods of the interface.** - **Default Methods** - You can supply a default implementation for any interface method. ```java public interface Comparable<T> { default int compareTo(T other) { return 0; } // by default, all elements are the same } - **Resolving Default Method Conflicts** - What happens if the exact same method is defined as a default method in one interface and then again as a method of a superclass or another interface? - Rules 1. Superclasses win. If a superclass provides a concrete method, default methods with the same name and parameter types are simply ignored. 2. Interfaces clash. If an interface provides a default method, and another interface contains a method with the same name and parameter types (default or not), then you must resolve the conflict by overriding that method. Interfaces and Callbacks A common pattern in programming is the callback pattern. In this pattern, you specify the action that should occur whenever a particular event happens. Interfaces allow implementing callbacks by enforcing what a class should do. In many programming languages, you supply the name of a function that the timer should call periodically. However, the classes in the Java standard library take an object- oriented approach. You pass an object of some class. The timer then calls one of the methods on that object. Passing an object is more flexible than passing a function because the object can carry additional information.","title":"4.1. Interfaces"},{"location":"java/chp4-interfaces/chp4-interfaces.html#object-cloning-and-cloneable-interface","text":"To understand what cloning means, recall what happens when you make a copy of a variable holding an object reference. The original and the copy are references to the same object. This means a change to either variable also affects the other. The clone method is a protected method of Object, which means that your code cannot simply call it. Only the Employee class can clone Employee objects. There is a reason for this restriction. Think about the way in which the Object class can implement clone. It knows nothing about the object at all, so it can make only a field-by-field copy. If all instance fields in the object are numbers or other basic types, copying the fields is just fine. But if the object contains references to subobjects, then copying the field gives you another reference to the same subobject, so the original and the cloned objects still share some information. As you can see, the default cloning operation is \u201cshallow\u201d\u2014it doesn\u2019t clone objects that are referenced inside other objects. Does it matter if the copy is shallow? It depends. If the subobject shared between the original and the shallow clone is immutable, then the sharing is safe. Quite frequently, however, subobjects are mutable, and you must redefine the clone method to make a deep copy that clones the subobjects as well. For every class, you need to decide whether: 1. The default clone method is good enough; 2. The default clone method can be patched up by calling clone on the mutable subobjects; or 3. clone should not be attempted. The third option is actually the default. To choose either the first or the second option, a class must 1. Implement the Cloneable interface; and 2. Redefine the clone method with the public access modifier. The clone method is declared protected in the Object class, so that your code can\u2019t simply call anObject.clone(). But aren\u2019t protected methods accessible from any subclass, and isn\u2019t every class a subclass of Object? Fortunately, the rules for protected access are more subtle. A subclass can call a protected clone method only to clone its own objects. You must redefine clone to be public to allow objects to be cloned by any method. A tagging interface has no methods; its only purpose is to allow the use of instanceof in a type inquiry. Even if the default (shallow copy) implementation of clone is adequate, you still need to implement the Cloneable interface, redefine clone to be public, and call super.clone(). The clone method that you just saw adds no functionality to the shallow copy provided by Object.clone. It merely makes the method public. class Employee implements Cloneable { // public access, change return type public Employee clone() throws CloneNotSupportedException { return (Employee) super.clone(); } . . . } Here is an example of a clone method that creates a deep copy: class Employee implements Cloneable { public Employee clone() throws CloneNotSupportedException { // call Object.clone() Employee cloned = (Employee) super.clone(); // clone mutable fields cloned.hireDay = (Date) hireDay.clone(); return cloned; } } The clone method of the Object class threatens to throw a CloneNotSupportedException \u2014it does that whenever clone is invoked on an object whose class does not implement the Cloneable interface. You have to be careful about cloning of subclasses. For example, once you have defined the clone method for the Employee class, anyone can use it to clone Manager objects. Can the Employee clone method do the job? It depends on the fields of the Manager class. In our case, there is no problem because the bonus field has primitive type. But Manager might have acquired fields that require a deep copy or are not cloneable. There is no guarantee that the implementor of the subclass has fixed clone to do the right thing. For that reason, the clone method is declared as protected in the Object class. But you don\u2019t have that luxury if you want the users of your classes to invoke clone.","title":"Object Cloning and Cloneable Interface"},{"location":"java/chp4-interfaces/chp4-interfaces.html#42-lambda-expressions","text":"A lambda expression is a block of code that you can pass around so it can be executed later, once or multiple times.","title":"4.2. Lambda Expressions"},{"location":"java/chp4-interfaces/chp4-interfaces.html#421-the-syntax-of-lambda-expressions","text":"A simple form of lambda expressions in Java: parameters, the -> arrow, and an expression. If the code carries out a computation that doesn\u2019t fit in a single expression, write it exactly like you would have written a method: enclosed in {} and with explicit return statements. // FIRST (String first, String second) -> first.length() - second.length(); // SECOND (String first, String second) -> { if (first.length() < second.length()) return -1; else if (first.length() > second.length()) return 1; else return 0; } If a lambda expression has no parameters, you still supply empty parentheses () -> { for (int i = 100; i >= 0; i--) System.out.println(i); } If the parameter types of a lambda expression can be inferred, you can omit them. Comparator<String> comp = (first, second) // same as (String first, String second) -> first.length() - second.length(); If a method has a single parameter with inferred type, you can even omit the parentheses ActionListener listener = event -> System.out.println(\"The time is \" + Instant.ofEpochMilli(event.getWhen())); // instead of (event) -> . . . or (ActionEvent event) -> . . . You never specify the result type of a lambda expression. It is always inferred from context. The following can be used in a context where a result of type int is expected. (String first, String second) -> first.length() - second.length()","title":"4.2.1. The Syntax of Lambda Expressions"},{"location":"java/chp4-interfaces/chp4-interfaces.html#422-functional-interfaces","text":"As we discussed, there are many existing interfaces in Java that encapsulate blocks of code, such as ActionListener or Comparator . Lambdas are compatible with these interfaces. You can supply a lambda expression whenever an object of an interface with a single abstract method is expected. Such an interface is called a functional interface. To demonstrate the conversion to a functional interface, consider the Arrays.sort method. Its second parameter requires an instance of Comparator , an interface with a single method. Simply supply a lambda. Behind the scenes, the Arrays.sort method receives an object of some class that implements Comparator<String> . Invoking the compare method on that object executes the body of the lambda expression. In fact, conversion to a functional interface is the only thing that you can do with a lambda expression in Java. Arrays.sort(words, (first, second) -> first.length() - second.length()); A particularly useful interface in the java.util.function package is Predicate : public interface Predicate<T> { boolean test(T t); // additional default and static methods } The ArrayList class has a removeIf method whose parameter is a Predicate . list.removeIf(e -> e == null); Another useful functional interface is Supplier<T> : public interface Supplier<T> { T get(); } A supplier has no arguments and yields a value of type T when it is called. Suppliers are used for lazy evaluation . For example, consider the call: LocalDate hireDay = Objects.requireNonNullElseGet(day, () -> new LocalDate.of(1970, 1, 1));","title":"4.2.2. Functional Interfaces"},{"location":"java/chp4-interfaces/chp4-interfaces.html#423-method-references","text":"Sometimes, a lambda expression involves a single method. For example, suppose you simply want to print the event object whenever a timer event occurs. var timer = new Timer(1000, System.out::println); The expression System.out::println is a method reference. It directs the compiler to produce an instance of a functional interface, overriding the single abstract method of the interface to call the given method. In this example, an ActionListener is produced whose actionPerformed(ActionEvent e) method calls System.out.println(e) . Like a lambda expression, a method reference is not an object. It gives rise to an object when assigned to a variable whose type is a functional interface. The :: operator separates the method name from the name of an object or class. There are three variants: object::instanceMethod Class:instanceMethod Class:staticMethod Method Reference Equivalent Lambda Expression separator::equals x -> separator.equals(x) String::trim x -> x.strip() String::concat (x,y) -> x.concat(y) Integer::valueOf x -> Integer.valueOf(x) Integer::sum (x,y) -> Integer.sum(x,y) String::new x -> new String(x) String[]::new n -> new String[n] - NOTE: You can capture the this parameter in a method reference. For example, this::equals is the same as x -> this.equals(x) . It is also valid to use super . The method expression super::instanceMethod uses this as the target and invokes the superclass version of the given method.","title":"4.2.3. Method References"},{"location":"java/chp4-interfaces/chp4-interfaces.html#424-constructor-references","text":"Constructor references are just like method references, except that the name of the method is new. For example, Person::new is a reference to a Person constructor. Which constructor? It depends on the context. ArrayList<String> names = . . .; Stream<Person> stream = names.stream().map(Person::new); List<Person> people = stream.toList();","title":"4.2.4. Constructor References"},{"location":"java/chp4-interfaces/chp4-interfaces.html#425-variable-scope","text":"To understand what is happening, we need to refine our understanding of a lambda expression. A lambda expression has three ingredients: A block of code Parameters Values for the free variables\u2014that is, the variables that are not parameters and not defined inside the code The technical term for a block of code together with the values of the free variables is a closure . If someone gloats that their language has closures, rest assured that Java has them as well. In Java, lambda expressions are closures. As you have seen, a lambda expression can capture the value of a variable in the enclosing scope. Mutating variables in a lambda expression is not safe when multiple actions are executed concurrently. The rule is that any captured variable in a lambda expression must be effectively final . The body of a lambda expression has the same scope as a nested block. The same rules for name conflicts and shadowing apply. It is illegal to declare a parameter or a local variable in the lambda that has the same name as a local variable.","title":"4.2.5. Variable Scope"},{"location":"java/chp4-interfaces/chp4-interfaces.html#426-processing-lambda-expressions","text":"Up to now, you have seen how to produce lambda expressions and pass them to a method that expects a functional interface. Now let us see how to write methods that can consume lambda expressions. The point of using lambdas is deferred execution . To accept the lambda, we need to pick (or, in rare cases, provide) a functional interface. Table below the most important functional interfaces that are provided in the Java API. NOTE: If you design your own interface with a single abstract method, you can tag it with the @FunctionalInterface annotation. This has two advantages. The compiler gives an error message if you accidentally add another abstract method. And the javadoc page includes a statement that your interface is a functional interface. It is not required to use the annotation. Any interface with a single abstract method is, by definition, a functional interface. But using the @FunctionalInterface annotation is a good idea. Functional Interface Parameter Types Return Type Abstract Method Name Description Other Methods Runnable none void run Runs an action without arguments or return value Supplier<T> none T get Supplies a value of type T Consumer<T> T void accept Consumes a value of type T andThen BiConsumer<T, U> T, U void accept Consumes values of types T and U andThen Function<T, R> T R apply A function with argument of type T compose , andThen , identity BiFunction<T, U, R> T, U R apply A function with arguments of types T and U andThen UnaryOperator<T> T T apply A unary operator on the type T compose , andThen , identity BinaryOperator<T> T, T T apply A binary operator on the type T andThen , maxBy , minBy Predicate<T> T boolean test A boolean-valued function and , or , negate , isEqual , not BiPredicate<T, U> T, U boolean test A boolean-valued function with two arguments and , or , negate","title":"4.2.6. Processing Lambda Expressions"},{"location":"java/chp4-interfaces/chp4-interfaces.html#43-inner-classes","text":"An inner class is a class that is defined inside another class. Why would you want to do that? There are two reasons: - Inner classes can be hidden from other classes in the same package. - Inner class methods can access the data from the scope in which they are defined\u2014including the data that would otherwise be private. An object that comes from an inner class has an implicit reference to the outer class object that instantiated it. Through this pointer, it gains access to the total state of the outer object. - For example, in Java, the Iterator class would not need an explicit pointer to the LinkedList into which it points. - An inner class object has a reference to an outer class object. - The syntax for the outer reference is the following OuterClass.this . - We could declare an inner class as private . Then only the outer class would be able to construct inner class objects. Only inner classes can be private. Regular classes always have either package or public access. - An inner class cannot have static methods. - Any static-fields declared in an inner class must be final and initialized with a compile-time constant. - The inner class can access the private data of the outer class, but the outer class cannot. Thus, inner classes are genuinely more powerful than regular classes because they have more access privileges.","title":"4.3. Inner Classes"},{"location":"java/chp4-interfaces/chp4-interfaces.html#431-local-inner-classes","text":"You can define the class locally in a single method. public void start() { class TimePrinter implements ActionListener { public void actionPerformed(ActionEvent event) { System.out.println(\"At the tone, the time is \" + Instant.ofEpochMilli(event.getWhen())); if (beep) Toolkit.getDefaultToolkit().beep(); } } var listener = new TimePrinter(); var timer = new Timer(interval, listener); timer.start(); } Local classes are never declared with an access specifier (that is, public or private). Their scope is always restricted to the block in which they are declared. Local classes have one great advantage: They are completely hidden from the outside world. Local classes have another advantage over other inner classes. Not only can they access the fields of their outer classes; they can even access local variables ! However, those local variables must be effectively final. That means, they may never change once they have been assigned.","title":"4.3.1. Local Inner Classes"},{"location":"java/chp4-interfaces/chp4-interfaces.html#4311-anonymous-inner-classes","text":"If you want to make only a single object of this class, you don\u2019t even need to give the class a name. Such a class is called an anonymous inner class . public void start(int interval, boolean beep) { var listener = new ActionListener() { public void actionPerformed(ActionEvent event) { System.out.println(\"At the tone, the time is \" + Instant.ofEpochMilli(event.getWhen())); if (beep) Toolkit.getDefaultToolkit().beep(); } }; var timer = new Timer(interval, listener); timer.start(); } In general, the syntax is new SuperType(construction parameters) { inner class methods and data } Here, SuperType can be an interface , such as ActionListener; then, the inner class implements that interface . SuperType can also be a class ; then, the inner class extends that class. An anonymous inner class cannot have constructors because the name of a constructor must be the same as the name of a class, and the class has no name. Instead, the construction parameters are given to the superclass constructor. You have to look carefully to see the difference between the construction of a new object of a class and the construction of an object of an anonymous inner class extending that class. var queen = new Person(\"Mary\"); // a Person object var count = new Person(\"Dracula\") { . . . }; // an object of an inner class extending Person For many years, Java programmers routinely used anonymous inner classes for event listeners and other callbacks. Nowadays, you are better off using a lambda expression. public void start(int interval, boolean beep) { // Simply by using lambda var timer = new Timer(interval, event -> { System.out.println( \"At the tone, the time is \" + Instant.ofEpochMilli(event.getWhen())); if (beep) Toolkit.getDefaultToolkit().beep(); }); timer.start(); } NOTE: Double Brace Initialization The following trick, called double brace initialization, takes advantage of the inner class syntax. Suppose you want to construct an array list and pass it to a method: var friends = new ArrayList<String>(); friends.add(\"Harry\"); friends.add(\"Tony\"); invite(friends); If you don\u2019t need the array list again, it would be nice to make it anonymous. But then how can you add the elements? invite(new ArrayList<String>() {{ add(\"Harry\"); add(\"Ron\");}}); // double brace initialization var friends = new ArrayList<String>() { { add(\"Harry\"); add(\"Ron\"); } } Note the double braces. The outer braces make an anonymous subclass of ArrayList. The inner braces are an object initialization block (see previous chapter).","title":"4.3.1.1. Anonymous Inner Classes"},{"location":"java/chp4-interfaces/chp4-interfaces.html#432-static-inner-class","text":"Occasionally, you may want to use an inner class simply to hide one class inside another\u2014 but you don\u2019t need the inner class to have a reference to the outer class object. You can suppress the generation of that reference by declaring the inner class static . - Use a static inner class whenever the inner class does not need to access an outer class object. - Unlike regular inner classes, static inner classes can have static fields and methods. - Classes that are declared inside an interface are automatically static and public. - Interfaces, records, and enumerations that are declared inside a class are automatically static.","title":"4.3.2. Static Inner Class"},{"location":"java/chp5-exception-handling-and-logging/chp5-exception-handling-and-logging.html","text":"Chapter 5: Exception Handling, Assertions, and Logging In the Java programming language, an exception object is always an instance of a class derived from Throwable . The Error hierarchy describes internal errors and resource exhaustion situations inside the Java runtime system. The Exception hierarchy also splits into two branches: exceptions that derive from RuntimeException and those that do not. The general rule is this: A RuntimeException happens because you made a programming error. Any other exception occurs because a bad thing, such as an I/O error, happened to your otherwise good program. The Java Language Specification calls any exception that derives from the class Error or the class RuntimeException an unchecked exception . All other exceptions are called checked exceptions. The compiler checks that you provide exception handlers for all checked exceptions. ![[exception-hierarchy.png]] As with Java methods that are part of the supplied classes, you declare that your method may throw an exception with an exception specification in the method header. In summary, a method must declare all the checked exceptions that it might throw. Unchecked exceptions are either beyond your control ( Error ) or result from conditions that you should not have allowed in the first place ( RuntimeException ). If your method fails to faithfully declare all checked exceptions, the compiler will issue an error message. Once a method throws an exception, it does not return to its caller. This means you do not have to worry about cooking up a default return value or an error code.","title":"Chapter 5: Exception Handling, Assertions, and Logging"},{"location":"java/chp5-exception-handling-and-logging/chp5-exception-handling-and-logging.html#chapter-5-exception-handling-assertions-and-logging","text":"In the Java programming language, an exception object is always an instance of a class derived from Throwable . The Error hierarchy describes internal errors and resource exhaustion situations inside the Java runtime system. The Exception hierarchy also splits into two branches: exceptions that derive from RuntimeException and those that do not. The general rule is this: A RuntimeException happens because you made a programming error. Any other exception occurs because a bad thing, such as an I/O error, happened to your otherwise good program. The Java Language Specification calls any exception that derives from the class Error or the class RuntimeException an unchecked exception . All other exceptions are called checked exceptions. The compiler checks that you provide exception handlers for all checked exceptions. ![[exception-hierarchy.png]] As with Java methods that are part of the supplied classes, you declare that your method may throw an exception with an exception specification in the method header. In summary, a method must declare all the checked exceptions that it might throw. Unchecked exceptions are either beyond your control ( Error ) or result from conditions that you should not have allowed in the first place ( RuntimeException ). If your method fails to faithfully declare all checked exceptions, the compiler will issue an error message. Once a method throws an exception, it does not return to its caller. This means you do not have to worry about cooking up a default return value or an error code.","title":"Chapter 5: Exception Handling, Assertions, and Logging"},{"location":"java/chp6-generic-programming/chp6-generic-programming.html","text":"Chapter 6: Generic Programming","title":"Chapter 6: Generic Programming"},{"location":"java/chp6-generic-programming/chp6-generic-programming.html#chapter-6-generic-programming","text":"","title":"Chapter 6: Generic Programming"},{"location":"java/chp7-collections/chp7-collections.html","text":"Chapter 7: Collections","title":"Chapter 7: Collections"},{"location":"java/chp7-collections/chp7-collections.html#chapter-7-collections","text":"","title":"Chapter 7: Collections"},{"location":"java/chp8-concurrency/chp8-concurrency.html","text":"","title":"Chp8 concurrency"}]}